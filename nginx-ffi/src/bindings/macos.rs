// cargo:warning=couldn't execute `llvm-config --prefix` (error: No such file or directory (os error 2))
// cargo:warning=set the LLVM_CONFIG_PATH environment variable to a valid `llvm-config` executable
/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub const NGX_OLDPID_EXT: &'static [u8; 8usize] = b".oldbin\0";
pub const NGX_HAVE_UNISTD_H: u32 = 1;
pub const NGX_HAVE_INTTYPES_H: u32 = 1;
pub const NGX_HAVE_LIMITS_H: u32 = 1;
pub const NGX_HAVE_SYS_FILIO_H: u32 = 1;
pub const NGX_HAVE_SYS_PARAM_H: u32 = 1;
pub const NGX_HAVE_SYS_MOUNT_H: u32 = 1;
pub const NGX_HAVE_SYS_STATVFS_H: u32 = 1;
pub const NGX_DARWIN: u32 = 1;
pub const NGX_CONFIGURE: &'static [u8; 38usize] = b" --builddir=build --prefix=/usr/local\0";
pub const NGX_COMPILER: &'static [u8; 34usize] = b"clang 10.0.0 (clang-1000.10.44.4)\0";
pub const NGX_HAVE_GCC_ATOMIC: u32 = 1;
pub const NGX_HAVE_C99_VARIADIC_MACROS: u32 = 1;
pub const NGX_HAVE_GCC_VARIADIC_MACROS: u32 = 1;
pub const NGX_HAVE_GCC_BSWAP64: u32 = 1;
pub const NGX_HAVE_KQUEUE: u32 = 1;
pub const NGX_HAVE_CLEAR_EVENT: u32 = 1;
pub const NGX_HAVE_TIMER_EVENT: u32 = 1;
pub const NGX_HAVE_SENDFILE: u32 = 1;
pub const NGX_DARWIN_ATOMIC: u32 = 1;
pub const NGX_HAVE_NONALIGNED: u32 = 1;
pub const NGX_CPU_CACHE_LINE: u32 = 64;
pub const NGX_HAVE_F_NOCACHE: u32 = 1;
pub const NGX_HAVE_STATFS: u32 = 1;
pub const NGX_HAVE_STATVFS: u32 = 1;
pub const NGX_HAVE_DLOPEN: u32 = 1;
pub const NGX_HAVE_SCHED_YIELD: u32 = 1;
pub const NGX_HAVE_REUSEPORT: u32 = 1;
pub const NGX_HAVE_IP_RECVDSTADDR: u32 = 1;
pub const NGX_HAVE_IP_PKTINFO: u32 = 1;
pub const NGX_HAVE_IPV6_RECVPKTINFO: u32 = 1;
pub const NGX_HAVE_TCP_FASTOPEN: u32 = 1;
pub const NGX_HAVE_UNIX_DOMAIN: u32 = 1;
pub const NGX_PTR_SIZE: u32 = 8;
pub const NGX_SIG_ATOMIC_T_SIZE: u32 = 4;
pub const NGX_HAVE_LITTLE_ENDIAN: u32 = 1;
pub const NGX_MAX_SIZE_T_VALUE: u64 = 9223372036854775807;
pub const NGX_MAX_OFF_T_VALUE: u64 = 9223372036854775807;
pub const NGX_TIME_T_SIZE: u32 = 8;
pub const NGX_MAX_TIME_T_VALUE: u64 = 9223372036854775807;
pub const NGX_HAVE_INET6: u32 = 1;
pub const NGX_HAVE_PREAD: u32 = 1;
pub const NGX_HAVE_PWRITE: u32 = 1;
pub const NGX_SYS_NERR: u32 = 107;
pub const NGX_HAVE_LOCALTIME_R: u32 = 1;
pub const NGX_HAVE_CLOCK_MONOTONIC: u32 = 1;
pub const NGX_HAVE_POSIX_MEMALIGN: u32 = 1;
pub const NGX_HAVE_MAP_ANON: u32 = 1;
pub const NGX_HAVE_SYSVSHM: u32 = 1;
pub const NGX_HAVE_MSGHDR_MSG_CONTROL: u32 = 1;
pub const NGX_HAVE_FIONBIO: u32 = 1;
pub const NGX_HAVE_FIONREAD: u32 = 1;
pub const NGX_HAVE_GMTOFF: u32 = 1;
pub const NGX_HAVE_D_NAMLEN: u32 = 1;
pub const NGX_HAVE_D_TYPE: u32 = 1;
pub const NGX_HAVE_SC_NPROCESSORS_ONLN: u32 = 1;
pub const NGX_HAVE_OPENAT: u32 = 1;
pub const NGX_HAVE_GETADDRINFO: u32 = 1;
pub const NGX_HTTP_CACHE: u32 = 1;
pub const NGX_HTTP_GZIP: u32 = 1;
pub const NGX_HTTP_SSI: u32 = 1;
pub const NGX_CRYPT: u32 = 1;
pub const NGX_HTTP_X_FORWARDED_FOR: u32 = 1;
pub const NGX_HTTP_UPSTREAM_ZONE: u32 = 1;
pub const NGX_PCRE: u32 = 1;
pub const NGX_HAVE_PCRE_JIT: u32 = 1;
pub const NGX_ZLIB: u32 = 1;
pub const NGX_PREFIX: &'static [u8; 12usize] = b"/usr/local/\0";
pub const NGX_CONF_PREFIX: &'static [u8; 6usize] = b"conf/\0";
pub const NGX_SBIN_PATH: &'static [u8; 11usize] = b"sbin/nginx\0";
pub const NGX_CONF_PATH: &'static [u8; 16usize] = b"conf/nginx.conf\0";
pub const NGX_PID_PATH: &'static [u8; 15usize] = b"logs/nginx.pid\0";
pub const NGX_LOCK_PATH: &'static [u8; 16usize] = b"logs/nginx.lock\0";
pub const NGX_ERROR_LOG_PATH: &'static [u8; 15usize] = b"logs/error.log\0";
pub const NGX_HTTP_LOG_PATH: &'static [u8; 16usize] = b"logs/access.log\0";
pub const NGX_HTTP_CLIENT_TEMP_PATH: &'static [u8; 17usize] = b"client_body_temp\0";
pub const NGX_HTTP_PROXY_TEMP_PATH: &'static [u8; 11usize] = b"proxy_temp\0";
pub const NGX_HTTP_FASTCGI_TEMP_PATH: &'static [u8; 13usize] = b"fastcgi_temp\0";
pub const NGX_HTTP_UWSGI_TEMP_PATH: &'static [u8; 11usize] = b"uwsgi_temp\0";
pub const NGX_HTTP_SCGI_TEMP_PATH: &'static [u8; 10usize] = b"scgi_temp\0";
pub const NGX_SUPPRESS_WARN: u32 = 1;
pub const NGX_SMP: u32 = 1;
pub const NGX_USER: &'static [u8; 7usize] = b"nobody\0";
pub const NGX_GROUP: &'static [u8; 7usize] = b"nobody\0";
pub const NGX_LISTEN_BACKLOG: i32 = -1;
pub const NGX_HAVE_INHERITED_NONBLOCK: u32 = 1;
pub const NGX_HAVE_CASELESS_FILESYSTEM: u32 = 1;
pub const NGX_HAVE_OS_SPECIFIC_INIT: u32 = 1;
pub const NGX_HAVE_DEBUG_MALLOC: u32 = 1;
pub const NGX_HAVE_SO_SNDLOWAT: u32 = 1;
pub const NGX_MAX_INT_T_VALUE: u64 = 9223372036854775807;
pub const NGX_INVALID_ARRAY_INDEX: u32 = 2147483648;
pub const NGX_MAXHOSTNAMELEN: u32 = 256;
pub const NGX_OK: u32 = 0;
pub const NGX_ERROR: i32 = -1;
pub const NGX_AGAIN: i32 = -2;
pub const NGX_BUSY: i32 = -3;
pub const NGX_DONE: i32 = -4;
pub const NGX_DECLINED: i32 = -5;
pub const NGX_ABORT: i32 = -6;
pub const NGX_EPERM: u32 = 1;
pub const NGX_ENOENT: u32 = 2;
pub const NGX_ENOPATH: u32 = 2;
pub const NGX_ESRCH: u32 = 3;
pub const NGX_EINTR: u32 = 4;
pub const NGX_ECHILD: u32 = 10;
pub const NGX_ENOMEM: u32 = 12;
pub const NGX_EACCES: u32 = 13;
pub const NGX_EBUSY: u32 = 16;
pub const NGX_EEXIST: u32 = 17;
pub const NGX_EEXIST_FILE: u32 = 17;
pub const NGX_EXDEV: u32 = 18;
pub const NGX_ENOTDIR: u32 = 20;
pub const NGX_EISDIR: u32 = 21;
pub const NGX_EINVAL: u32 = 22;
pub const NGX_ENFILE: u32 = 23;
pub const NGX_EMFILE: u32 = 24;
pub const NGX_ENOSPC: u32 = 28;
pub const NGX_EPIPE: u32 = 32;
pub const NGX_EINPROGRESS: u32 = 36;
pub const NGX_ENOPROTOOPT: u32 = 42;
pub const NGX_EOPNOTSUPP: u32 = 102;
pub const NGX_EADDRINUSE: u32 = 48;
pub const NGX_ECONNABORTED: u32 = 53;
pub const NGX_ECONNRESET: u32 = 54;
pub const NGX_ENOTCONN: u32 = 57;
pub const NGX_ETIMEDOUT: u32 = 60;
pub const NGX_ECONNREFUSED: u32 = 61;
pub const NGX_ENAMETOOLONG: u32 = 63;
pub const NGX_ENETDOWN: u32 = 50;
pub const NGX_ENETUNREACH: u32 = 51;
pub const NGX_EHOSTDOWN: u32 = 64;
pub const NGX_EHOSTUNREACH: u32 = 65;
pub const NGX_ENOSYS: u32 = 78;
pub const NGX_ECANCELED: u32 = 89;
pub const NGX_EILSEQ: u32 = 92;
pub const NGX_ENOMOREFILES: u32 = 0;
pub const NGX_ELOOP: u32 = 62;
pub const NGX_EBADF: u32 = 9;
pub const NGX_EMLINK: u32 = 31;
pub const NGX_EAGAIN: u32 = 35;
pub const NGX_HAVE_ATOMIC_OPS: u32 = 1;
pub const ngx_log_tid: u32 = 0;
pub const NGX_TID_T_FMT: &'static [u8; 3usize] = b"%d\0";
pub const NGX_WRITE_SHUTDOWN: u32 = 1;
pub const ngx_socket_n: &'static [u8; 9usize] = b"socket()\0";
pub const ngx_nonblocking_n: &'static [u8; 15usize] = b"ioctl(FIONBIO)\0";
pub const ngx_blocking_n: &'static [u8; 16usize] = b"ioctl(!FIONBIO)\0";
pub const ngx_socket_nread_n: &'static [u8; 16usize] = b"ioctl(FIONREAD)\0";
pub const ngx_tcp_nopush_n: &'static [u8; 23usize] = b"setsockopt(TCP_NOPUSH)\0";
pub const ngx_tcp_push_n: &'static [u8; 24usize] = b"setsockopt(!TCP_NOPUSH)\0";
pub const ngx_shutdown_socket_n: &'static [u8; 11usize] = b"shutdown()\0";
pub const ngx_close_socket_n: &'static [u8; 15usize] = b"close() socket\0";
pub const NGX_ESCAPE_URI: u32 = 0;
pub const NGX_ESCAPE_ARGS: u32 = 1;
pub const NGX_ESCAPE_URI_COMPONENT: u32 = 2;
pub const NGX_ESCAPE_HTML: u32 = 3;
pub const NGX_ESCAPE_REFRESH: u32 = 4;
pub const NGX_ESCAPE_MEMCACHED: u32 = 5;
pub const NGX_ESCAPE_MAIL_AUTH: u32 = 6;
pub const NGX_UNESCAPE_URI: u32 = 1;
pub const NGX_UNESCAPE_REDIRECT: u32 = 2;
pub const NGX_INVALID_FILE: i32 = -1;
pub const NGX_FILE_ERROR: i32 = -1;
pub const ngx_open_file_n: &'static [u8; 7usize] = b"open()\0";
pub const NGX_FILE_RDONLY: u32 = 0;
pub const NGX_FILE_WRONLY: u32 = 1;
pub const NGX_FILE_RDWR: u32 = 2;
pub const NGX_FILE_CREATE_OR_OPEN: u32 = 512;
pub const NGX_FILE_OPEN: u32 = 0;
pub const NGX_FILE_TRUNCATE: u32 = 1536;
pub const NGX_FILE_APPEND: u32 = 9;
pub const NGX_FILE_NONBLOCK: u32 = 4;
pub const NGX_FILE_NOFOLLOW: u32 = 256;
pub const NGX_FILE_DIRECTORY: u32 = 1048576;
pub const NGX_FILE_SEARCH: u32 = 1048576;
pub const NGX_FILE_DEFAULT_ACCESS: u32 = 420;
pub const NGX_FILE_OWNER_ACCESS: u32 = 384;
pub const ngx_close_file_n: &'static [u8; 8usize] = b"close()\0";
pub const ngx_delete_file_n: &'static [u8; 9usize] = b"unlink()\0";
pub const ngx_open_tempfile_n: &'static [u8; 7usize] = b"open()\0";
pub const ngx_read_file_n: &'static [u8; 8usize] = b"pread()\0";
pub const ngx_read_fd_n: &'static [u8; 7usize] = b"read()\0";
pub const ngx_write_fd_n: &'static [u8; 8usize] = b"write()\0";
pub const NGX_LINEFEED_SIZE: u32 = 1;
pub const NGX_LINEFEED: &'static [u8; 2usize] = b"\n\0";
pub const ngx_rename_file_n: &'static [u8; 9usize] = b"rename()\0";
pub const ngx_change_file_access_n: &'static [u8; 8usize] = b"chmod()\0";
pub const ngx_set_file_time_n: &'static [u8; 9usize] = b"utimes()\0";
pub const ngx_file_info_n: &'static [u8; 7usize] = b"stat()\0";
pub const ngx_fd_info_n: &'static [u8; 8usize] = b"fstat()\0";
pub const ngx_link_info_n: &'static [u8; 8usize] = b"lstat()\0";
pub const ngx_realpath_n: &'static [u8; 11usize] = b"realpath()\0";
pub const ngx_getcwd_n: &'static [u8; 9usize] = b"getcwd()\0";
pub const NGX_HAVE_MAX_PATH: u32 = 1;
pub const NGX_MAX_PATH: u32 = 1024;
pub const ngx_open_dir_n: &'static [u8; 10usize] = b"opendir()\0";
pub const ngx_close_dir_n: &'static [u8; 11usize] = b"closedir()\0";
pub const ngx_read_dir_n: &'static [u8; 10usize] = b"readdir()\0";
pub const ngx_create_dir_n: &'static [u8; 8usize] = b"mkdir()\0";
pub const ngx_delete_dir_n: &'static [u8; 8usize] = b"rmdir()\0";
pub const ngx_de_info_n: &'static [u8; 7usize] = b"stat()\0";
pub const ngx_de_link_info_n: &'static [u8; 8usize] = b"lstat()\0";
pub const ngx_open_glob_n: &'static [u8; 7usize] = b"glob()\0";
pub const ngx_trylock_fd_n: &'static [u8; 24usize] = b"fcntl(F_SETLK, F_WRLCK)\0";
pub const ngx_lock_fd_n: &'static [u8; 25usize] = b"fcntl(F_SETLKW, F_WRLCK)\0";
pub const ngx_unlock_fd_n: &'static [u8; 24usize] = b"fcntl(F_SETLK, F_UNLCK)\0";
pub const ngx_read_ahead_n: &'static [u8; 17usize] = b"ngx_read_ahead_n\0";
pub const ngx_directio_on_n: &'static [u8; 20usize] = b"fcntl(F_NOCACHE, 1)\0";
pub const ngx_openat_file_n: &'static [u8; 9usize] = b"openat()\0";
pub const ngx_file_at_info_n: &'static [u8; 10usize] = b"fstatat()\0";
pub const ngx_stdout: u32 = 1;
pub const ngx_stderr: u32 = 2;
pub const ngx_set_stderr_n: &'static [u8; 20usize] = b"dup2(STDERR_FILENO)\0";
pub const NGX_SETPROCTITLE_USES_ENV: u32 = 1;
pub const NGX_SETPROCTITLE_PAD: u8 = 0u8;
pub const NGX_INVALID_PID: i32 = -1;
pub const NGX_MAX_PROCESSES: u32 = 1024;
pub const NGX_PROCESS_NORESPAWN: i32 = -1;
pub const NGX_PROCESS_JUST_SPAWN: i32 = -2;
pub const NGX_PROCESS_RESPAWN: i32 = -3;
pub const NGX_PROCESS_JUST_RESPAWN: i32 = -4;
pub const NGX_PROCESS_DETACHED: i32 = -5;
pub const ngx_dlopen_n: &'static [u8; 9usize] = b"dlopen()\0";
pub const ngx_dlsym_n: &'static [u8; 8usize] = b"dlsym()\0";
pub const ngx_dlclose_n: &'static [u8; 10usize] = b"dlclose()\0";
pub const NGX_LOG_STDERR: u32 = 0;
pub const NGX_LOG_EMERG: u32 = 1;
pub const NGX_LOG_ALERT: u32 = 2;
pub const NGX_LOG_CRIT: u32 = 3;
pub const NGX_LOG_ERR: u32 = 4;
pub const NGX_LOG_WARN: u32 = 5;
pub const NGX_LOG_NOTICE: u32 = 6;
pub const NGX_LOG_INFO: u32 = 7;
pub const NGX_LOG_DEBUG: u32 = 8;
pub const NGX_LOG_DEBUG_CORE: u32 = 16;
pub const NGX_LOG_DEBUG_ALLOC: u32 = 32;
pub const NGX_LOG_DEBUG_MUTEX: u32 = 64;
pub const NGX_LOG_DEBUG_EVENT: u32 = 128;
pub const NGX_LOG_DEBUG_HTTP: u32 = 256;
pub const NGX_LOG_DEBUG_MAIL: u32 = 512;
pub const NGX_LOG_DEBUG_STREAM: u32 = 1024;
pub const NGX_LOG_DEBUG_FIRST: u32 = 16;
pub const NGX_LOG_DEBUG_LAST: u32 = 1024;
pub const NGX_LOG_DEBUG_CONNECTION: u32 = 2147483648;
pub const NGX_LOG_DEBUG_ALL: u32 = 2147483632;
pub const NGX_MAX_ERROR_STR: u32 = 2048;
pub const NGX_HAVE_VARIADIC_MACROS: u32 = 1;
pub const NGX_DEFAULT_POOL_SIZE: u32 = 16384;
pub const NGX_POOL_ALIGNMENT: u32 = 16;
pub const NGX_HASH_SMALL: u32 = 1;
pub const NGX_HASH_LARGE: u32 = 2;
pub const NGX_HASH_LARGE_ASIZE: u32 = 16384;
pub const NGX_HASH_LARGE_HSIZE: u32 = 10007;
pub const NGX_HASH_WILDCARD_KEY: u32 = 1;
pub const NGX_HASH_READONLY_KEY: u32 = 2;
pub const NGX_MAX_PATH_LEVEL: u32 = 3;
pub const NGX_REGEX_NO_MATCHED: i32 = -1;
pub const NGX_REGEX_CASELESS: u32 = 1;
pub const ngx_regex_exec_n: &'static [u8; 12usize] = b"pcre_exec()\0";
pub const ngx_next_time_n: &'static [u8; 9usize] = b"mktime()\0";
pub const NGX_CYCLE_POOL_SIZE: u32 = 16384;
pub const NGX_DEBUG_POINTS_STOP: u32 = 1;
pub const NGX_DEBUG_POINTS_ABORT: u32 = 2;
pub const NGX_RESOLVE_A: u32 = 1;
pub const NGX_RESOLVE_CNAME: u32 = 5;
pub const NGX_RESOLVE_PTR: u32 = 12;
pub const NGX_RESOLVE_MX: u32 = 15;
pub const NGX_RESOLVE_TXT: u32 = 16;
pub const NGX_RESOLVE_AAAA: u32 = 28;
pub const NGX_RESOLVE_SRV: u32 = 33;
pub const NGX_RESOLVE_DNAME: u32 = 39;
pub const NGX_RESOLVE_FORMERR: u32 = 1;
pub const NGX_RESOLVE_SERVFAIL: u32 = 2;
pub const NGX_RESOLVE_NXDOMAIN: u32 = 3;
pub const NGX_RESOLVE_NOTIMP: u32 = 4;
pub const NGX_RESOLVE_REFUSED: u32 = 5;
pub const NGX_RESOLVE_TIMEDOUT: u32 = 60;
pub const NGX_RESOLVER_MAX_RECURSION: u32 = 50;
pub const NGX_CMD_OPEN_CHANNEL: u32 = 1;
pub const NGX_CMD_CLOSE_CHANNEL: u32 = 2;
pub const NGX_CMD_QUIT: u32 = 3;
pub const NGX_CMD_TERMINATE: u32 = 4;
pub const NGX_CMD_REOPEN: u32 = 5;
pub const NGX_PROCESS_SINGLE: u32 = 0;
pub const NGX_PROCESS_MASTER: u32 = 1;
pub const NGX_PROCESS_SIGNALLER: u32 = 2;
pub const NGX_PROCESS_WORKER: u32 = 3;
pub const NGX_PROCESS_HELPER: u32 = 4;
pub const NGX_CONF_NOARGS: u32 = 1;
pub const NGX_CONF_TAKE1: u32 = 2;
pub const NGX_CONF_TAKE2: u32 = 4;
pub const NGX_CONF_TAKE3: u32 = 8;
pub const NGX_CONF_TAKE4: u32 = 16;
pub const NGX_CONF_TAKE5: u32 = 32;
pub const NGX_CONF_TAKE6: u32 = 64;
pub const NGX_CONF_TAKE7: u32 = 128;
pub const NGX_CONF_MAX_ARGS: u32 = 8;
pub const NGX_CONF_TAKE12: u32 = 6;
pub const NGX_CONF_TAKE13: u32 = 10;
pub const NGX_CONF_TAKE23: u32 = 12;
pub const NGX_CONF_TAKE123: u32 = 14;
pub const NGX_CONF_TAKE1234: u32 = 30;
pub const NGX_CONF_ARGS_NUMBER: u32 = 255;
pub const NGX_CONF_BLOCK: u32 = 256;
pub const NGX_CONF_FLAG: u32 = 512;
pub const NGX_CONF_ANY: u32 = 1024;
pub const NGX_CONF_1MORE: u32 = 2048;
pub const NGX_CONF_2MORE: u32 = 4096;
pub const NGX_DIRECT_CONF: u32 = 65536;
pub const NGX_MAIN_CONF: u32 = 16777216;
pub const NGX_ANY_CONF: u32 = 4278190080;
pub const NGX_CONF_UNSET: i32 = -1;
pub const NGX_CONF_BLOCK_START: u32 = 1;
pub const NGX_CONF_BLOCK_DONE: u32 = 2;
pub const NGX_CONF_FILE_DONE: u32 = 3;
pub const NGX_CORE_MODULE: u32 = 1163022147;
pub const NGX_CONF_MODULE: u32 = 1179537219;
pub const NGX_MAX_CONF_ERRSTR: u32 = 1024;
pub const NGX_CONF_BITMASK_SET: u32 = 1;
pub const NGX_MODULE_SIGNATURE_1: &'static [u8; 2usize] = b"1\0";
pub const NGX_MODULE_SIGNATURE_2: &'static [u8; 2usize] = b"0\0";
pub const NGX_MODULE_SIGNATURE_3: &'static [u8; 2usize] = b"0\0";
pub const NGX_MODULE_SIGNATURE_4: &'static [u8; 2usize] = b"0\0";
pub const NGX_MODULE_SIGNATURE_5: &'static [u8; 2usize] = b"0\0";
pub const NGX_MODULE_SIGNATURE_6: &'static [u8; 2usize] = b"0\0";
pub const NGX_MODULE_SIGNATURE_7: &'static [u8; 2usize] = b"0\0";
pub const NGX_MODULE_SIGNATURE_8: &'static [u8; 2usize] = b"1\0";
pub const NGX_MODULE_SIGNATURE_9: &'static [u8; 2usize] = b"1\0";
pub const NGX_MODULE_SIGNATURE_10: &'static [u8; 2usize] = b"1\0";
pub const NGX_MODULE_SIGNATURE_11: &'static [u8; 2usize] = b"0\0";
pub const NGX_MODULE_SIGNATURE_12: &'static [u8; 2usize] = b"1\0";
pub const NGX_MODULE_SIGNATURE_13: &'static [u8; 2usize] = b"0\0";
pub const NGX_MODULE_SIGNATURE_14: &'static [u8; 2usize] = b"1\0";
pub const NGX_MODULE_SIGNATURE_15: &'static [u8; 2usize] = b"1\0";
pub const NGX_MODULE_SIGNATURE_16: &'static [u8; 2usize] = b"1\0";
pub const NGX_MODULE_SIGNATURE_17: &'static [u8; 2usize] = b"0\0";
pub const NGX_MODULE_SIGNATURE_18: &'static [u8; 2usize] = b"0\0";
pub const NGX_MODULE_SIGNATURE_19: &'static [u8; 2usize] = b"1\0";
pub const NGX_MODULE_SIGNATURE_20: &'static [u8; 2usize] = b"1\0";
pub const NGX_MODULE_SIGNATURE_21: &'static [u8; 2usize] = b"0\0";
pub const NGX_MODULE_SIGNATURE_22: &'static [u8; 2usize] = b"0\0";
pub const NGX_MODULE_SIGNATURE_23: &'static [u8; 2usize] = b"1\0";
pub const NGX_MODULE_SIGNATURE_24: &'static [u8; 2usize] = b"0\0";
pub const NGX_MODULE_SIGNATURE_25: &'static [u8; 2usize] = b"1\0";
pub const NGX_MODULE_SIGNATURE_26: &'static [u8; 2usize] = b"1\0";
pub const NGX_MODULE_SIGNATURE_27: &'static [u8; 2usize] = b"1\0";
pub const NGX_MODULE_SIGNATURE_28: &'static [u8; 2usize] = b"1\0";
pub const NGX_MODULE_SIGNATURE_29: &'static [u8; 2usize] = b"0\0";
pub const NGX_MODULE_SIGNATURE_30: &'static [u8; 2usize] = b"0\0";
pub const NGX_MODULE_SIGNATURE_31: &'static [u8; 2usize] = b"0\0";
pub const NGX_MODULE_SIGNATURE_32: &'static [u8; 2usize] = b"1\0";
pub const NGX_MODULE_SIGNATURE_33: &'static [u8; 2usize] = b"1\0";
pub const NGX_MODULE_SIGNATURE_34: &'static [u8; 2usize] = b"0\0";
pub const NGX_OPEN_FILE_DIRECTIO_OFF: u64 = 9223372036854775807;
pub const NGX_IO_SENDFILE: u32 = 1;
pub const NGX_IOVS_PREALLOCATE: u32 = 64;
pub const NGX_LOWLEVEL_BUFFERED: u32 = 15;
pub const NGX_SSL_BUFFERED: u32 = 1;
pub const NGX_HTTP_V2_BUFFERED: u32 = 2;
pub const NGX_PROXY_PROTOCOL_MAX_HEADER: u32 = 107;
pub const NGX_DISABLE_SYMLINKS_OFF: u32 = 0;
pub const NGX_DISABLE_SYMLINKS_ON: u32 = 1;
pub const NGX_DISABLE_SYMLINKS_NOTOWNER: u32 = 2;
pub const NGX_HTTP_VAR_CHANGEABLE: u32 = 1;
pub const NGX_HTTP_VAR_NOCACHEABLE: u32 = 2;
pub const NGX_HTTP_VAR_INDEXED: u32 = 4;
pub const NGX_HTTP_VAR_NOHASH: u32 = 8;
pub const NGX_HTTP_VAR_WEAK: u32 = 16;
pub const NGX_HTTP_VAR_PREFIX: u32 = 32;
pub const NGX_HTTP_MODULE: u32 = 1347703880;
pub const NGX_HTTP_MAIN_CONF: u32 = 33554432;
pub const NGX_HTTP_SRV_CONF: u32 = 67108864;
pub const NGX_HTTP_LOC_CONF: u32 = 134217728;
pub const NGX_HTTP_UPS_CONF: u32 = 268435456;
pub const NGX_HTTP_SIF_CONF: u32 = 536870912;
pub const NGX_HTTP_LIF_CONF: u32 = 1073741824;
pub const NGX_HTTP_LMT_CONF: u32 = 2147483648;
pub const NGX_HTTP_MAX_URI_CHANGES: u32 = 10;
pub const NGX_HTTP_MAX_SUBREQUESTS: u32 = 50;
pub const NGX_HTTP_LC_HEADER_LEN: u32 = 32;
pub const NGX_HTTP_DISCARD_BUFFER_SIZE: u32 = 4096;
pub const NGX_HTTP_LINGERING_BUFFER_SIZE: u32 = 4096;
pub const NGX_HTTP_VERSION_9: u32 = 9;
pub const NGX_HTTP_VERSION_10: u32 = 1000;
pub const NGX_HTTP_VERSION_11: u32 = 1001;
pub const NGX_HTTP_VERSION_20: u32 = 2000;
pub const NGX_HTTP_UNKNOWN: u32 = 1;
pub const NGX_HTTP_GET: u32 = 2;
pub const NGX_HTTP_HEAD: u32 = 4;
pub const NGX_HTTP_POST: u32 = 8;
pub const NGX_HTTP_PUT: u32 = 16;
pub const NGX_HTTP_DELETE: u32 = 32;
pub const NGX_HTTP_MKCOL: u32 = 64;
pub const NGX_HTTP_COPY: u32 = 128;
pub const NGX_HTTP_MOVE: u32 = 256;
pub const NGX_HTTP_OPTIONS: u32 = 512;
pub const NGX_HTTP_PROPFIND: u32 = 1024;
pub const NGX_HTTP_PROPPATCH: u32 = 2048;
pub const NGX_HTTP_LOCK: u32 = 4096;
pub const NGX_HTTP_UNLOCK: u32 = 8192;
pub const NGX_HTTP_PATCH: u32 = 16384;
pub const NGX_HTTP_TRACE: u32 = 32768;
pub const NGX_HTTP_CONNECTION_CLOSE: u32 = 1;
pub const NGX_HTTP_CONNECTION_KEEP_ALIVE: u32 = 2;
pub const NGX_NONE: u32 = 1;
pub const NGX_HTTP_PARSE_HEADER_DONE: u32 = 1;
pub const NGX_HTTP_CLIENT_ERROR: u32 = 10;
pub const NGX_HTTP_PARSE_INVALID_METHOD: u32 = 10;
pub const NGX_HTTP_PARSE_INVALID_REQUEST: u32 = 11;
pub const NGX_HTTP_PARSE_INVALID_VERSION: u32 = 12;
pub const NGX_HTTP_PARSE_INVALID_09_METHOD: u32 = 13;
pub const NGX_HTTP_PARSE_INVALID_HEADER: u32 = 14;
pub const NGX_HTTP_SUBREQUEST_IN_MEMORY: u32 = 2;
pub const NGX_HTTP_SUBREQUEST_WAITED: u32 = 4;
pub const NGX_HTTP_SUBREQUEST_CLONE: u32 = 8;
pub const NGX_HTTP_SUBREQUEST_BACKGROUND: u32 = 16;
pub const NGX_HTTP_LOG_UNSAFE: u32 = 1;
pub const NGX_HTTP_CONTINUE: u32 = 100;
pub const NGX_HTTP_SWITCHING_PROTOCOLS: u32 = 101;
pub const NGX_HTTP_PROCESSING: u32 = 102;
pub const NGX_HTTP_OK: u32 = 200;
pub const NGX_HTTP_CREATED: u32 = 201;
pub const NGX_HTTP_ACCEPTED: u32 = 202;
pub const NGX_HTTP_NO_CONTENT: u32 = 204;
pub const NGX_HTTP_PARTIAL_CONTENT: u32 = 206;
pub const NGX_HTTP_SPECIAL_RESPONSE: u32 = 300;
pub const NGX_HTTP_MOVED_PERMANENTLY: u32 = 301;
pub const NGX_HTTP_MOVED_TEMPORARILY: u32 = 302;
pub const NGX_HTTP_SEE_OTHER: u32 = 303;
pub const NGX_HTTP_NOT_MODIFIED: u32 = 304;
pub const NGX_HTTP_TEMPORARY_REDIRECT: u32 = 307;
pub const NGX_HTTP_PERMANENT_REDIRECT: u32 = 308;
pub const NGX_HTTP_BAD_REQUEST: u32 = 400;
pub const NGX_HTTP_UNAUTHORIZED: u32 = 401;
pub const NGX_HTTP_FORBIDDEN: u32 = 403;
pub const NGX_HTTP_NOT_FOUND: u32 = 404;
pub const NGX_HTTP_NOT_ALLOWED: u32 = 405;
pub const NGX_HTTP_REQUEST_TIME_OUT: u32 = 408;
pub const NGX_HTTP_CONFLICT: u32 = 409;
pub const NGX_HTTP_LENGTH_REQUIRED: u32 = 411;
pub const NGX_HTTP_PRECONDITION_FAILED: u32 = 412;
pub const NGX_HTTP_REQUEST_ENTITY_TOO_LARGE: u32 = 413;
pub const NGX_HTTP_REQUEST_URI_TOO_LARGE: u32 = 414;
pub const NGX_HTTP_UNSUPPORTED_MEDIA_TYPE: u32 = 415;
pub const NGX_HTTP_RANGE_NOT_SATISFIABLE: u32 = 416;
pub const NGX_HTTP_MISDIRECTED_REQUEST: u32 = 421;
pub const NGX_HTTP_TOO_MANY_REQUESTS: u32 = 429;
pub const NGX_HTTP_CLOSE: u32 = 444;
pub const NGX_HTTP_NGINX_CODES: u32 = 494;
pub const NGX_HTTP_REQUEST_HEADER_TOO_LARGE: u32 = 494;
pub const NGX_HTTPS_CERT_ERROR: u32 = 495;
pub const NGX_HTTPS_NO_CERT: u32 = 496;
pub const NGX_HTTP_TO_HTTPS: u32 = 497;
pub const NGX_HTTP_CLIENT_CLOSED_REQUEST: u32 = 499;
pub const NGX_HTTP_INTERNAL_SERVER_ERROR: u32 = 500;
pub const NGX_HTTP_NOT_IMPLEMENTED: u32 = 501;
pub const NGX_HTTP_BAD_GATEWAY: u32 = 502;
pub const NGX_HTTP_SERVICE_UNAVAILABLE: u32 = 503;
pub const NGX_HTTP_GATEWAY_TIME_OUT: u32 = 504;
pub const NGX_HTTP_VERSION_NOT_SUPPORTED: u32 = 505;
pub const NGX_HTTP_INSUFFICIENT_STORAGE: u32 = 507;
pub const NGX_HTTP_LOWLEVEL_BUFFERED: u32 = 240;
pub const NGX_HTTP_WRITE_BUFFERED: u32 = 16;
pub const NGX_HTTP_GZIP_BUFFERED: u32 = 32;
pub const NGX_HTTP_SSI_BUFFERED: u32 = 1;
pub const NGX_HTTP_SUB_BUFFERED: u32 = 2;
pub const NGX_HTTP_COPY_BUFFERED: u32 = 4;
pub const NGX_INVALID_INDEX: u32 = 3503345872;
pub const NGX_USE_LEVEL_EVENT: u32 = 1;
pub const NGX_USE_ONESHOT_EVENT: u32 = 2;
pub const NGX_USE_CLEAR_EVENT: u32 = 4;
pub const NGX_USE_KQUEUE_EVENT: u32 = 8;
pub const NGX_USE_LOWAT_EVENT: u32 = 16;
pub const NGX_USE_GREEDY_EVENT: u32 = 32;
pub const NGX_USE_EPOLL_EVENT: u32 = 64;
pub const NGX_USE_RTSIG_EVENT: u32 = 128;
pub const NGX_USE_AIO_EVENT: u32 = 256;
pub const NGX_USE_IOCP_EVENT: u32 = 512;
pub const NGX_USE_FD_EVENT: u32 = 1024;
pub const NGX_USE_TIMER_EVENT: u32 = 2048;
pub const NGX_USE_EVENTPORT_EVENT: u32 = 4096;
pub const NGX_USE_VNODE_EVENT: u32 = 8192;
pub const NGX_CLOSE_EVENT: u32 = 1;
pub const NGX_DISABLE_EVENT: u32 = 2;
pub const NGX_FLUSH_EVENT: u32 = 4;
pub const NGX_LOWAT_EVENT: u32 = 0;
pub const NGX_VNODE_EVENT: u32 = 0;
pub const NGX_READ_EVENT: i32 = -1;
pub const NGX_WRITE_EVENT: i32 = -2;
pub const NGX_LEVEL_EVENT: u32 = 0;
pub const NGX_ONESHOT_EVENT: u32 = 16;
pub const NGX_CLEAR_EVENT: u32 = 32;
pub const NGX_EVENT_MODULE: u32 = 1414420037;
pub const NGX_EVENT_CONF: u32 = 33554432;
pub const NGX_UPDATE_TIME: u32 = 1;
pub const NGX_POST_EVENTS: u32 = 2;
pub const NGX_TIMER_LAZY_DELAY: u32 = 300;
pub const NGX_PEER_KEEPALIVE: u32 = 1;
pub const NGX_PEER_NEXT: u32 = 2;
pub const NGX_PEER_FAILED: u32 = 4;
pub const NGX_HTTP_UPSTREAM_FT_ERROR: u32 = 2;
pub const NGX_HTTP_UPSTREAM_FT_TIMEOUT: u32 = 4;
pub const NGX_HTTP_UPSTREAM_FT_INVALID_HEADER: u32 = 8;
pub const NGX_HTTP_UPSTREAM_FT_HTTP_500: u32 = 16;
pub const NGX_HTTP_UPSTREAM_FT_HTTP_502: u32 = 32;
pub const NGX_HTTP_UPSTREAM_FT_HTTP_503: u32 = 64;
pub const NGX_HTTP_UPSTREAM_FT_HTTP_504: u32 = 128;
pub const NGX_HTTP_UPSTREAM_FT_HTTP_403: u32 = 256;
pub const NGX_HTTP_UPSTREAM_FT_HTTP_404: u32 = 512;
pub const NGX_HTTP_UPSTREAM_FT_HTTP_429: u32 = 1024;
pub const NGX_HTTP_UPSTREAM_FT_UPDATING: u32 = 2048;
pub const NGX_HTTP_UPSTREAM_FT_BUSY_LOCK: u32 = 4096;
pub const NGX_HTTP_UPSTREAM_FT_MAX_WAITING: u32 = 8192;
pub const NGX_HTTP_UPSTREAM_FT_NON_IDEMPOTENT: u32 = 16384;
pub const NGX_HTTP_UPSTREAM_FT_NOLIVE: u32 = 1073741824;
pub const NGX_HTTP_UPSTREAM_FT_OFF: u32 = 2147483648;
pub const NGX_HTTP_UPSTREAM_FT_STATUS: u32 = 2032;
pub const NGX_HTTP_UPSTREAM_INVALID_HEADER: u32 = 40;
pub const NGX_HTTP_UPSTREAM_IGN_XA_REDIRECT: u32 = 2;
pub const NGX_HTTP_UPSTREAM_IGN_XA_EXPIRES: u32 = 4;
pub const NGX_HTTP_UPSTREAM_IGN_EXPIRES: u32 = 8;
pub const NGX_HTTP_UPSTREAM_IGN_CACHE_CONTROL: u32 = 16;
pub const NGX_HTTP_UPSTREAM_IGN_SET_COOKIE: u32 = 32;
pub const NGX_HTTP_UPSTREAM_IGN_XA_LIMIT_RATE: u32 = 64;
pub const NGX_HTTP_UPSTREAM_IGN_XA_BUFFERING: u32 = 128;
pub const NGX_HTTP_UPSTREAM_IGN_XA_CHARSET: u32 = 256;
pub const NGX_HTTP_UPSTREAM_IGN_VARY: u32 = 512;
pub const NGX_HTTP_UPSTREAM_CREATE: u32 = 1;
pub const NGX_HTTP_UPSTREAM_WEIGHT: u32 = 2;
pub const NGX_HTTP_UPSTREAM_MAX_FAILS: u32 = 4;
pub const NGX_HTTP_UPSTREAM_FAIL_TIMEOUT: u32 = 8;
pub const NGX_HTTP_UPSTREAM_DOWN: u32 = 16;
pub const NGX_HTTP_UPSTREAM_BACKUP: u32 = 32;
pub const NGX_HTTP_UPSTREAM_MAX_CONNS: u32 = 256;
pub const NGX_HTTP_GZIP_PROXIED_OFF: u32 = 2;
pub const NGX_HTTP_GZIP_PROXIED_EXPIRED: u32 = 4;
pub const NGX_HTTP_GZIP_PROXIED_NO_CACHE: u32 = 8;
pub const NGX_HTTP_GZIP_PROXIED_NO_STORE: u32 = 16;
pub const NGX_HTTP_GZIP_PROXIED_PRIVATE: u32 = 32;
pub const NGX_HTTP_GZIP_PROXIED_NO_LM: u32 = 64;
pub const NGX_HTTP_GZIP_PROXIED_NO_ETAG: u32 = 128;
pub const NGX_HTTP_GZIP_PROXIED_AUTH: u32 = 256;
pub const NGX_HTTP_GZIP_PROXIED_ANY: u32 = 512;
pub const NGX_HTTP_AIO_OFF: u32 = 0;
pub const NGX_HTTP_AIO_ON: u32 = 1;
pub const NGX_HTTP_AIO_THREADS: u32 = 2;
pub const NGX_HTTP_SATISFY_ALL: u32 = 0;
pub const NGX_HTTP_SATISFY_ANY: u32 = 1;
pub const NGX_HTTP_LINGERING_OFF: u32 = 0;
pub const NGX_HTTP_LINGERING_ON: u32 = 1;
pub const NGX_HTTP_LINGERING_ALWAYS: u32 = 2;
pub const NGX_HTTP_IMS_OFF: u32 = 0;
pub const NGX_HTTP_IMS_EXACT: u32 = 1;
pub const NGX_HTTP_IMS_BEFORE: u32 = 2;
pub const NGX_HTTP_KEEPALIVE_DISABLE_NONE: u32 = 2;
pub const NGX_HTTP_KEEPALIVE_DISABLE_MSIE6: u32 = 4;
pub const NGX_HTTP_KEEPALIVE_DISABLE_SAFARI: u32 = 8;
pub const NGX_HTTP_SERVER_TOKENS_OFF: u32 = 0;
pub const NGX_HTTP_SERVER_TOKENS_ON: u32 = 1;
pub const NGX_HTTP_SERVER_TOKENS_BUILD: u32 = 2;
pub const NGX_HTTP_CACHE_MISS: u32 = 1;
pub const NGX_HTTP_CACHE_BYPASS: u32 = 2;
pub const NGX_HTTP_CACHE_EXPIRED: u32 = 3;
pub const NGX_HTTP_CACHE_STALE: u32 = 4;
pub const NGX_HTTP_CACHE_UPDATING: u32 = 5;
pub const NGX_HTTP_CACHE_REVALIDATED: u32 = 6;
pub const NGX_HTTP_CACHE_HIT: u32 = 7;
pub const NGX_HTTP_CACHE_SCARCE: u32 = 8;
pub const NGX_HTTP_CACHE_KEY_LEN: u32 = 16;
pub const NGX_HTTP_CACHE_ETAG_LEN: u32 = 128;
pub const NGX_HTTP_CACHE_VARY_LEN: u32 = 128;
pub const NGX_HTTP_CACHE_VERSION: u32 = 5;
pub const NGX_HTTP_SSI_MAX_PARAMS: u32 = 16;
pub const NGX_HTTP_SSI_COMMAND_LEN: u32 = 32;
pub const NGX_HTTP_SSI_PARAM_LEN: u32 = 32;
pub const NGX_HTTP_SSI_PARAMS_N: u32 = 4;
pub const NGX_HTTP_SSI_COND_IF: u32 = 1;
pub const NGX_HTTP_SSI_COND_ELSE: u32 = 2;
pub const NGX_HTTP_SSI_NO_ENCODING: u32 = 0;
pub const NGX_HTTP_SSI_URL_ENCODING: u32 = 1;
pub const NGX_HTTP_SSI_ENTITY_ENCODING: u32 = 2;
pub const NGX_HTTP_LAST: u32 = 1;
pub const NGX_HTTP_FLUSH: u32 = 2;
pub type ngx_int_t = isize;
pub type ngx_uint_t = usize;
pub type ngx_flag_t = isize;
pub type ngx_module_t = ngx_module_s;
pub type ngx_conf_t = ngx_conf_s;
pub type ngx_cycle_t = ngx_cycle_s;
pub type ngx_pool_t = ngx_pool_s;
pub type ngx_chain_t = ngx_chain_s;
pub type ngx_log_t = ngx_log_s;
pub type ngx_open_file_t = ngx_open_file_s;
pub type ngx_command_t = ngx_command_s;
pub type ngx_file_t = ngx_file_s;
pub type ngx_event_t = ngx_event_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_event_aio_s {
    _unused: [u8; 0],
}
pub type ngx_event_aio_t = ngx_event_aio_s;
pub type ngx_connection_t = ngx_connection_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_thread_task_s {
    _unused: [u8; 0],
}
pub type ngx_thread_task_t = ngx_thread_task_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_ssl_s {
    _unused: [u8; 0],
}
pub type ngx_ssl_t = ngx_ssl_s;
pub type ngx_proxy_protocol_t = ngx_proxy_protocol_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_ssl_connection_s {
    _unused: [u8; 0],
}
pub type ngx_ssl_connection_t = ngx_ssl_connection_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_udp_connection_s {
    _unused: [u8; 0],
}
pub type ngx_udp_connection_t = ngx_udp_connection_s;
pub type ngx_event_handler_pt = ::std::option::Option<unsafe extern "C" fn(ev: *mut ngx_event_t)>;
pub type ngx_connection_handler_pt =
    ::std::option::Option<unsafe extern "C" fn(c: *mut ngx_connection_t)>;
pub type ngx_err_t = libc::c_int;
extern "C" {
    pub fn ngx_strerror(err: ngx_err_t, errstr: *mut u_char, size: size_t) -> *mut u_char;
}
extern "C" {
    pub fn ngx_strerror_init() -> ngx_int_t;
}
pub type ngx_atomic_int_t = i64;
pub type ngx_atomic_uint_t = u64;
pub type ngx_atomic_t = ngx_atomic_uint_t;
extern "C" {
    pub fn ngx_spinlock(lock: *mut ngx_atomic_t, value: ngx_atomic_int_t, spin: ngx_uint_t);
}
pub type ngx_rbtree_key_t = ngx_uint_t;
pub type ngx_rbtree_key_int_t = ngx_int_t;
pub type ngx_rbtree_node_t = ngx_rbtree_node_s;
#[repr(C)]
pub struct ngx_rbtree_node_s {
    pub key: ngx_rbtree_key_t,
    pub left: *mut ngx_rbtree_node_t,
    pub right: *mut ngx_rbtree_node_t,
    pub parent: *mut ngx_rbtree_node_t,
    pub color: u_char,
    pub data: u_char,
}
impl ::std::fmt::Debug for ngx_rbtree_node_s {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_rbtree_node_s {{ left: {:?}, right: {:?}, parent: {:?} }}",
            self.left, self.right, self.parent
        )
    }
}
pub type ngx_rbtree_t = ngx_rbtree_s;
pub type ngx_rbtree_insert_pt = ::std::option::Option<
    unsafe extern "C" fn(
        root: *mut ngx_rbtree_node_t,
        node: *mut ngx_rbtree_node_t,
        sentinel: *mut ngx_rbtree_node_t,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_rbtree_s {
    pub root: *mut ngx_rbtree_node_t,
    pub sentinel: *mut ngx_rbtree_node_t,
    pub insert: ngx_rbtree_insert_pt,
}
extern "C" {
    pub fn ngx_rbtree_insert(tree: *mut ngx_rbtree_t, node: *mut ngx_rbtree_node_t);
}
extern "C" {
    pub fn ngx_rbtree_delete(tree: *mut ngx_rbtree_t, node: *mut ngx_rbtree_node_t);
}
extern "C" {
    pub fn ngx_rbtree_insert_value(
        root: *mut ngx_rbtree_node_t,
        node: *mut ngx_rbtree_node_t,
        sentinel: *mut ngx_rbtree_node_t,
    );
}
extern "C" {
    pub fn ngx_rbtree_insert_timer_value(
        root: *mut ngx_rbtree_node_t,
        node: *mut ngx_rbtree_node_t,
        sentinel: *mut ngx_rbtree_node_t,
    );
}
extern "C" {
    pub fn ngx_rbtree_next(
        tree: *mut ngx_rbtree_t,
        node: *mut ngx_rbtree_node_t,
    ) -> *mut ngx_rbtree_node_t;
}
pub type ngx_msec_t = ngx_rbtree_key_t;
pub type ngx_msec_int_t = ngx_rbtree_key_int_t;
pub type ngx_tm_t = tm;
extern "C" {
    pub fn ngx_timezone_update();
}
extern "C" {
    pub fn ngx_localtime(s: time_t, tm: *mut ngx_tm_t);
}
extern "C" {
    pub fn ngx_libc_localtime(s: time_t, tm: *mut tm);
}
extern "C" {
    pub fn ngx_libc_gmtime(s: time_t, tm: *mut tm);
}
pub type ngx_socket_t = libc::c_int;
extern "C" {
    pub fn ngx_nonblocking(s: ngx_socket_t) -> libc::c_int;
}
extern "C" {
    pub fn ngx_blocking(s: ngx_socket_t) -> libc::c_int;
}
extern "C" {
    pub fn ngx_tcp_nopush(s: ngx_socket_t) -> libc::c_int;
}
extern "C" {
    pub fn ngx_tcp_push(s: ngx_socket_t) -> libc::c_int;
}
#[repr(C)]
pub struct ngx_str_t {
    pub len: size_t,
    pub data: *mut u_char,
}
impl ::std::fmt::Debug for ngx_str_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "ngx_str_t {{ data: {:?} }}", self.data)
    }
}
#[repr(C)]
pub struct ngx_keyval_t {
    pub key: ngx_str_t,
    pub value: ngx_str_t,
}
impl ::std::fmt::Debug for ngx_keyval_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_keyval_t {{ key: {:?}, value: {:?} }}",
            self.key, self.value
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_variable_value_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub data: *mut u_char,
}
impl ngx_variable_value_t {
    #[inline]
    pub fn len(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_len(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn valid(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_valid(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_cacheable(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_cacheable(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn not_found(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_not_found(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn escape(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_escape(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        len: libc::c_uint,
        valid: libc::c_uint,
        no_cacheable: libc::c_uint,
        not_found: libc::c_uint,
        escape: libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 28u8, {
            let len: u32 = unsafe { ::std::mem::transmute(len) };
            len as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let valid: u32 = unsafe { ::std::mem::transmute(valid) };
            valid as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let no_cacheable: u32 = unsafe { ::std::mem::transmute(no_cacheable) };
            no_cacheable as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let not_found: u32 = unsafe { ::std::mem::transmute(not_found) };
            not_found as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let escape: u32 = unsafe { ::std::mem::transmute(escape) };
            escape as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn ngx_strlow(dst: *mut u_char, src: *mut u_char, n: size_t);
}
extern "C" {
    pub fn ngx_strnlen(p: *mut u_char, n: size_t) -> size_t;
}
extern "C" {
    pub fn ngx_explicit_memzero(buf: *mut libc::c_void, n: size_t);
}
extern "C" {
    pub fn ngx_cpystrn(dst: *mut u_char, src: *mut u_char, n: size_t) -> *mut u_char;
}
extern "C" {
    pub fn ngx_pstrdup(pool: *mut ngx_pool_t, src: *mut ngx_str_t) -> *mut u_char;
}
extern "C" {
    pub fn ngx_sprintf(buf: *mut u_char, fmt: *const libc::c_char, ...) -> *mut u_char;
}
extern "C" {
    pub fn ngx_snprintf(
        buf: *mut u_char,
        max: size_t,
        fmt: *const libc::c_char,
        ...
    ) -> *mut u_char;
}
extern "C" {
    pub fn ngx_slprintf(
        buf: *mut u_char,
        last: *mut u_char,
        fmt: *const libc::c_char,
        ...
    ) -> *mut u_char;
}
extern "C" {
    pub fn ngx_vslprintf(
        buf: *mut u_char,
        last: *mut u_char,
        fmt: *const libc::c_char,
        args: *mut __va_list_tag,
    ) -> *mut u_char;
}
extern "C" {
    pub fn ngx_strcasecmp(s1: *mut u_char, s2: *mut u_char) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_strncasecmp(s1: *mut u_char, s2: *mut u_char, n: size_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_strnstr(s1: *mut u_char, s2: *mut libc::c_char, n: size_t) -> *mut u_char;
}
extern "C" {
    pub fn ngx_strstrn(s1: *mut u_char, s2: *mut libc::c_char, n: size_t) -> *mut u_char;
}
extern "C" {
    pub fn ngx_strcasestrn(s1: *mut u_char, s2: *mut libc::c_char, n: size_t) -> *mut u_char;
}
extern "C" {
    pub fn ngx_strlcasestrn(
        s1: *mut u_char,
        last: *mut u_char,
        s2: *mut u_char,
        n: size_t,
    ) -> *mut u_char;
}
extern "C" {
    pub fn ngx_rstrncmp(s1: *mut u_char, s2: *mut u_char, n: size_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_rstrncasecmp(s1: *mut u_char, s2: *mut u_char, n: size_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_memn2cmp(s1: *mut u_char, s2: *mut u_char, n1: size_t, n2: size_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_dns_strcmp(s1: *mut u_char, s2: *mut u_char) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_filename_cmp(s1: *mut u_char, s2: *mut u_char, n: size_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_atoi(line: *mut u_char, n: size_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_atofp(line: *mut u_char, n: size_t, point: size_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_atosz(line: *mut u_char, n: size_t) -> ssize_t;
}
extern "C" {
    pub fn ngx_atoof(line: *mut u_char, n: size_t) -> off_t;
}
extern "C" {
    pub fn ngx_atotm(line: *mut u_char, n: size_t) -> time_t;
}
extern "C" {
    pub fn ngx_hextoi(line: *mut u_char, n: size_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_hex_dump(dst: *mut u_char, src: *mut u_char, len: size_t) -> *mut u_char;
}
extern "C" {
    pub fn ngx_encode_base64(dst: *mut ngx_str_t, src: *mut ngx_str_t);
}
extern "C" {
    pub fn ngx_encode_base64url(dst: *mut ngx_str_t, src: *mut ngx_str_t);
}
extern "C" {
    pub fn ngx_decode_base64(dst: *mut ngx_str_t, src: *mut ngx_str_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_decode_base64url(dst: *mut ngx_str_t, src: *mut ngx_str_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_utf8_decode(p: *mut *mut u_char, n: size_t) -> u32;
}
extern "C" {
    pub fn ngx_utf8_length(p: *mut u_char, n: size_t) -> size_t;
}
extern "C" {
    pub fn ngx_utf8_cpystrn(
        dst: *mut u_char,
        src: *mut u_char,
        n: size_t,
        len: size_t,
    ) -> *mut u_char;
}
extern "C" {
    pub fn ngx_escape_uri(
        dst: *mut u_char,
        src: *mut u_char,
        size: size_t,
        type_: ngx_uint_t,
    ) -> usize;
}
extern "C" {
    pub fn ngx_unescape_uri(
        dst: *mut *mut u_char,
        src: *mut *mut u_char,
        size: size_t,
        type_: ngx_uint_t,
    );
}
extern "C" {
    pub fn ngx_escape_html(dst: *mut u_char, src: *mut u_char, size: size_t) -> usize;
}
extern "C" {
    pub fn ngx_escape_json(dst: *mut u_char, src: *mut u_char, size: size_t) -> usize;
}
#[repr(C)]
pub struct ngx_str_node_t {
    pub node: ngx_rbtree_node_t,
    pub str: ngx_str_t,
}
impl ::std::fmt::Debug for ngx_str_node_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_str_node_t {{ node: {:?}, str: {:?} }}",
            self.node, self.str
        )
    }
}
extern "C" {
    pub fn ngx_str_rbtree_insert_value(
        temp: *mut ngx_rbtree_node_t,
        node: *mut ngx_rbtree_node_t,
        sentinel: *mut ngx_rbtree_node_t,
    );
}
extern "C" {
    pub fn ngx_str_rbtree_lookup(
        rbtree: *mut ngx_rbtree_t,
        name: *mut ngx_str_t,
        hash: u32,
    ) -> *mut ngx_str_node_t;
}
extern "C" {
    pub fn ngx_sort(
        base: *mut libc::c_void,
        n: size_t,
        size: size_t,
        cmp: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const libc::c_void, arg2: *const libc::c_void) -> ngx_int_t,
        >,
    );
}
pub type ngx_fd_t = libc::c_int;
pub type ngx_file_info_t = stat;
pub type ngx_file_uniq_t = ino_t;
#[repr(C)]
pub struct ngx_file_mapping_t {
    pub name: *mut u_char,
    pub size: size_t,
    pub addr: *mut libc::c_void,
    pub fd: ngx_fd_t,
    pub log: *mut ngx_log_t,
}
impl ::std::fmt::Debug for ngx_file_mapping_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_file_mapping_t {{ name: {:?}, addr: {:?}, fd: {:?}, log: {:?} }}",
            self.name, self.addr, self.fd, self.log
        )
    }
}
#[repr(C)]
pub struct ngx_dir_t {
    pub dir: *mut DIR,
    pub de: *mut dirent,
    pub info: stat,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub __bindgen_padding_0: [u16; 3usize],
}
impl ::std::fmt::Debug for ngx_dir_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_dir_t {{ dir: {:?}, de: {:?}, type : {:?}, valid_info : {:?} }}",
            self.dir,
            self.de,
            self.type_(),
            self.valid_info()
        )
    }
}
impl ngx_dir_t {
    #[inline]
    pub fn type_(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn valid_info(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_valid_info(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        type_: libc::c_uint,
        valid_info: libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let valid_info: u32 = unsafe { ::std::mem::transmute(valid_info) };
            valid_info as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct ngx_glob_t {
    pub n: size_t,
    pub pglob: glob_t,
    pub pattern: *mut u_char,
    pub log: *mut ngx_log_t,
    pub test: ngx_uint_t,
}
impl ::std::fmt::Debug for ngx_glob_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_glob_t {{ pattern: {:?}, log: {:?} }}",
            self.pattern, self.log
        )
    }
}
extern "C" {
    pub fn ngx_open_tempfile(
        name: *mut u_char,
        persistent: ngx_uint_t,
        access: ngx_uint_t,
    ) -> ngx_fd_t;
}
extern "C" {
    pub fn ngx_read_file(
        file: *mut ngx_file_t,
        buf: *mut u_char,
        size: size_t,
        offset: off_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn ngx_write_file(
        file: *mut ngx_file_t,
        buf: *mut u_char,
        size: size_t,
        offset: off_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn ngx_write_chain_to_file(
        file: *mut ngx_file_t,
        ce: *mut ngx_chain_t,
        offset: off_t,
        pool: *mut ngx_pool_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn ngx_set_file_time(name: *mut u_char, fd: ngx_fd_t, s: time_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_create_file_mapping(fm: *mut ngx_file_mapping_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_close_file_mapping(fm: *mut ngx_file_mapping_t);
}
extern "C" {
    pub fn ngx_open_dir(name: *mut ngx_str_t, dir: *mut ngx_dir_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_read_dir(dir: *mut ngx_dir_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_open_glob(gl: *mut ngx_glob_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_read_glob(gl: *mut ngx_glob_t, name: *mut ngx_str_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_close_glob(gl: *mut ngx_glob_t);
}
extern "C" {
    pub fn ngx_trylock_fd(fd: ngx_fd_t) -> ngx_err_t;
}
extern "C" {
    pub fn ngx_lock_fd(fd: ngx_fd_t) -> ngx_err_t;
}
extern "C" {
    pub fn ngx_unlock_fd(fd: ngx_fd_t) -> ngx_err_t;
}
extern "C" {
    pub fn ngx_fs_bsize(name: *mut u_char) -> size_t;
}
#[repr(C)]
pub struct ngx_shm_t {
    pub addr: *mut u_char,
    pub size: size_t,
    pub name: ngx_str_t,
    pub log: *mut ngx_log_t,
    pub exists: ngx_uint_t,
}
impl ::std::fmt::Debug for ngx_shm_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_shm_t {{ addr: {:?}, name: {:?}, log: {:?} }}",
            self.addr, self.name, self.log
        )
    }
}
extern "C" {
    pub fn ngx_shm_alloc(shm: *mut ngx_shm_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_shm_free(shm: *mut ngx_shm_t);
}
pub type ngx_cpuset_t = u64;
extern "C" {
    pub fn ngx_init_setproctitle(log: *mut ngx_log_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_setproctitle(title: *mut libc::c_char);
}
pub type ngx_pid_t = pid_t;
pub type ngx_spawn_proc_pt =
    ::std::option::Option<unsafe extern "C" fn(cycle: *mut ngx_cycle_t, data: *mut libc::c_void)>;
#[repr(C)]
pub struct ngx_process_t {
    pub pid: ngx_pid_t,
    pub status: libc::c_int,
    pub channel: [ngx_socket_t; 2usize],
    pub proc_: ngx_spawn_proc_pt,
    pub data: *mut libc::c_void,
    pub name: *mut libc::c_char,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl ::std::fmt::Debug for ngx_process_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "ngx_process_t {{ status: {:?}, channel: {:?}, proc: {:?}, data: {:?}, name: {:?}, respawn : {:?}, just_spawn : {:?}, detached : {:?}, exiting : {:?}, exited : {:?} }}" , self . status , self . channel , self . proc_ , self . data , self . name , self . respawn ( ) , self . just_spawn ( ) , self . detached ( ) , self . exiting ( ) , self . exited ( ) )
    }
}
impl ngx_process_t {
    #[inline]
    pub fn respawn(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_respawn(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn just_spawn(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_just_spawn(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn detached(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_detached(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn exiting(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_exiting(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn exited(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_exited(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        respawn: libc::c_uint,
        just_spawn: libc::c_uint,
        detached: libc::c_uint,
        exiting: libc::c_uint,
        exited: libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let respawn: u32 = unsafe { ::std::mem::transmute(respawn) };
            respawn as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let just_spawn: u32 = unsafe { ::std::mem::transmute(just_spawn) };
            just_spawn as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let detached: u32 = unsafe { ::std::mem::transmute(detached) };
            detached as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let exiting: u32 = unsafe { ::std::mem::transmute(exiting) };
            exiting as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let exited: u32 = unsafe { ::std::mem::transmute(exited) };
            exited as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_exec_ctx_t {
    pub path: *mut libc::c_char,
    pub name: *mut libc::c_char,
    pub argv: *const *mut libc::c_char,
    pub envp: *const *mut libc::c_char,
}
extern "C" {
    pub fn ngx_spawn_process(
        cycle: *mut ngx_cycle_t,
        proc_: ngx_spawn_proc_pt,
        data: *mut libc::c_void,
        name: *mut libc::c_char,
        respawn: ngx_int_t,
    ) -> ngx_pid_t;
}
extern "C" {
    pub fn ngx_execute(cycle: *mut ngx_cycle_t, ctx: *mut ngx_exec_ctx_t) -> ngx_pid_t;
}
extern "C" {
    pub fn ngx_init_signals(log: *mut ngx_log_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_debug_point();
}
extern "C" {
    pub static mut ngx_argc: libc::c_int;
}
extern "C" {
    pub static mut ngx_argv: *mut *mut libc::c_char;
}
extern "C" {
    pub static mut ngx_os_argv: *mut *mut libc::c_char;
}
extern "C" {
    pub static mut ngx_pid: ngx_pid_t;
}
extern "C" {
    pub static mut ngx_parent: ngx_pid_t;
}
extern "C" {
    pub static mut ngx_channel: ngx_socket_t;
}
extern "C" {
    pub static mut ngx_process_slot: ngx_int_t;
}
extern "C" {
    pub static mut ngx_last_process: ngx_int_t;
}
extern "C" {
    pub static mut ngx_processes: [ngx_process_t; 1024usize];
}
pub type ngx_uid_t = uid_t;
pub type ngx_gid_t = gid_t;
extern "C" {
    pub fn ngx_libc_crypt(
        pool: *mut ngx_pool_t,
        key: *mut u_char,
        salt: *mut u_char,
        encrypted: *mut *mut u_char,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_dlerror() -> *mut libc::c_char;
}
extern "C" {
    pub fn ngx_parse_size(line: *mut ngx_str_t) -> ssize_t;
}
extern "C" {
    pub fn ngx_parse_offset(line: *mut ngx_str_t) -> off_t;
}
extern "C" {
    pub fn ngx_parse_time(line: *mut ngx_str_t, is_sec: ngx_uint_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_parse_http_time(value: *mut u_char, len: size_t) -> time_t;
}
pub type ngx_log_handler_pt = ::std::option::Option<
    unsafe extern "C" fn(log: *mut ngx_log_t, buf: *mut u_char, len: size_t) -> *mut u_char,
>;
pub type ngx_log_writer_pt = ::std::option::Option<
    unsafe extern "C" fn(log: *mut ngx_log_t, level: ngx_uint_t, buf: *mut u_char, len: size_t),
>;
#[repr(C)]
pub struct ngx_log_s {
    pub log_level: ngx_uint_t,
    pub file: *mut ngx_open_file_t,
    pub connection: ngx_atomic_uint_t,
    pub disk_full_time: time_t,
    pub handler: ngx_log_handler_pt,
    pub data: *mut libc::c_void,
    pub writer: ngx_log_writer_pt,
    pub wdata: *mut libc::c_void,
    pub action: *mut libc::c_char,
    pub next: *mut ngx_log_t,
}
impl ::std::fmt::Debug for ngx_log_s {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "ngx_log_s {{ file: {:?}, handler: {:?}, data: {:?}, writer: {:?}, wdata: {:?}, action: {:?}, next: {:?} }}" , self . file , self . handler , self . data , self . writer , self . wdata , self . action , self . next )
    }
}
extern "C" {
    pub fn ngx_log_error_core(
        level: ngx_uint_t,
        log: *mut ngx_log_t,
        err: ngx_err_t,
        fmt: *const libc::c_char,
        ...
    );
}
extern "C" {
    pub fn ngx_log_init(prefix: *mut u_char) -> *mut ngx_log_t;
}
extern "C" {
    pub fn ngx_log_abort(err: ngx_err_t, fmt: *const libc::c_char, ...);
}
extern "C" {
    pub fn ngx_log_stderr(err: ngx_err_t, fmt: *const libc::c_char, ...);
}
extern "C" {
    pub fn ngx_log_errno(buf: *mut u_char, last: *mut u_char, err: ngx_err_t) -> *mut u_char;
}
extern "C" {
    pub fn ngx_log_open_default(cycle: *mut ngx_cycle_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_log_redirect_stderr(cycle: *mut ngx_cycle_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_log_get_file_log(head: *mut ngx_log_t) -> *mut ngx_log_t;
}
extern "C" {
    pub fn ngx_log_set_log(cf: *mut ngx_conf_t, head: *mut *mut ngx_log_t) -> *mut libc::c_char;
}
extern "C" {
    pub static mut ngx_errlog_module: ngx_module_t;
}
extern "C" {
    pub static mut ngx_use_stderr: ngx_uint_t;
}
extern "C" {
    pub fn ngx_alloc(size: size_t, log: *mut ngx_log_t) -> *mut libc::c_void;
}
extern "C" {
    pub fn ngx_calloc(size: size_t, log: *mut ngx_log_t) -> *mut libc::c_void;
}
extern "C" {
    pub fn ngx_memalign(alignment: size_t, size: size_t, log: *mut ngx_log_t) -> *mut libc::c_void;
}
extern "C" {
    pub static mut ngx_pagesize: ngx_uint_t;
}
extern "C" {
    pub static mut ngx_pagesize_shift: ngx_uint_t;
}
extern "C" {
    pub static mut ngx_cacheline_size: ngx_uint_t;
}
pub type ngx_pool_cleanup_pt = ::std::option::Option<unsafe extern "C" fn(data: *mut libc::c_void)>;
pub type ngx_pool_cleanup_t = ngx_pool_cleanup_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_pool_cleanup_s {
    pub handler: ngx_pool_cleanup_pt,
    pub data: *mut libc::c_void,
    pub next: *mut ngx_pool_cleanup_t,
}
pub type ngx_pool_large_t = ngx_pool_large_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_pool_large_s {
    pub next: *mut ngx_pool_large_t,
    pub alloc: *mut libc::c_void,
}
#[repr(C)]
pub struct ngx_pool_data_t {
    pub last: *mut u_char,
    pub end: *mut u_char,
    pub next: *mut ngx_pool_t,
    pub failed: ngx_uint_t,
}
impl ::std::fmt::Debug for ngx_pool_data_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_pool_data_t {{ last: {:?}, end: {:?}, next: {:?} }}",
            self.last, self.end, self.next
        )
    }
}
#[repr(C)]
pub struct ngx_pool_s {
    pub d: ngx_pool_data_t,
    pub max: size_t,
    pub current: *mut ngx_pool_t,
    pub chain: *mut ngx_chain_t,
    pub large: *mut ngx_pool_large_t,
    pub cleanup: *mut ngx_pool_cleanup_t,
    pub log: *mut ngx_log_t,
}
impl ::std::fmt::Debug for ngx_pool_s {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "ngx_pool_s {{ d: {:?}, current: {:?}, chain: {:?}, large: {:?}, cleanup: {:?}, log: {:?} }}" , self . d , self . current , self . chain , self . large , self . cleanup , self . log )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_pool_cleanup_file_t {
    pub fd: ngx_fd_t,
    pub name: *mut u_char,
    pub log: *mut ngx_log_t,
}
extern "C" {
    pub fn ngx_create_pool(size: size_t, log: *mut ngx_log_t) -> *mut ngx_pool_t;
}
extern "C" {
    pub fn ngx_destroy_pool(pool: *mut ngx_pool_t);
}
extern "C" {
    pub fn ngx_reset_pool(pool: *mut ngx_pool_t);
}
extern "C" {
    pub fn ngx_palloc(pool: *mut ngx_pool_t, size: size_t) -> *mut libc::c_void;
}
extern "C" {
    pub fn ngx_pnalloc(pool: *mut ngx_pool_t, size: size_t) -> *mut libc::c_void;
}
extern "C" {
    pub fn ngx_pcalloc(pool: *mut ngx_pool_t, size: size_t) -> *mut libc::c_void;
}
extern "C" {
    pub fn ngx_pmemalign(
        pool: *mut ngx_pool_t,
        size: size_t,
        alignment: size_t,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn ngx_pfree(pool: *mut ngx_pool_t, p: *mut libc::c_void) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_pool_cleanup_add(p: *mut ngx_pool_t, size: size_t) -> *mut ngx_pool_cleanup_t;
}
extern "C" {
    pub fn ngx_pool_run_cleanup_file(p: *mut ngx_pool_t, fd: ngx_fd_t);
}
extern "C" {
    pub fn ngx_pool_cleanup_file(data: *mut libc::c_void);
}
extern "C" {
    pub fn ngx_pool_delete_file(data: *mut libc::c_void);
}
pub type ngx_buf_tag_t = *mut libc::c_void;
pub type ngx_buf_t = ngx_buf_s;
#[repr(C)]
pub struct ngx_buf_s {
    pub pos: *mut u_char,
    pub last: *mut u_char,
    pub file_pos: off_t,
    pub file_last: off_t,
    pub start: *mut u_char,
    pub end: *mut u_char,
    pub tag: ngx_buf_tag_t,
    pub file: *mut ngx_file_t,
    pub shadow: *mut ngx_buf_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub num: libc::c_int,
}
impl ::std::fmt::Debug for ngx_buf_s {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "ngx_buf_s {{ pos: {:?}, last: {:?}, start: {:?}, end: {:?}, tag: {:?}, file: {:?}, shadow: {:?}, temporary : {:?}, memory : {:?}, mmap : {:?}, recycled : {:?}, in_file : {:?}, flush : {:?}, sync : {:?}, last_buf : {:?}, last_in_chain : {:?}, last_shadow : {:?}, temp_file : {:?}, num: {:?} }}" , self . pos , self . last , self . start , self . end , self . tag , self . file , self . shadow , self . temporary ( ) , self . memory ( ) , self . mmap ( ) , self . recycled ( ) , self . in_file ( ) , self . flush ( ) , self . sync ( ) , self . last_buf ( ) , self . last_in_chain ( ) , self . last_shadow ( ) , self . temp_file ( ) , self . num )
    }
}
impl ngx_buf_s {
    #[inline]
    pub fn temporary(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_temporary(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn memory(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_memory(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mmap(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mmap(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn recycled(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_recycled(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_file(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_file(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flush(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flush(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sync(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sync(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn last_buf(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_last_buf(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn last_in_chain(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_last_in_chain(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn last_shadow(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_last_shadow(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn temp_file(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_temp_file(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        temporary: libc::c_uint,
        memory: libc::c_uint,
        mmap: libc::c_uint,
        recycled: libc::c_uint,
        in_file: libc::c_uint,
        flush: libc::c_uint,
        sync: libc::c_uint,
        last_buf: libc::c_uint,
        last_in_chain: libc::c_uint,
        last_shadow: libc::c_uint,
        temp_file: libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let temporary: u32 = unsafe { ::std::mem::transmute(temporary) };
            temporary as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let memory: u32 = unsafe { ::std::mem::transmute(memory) };
            memory as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mmap: u32 = unsafe { ::std::mem::transmute(mmap) };
            mmap as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let recycled: u32 = unsafe { ::std::mem::transmute(recycled) };
            recycled as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let in_file: u32 = unsafe { ::std::mem::transmute(in_file) };
            in_file as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let flush: u32 = unsafe { ::std::mem::transmute(flush) };
            flush as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let sync: u32 = unsafe { ::std::mem::transmute(sync) };
            sync as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let last_buf: u32 = unsafe { ::std::mem::transmute(last_buf) };
            last_buf as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let last_in_chain: u32 = unsafe { ::std::mem::transmute(last_in_chain) };
            last_in_chain as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let last_shadow: u32 = unsafe { ::std::mem::transmute(last_shadow) };
            last_shadow as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let temp_file: u32 = unsafe { ::std::mem::transmute(temp_file) };
            temp_file as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_chain_s {
    pub buf: *mut ngx_buf_t,
    pub next: *mut ngx_chain_t,
}
#[repr(C)]
pub struct ngx_bufs_t {
    pub num: ngx_int_t,
    pub size: size_t,
}
impl ::std::fmt::Debug for ngx_bufs_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "ngx_bufs_t {{  }}")
    }
}
pub type ngx_output_chain_ctx_t = ngx_output_chain_ctx_s;
pub type ngx_output_chain_filter_pt = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut libc::c_void, in_: *mut ngx_chain_t) -> ngx_int_t,
>;
pub type ngx_output_chain_aio_pt = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ngx_output_chain_ctx_t, file: *mut ngx_file_t),
>;
#[repr(C)]
pub struct ngx_output_chain_ctx_s {
    pub buf: *mut ngx_buf_t,
    pub in_: *mut ngx_chain_t,
    pub free: *mut ngx_chain_t,
    pub busy: *mut ngx_chain_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub alignment: off_t,
    pub pool: *mut ngx_pool_t,
    pub allocated: ngx_int_t,
    pub bufs: ngx_bufs_t,
    pub tag: ngx_buf_tag_t,
    pub output_filter: ngx_output_chain_filter_pt,
    pub filter_ctx: *mut libc::c_void,
}
impl ::std::fmt::Debug for ngx_output_chain_ctx_s {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "ngx_output_chain_ctx_s {{ buf: {:?}, in: {:?}, free: {:?}, busy: {:?}, sendfile : {:?}, directio : {:?}, unaligned : {:?}, need_in_memory : {:?}, need_in_temp : {:?}, aio : {:?}, pool: {:?}, bufs: {:?}, tag: {:?}, output_filter: {:?}, filter_ctx: {:?} }}" , self . buf , self . in_ , self . free , self . busy , self . sendfile ( ) , self . directio ( ) , self . unaligned ( ) , self . need_in_memory ( ) , self . need_in_temp ( ) , self . aio ( ) , self . pool , self . bufs , self . tag , self . output_filter , self . filter_ctx )
    }
}
impl ngx_output_chain_ctx_s {
    #[inline]
    pub fn sendfile(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sendfile(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn directio(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_directio(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unaligned(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_unaligned(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn need_in_memory(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_need_in_memory(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn need_in_temp(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_need_in_temp(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn aio(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_aio(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sendfile: libc::c_uint,
        directio: libc::c_uint,
        unaligned: libc::c_uint,
        need_in_memory: libc::c_uint,
        need_in_temp: libc::c_uint,
        aio: libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sendfile: u32 = unsafe { ::std::mem::transmute(sendfile) };
            sendfile as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let directio: u32 = unsafe { ::std::mem::transmute(directio) };
            directio as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let unaligned: u32 = unsafe { ::std::mem::transmute(unaligned) };
            unaligned as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let need_in_memory: u32 = unsafe { ::std::mem::transmute(need_in_memory) };
            need_in_memory as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let need_in_temp: u32 = unsafe { ::std::mem::transmute(need_in_temp) };
            need_in_temp as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let aio: u32 = unsafe { ::std::mem::transmute(aio) };
            aio as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct ngx_chain_writer_ctx_t {
    pub out: *mut ngx_chain_t,
    pub last: *mut *mut ngx_chain_t,
    pub connection: *mut ngx_connection_t,
    pub pool: *mut ngx_pool_t,
    pub limit: off_t,
}
impl ::std::fmt::Debug for ngx_chain_writer_ctx_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_chain_writer_ctx_t {{ out: {:?}, last: {:?}, connection: {:?}, pool: {:?} }}",
            self.out, self.last, self.connection, self.pool
        )
    }
}
extern "C" {
    pub fn ngx_create_temp_buf(pool: *mut ngx_pool_t, size: size_t) -> *mut ngx_buf_t;
}
extern "C" {
    pub fn ngx_create_chain_of_bufs(
        pool: *mut ngx_pool_t,
        bufs: *mut ngx_bufs_t,
    ) -> *mut ngx_chain_t;
}
extern "C" {
    pub fn ngx_alloc_chain_link(pool: *mut ngx_pool_t) -> *mut ngx_chain_t;
}
extern "C" {
    pub fn ngx_output_chain(ctx: *mut ngx_output_chain_ctx_t, in_: *mut ngx_chain_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_chain_writer(ctx: *mut libc::c_void, in_: *mut ngx_chain_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_chain_add_copy(
        pool: *mut ngx_pool_t,
        chain: *mut *mut ngx_chain_t,
        in_: *mut ngx_chain_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_chain_get_free_buf(
        p: *mut ngx_pool_t,
        free: *mut *mut ngx_chain_t,
    ) -> *mut ngx_chain_t;
}
extern "C" {
    pub fn ngx_chain_update_chains(
        p: *mut ngx_pool_t,
        free: *mut *mut ngx_chain_t,
        busy: *mut *mut ngx_chain_t,
        out: *mut *mut ngx_chain_t,
        tag: ngx_buf_tag_t,
    );
}
extern "C" {
    pub fn ngx_chain_coalesce_file(in_: *mut *mut ngx_chain_t, limit: off_t) -> off_t;
}
extern "C" {
    pub fn ngx_chain_update_sent(in_: *mut ngx_chain_t, sent: off_t) -> *mut ngx_chain_t;
}
pub type ngx_queue_t = ngx_queue_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_queue_s {
    pub prev: *mut ngx_queue_t,
    pub next: *mut ngx_queue_t,
}
extern "C" {
    pub fn ngx_queue_middle(queue: *mut ngx_queue_t) -> *mut ngx_queue_t;
}
extern "C" {
    pub fn ngx_queue_sort(
        queue: *mut ngx_queue_t,
        cmp: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const ngx_queue_t, arg2: *const ngx_queue_t) -> ngx_int_t,
        >,
    );
}
#[repr(C)]
pub struct ngx_array_t {
    pub elts: *mut libc::c_void,
    pub nelts: ngx_uint_t,
    pub size: size_t,
    pub nalloc: ngx_uint_t,
    pub pool: *mut ngx_pool_t,
}
impl ::std::fmt::Debug for ngx_array_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_array_t {{ elts: {:?}, pool: {:?} }}",
            self.elts, self.pool
        )
    }
}
extern "C" {
    pub fn ngx_array_create(p: *mut ngx_pool_t, n: ngx_uint_t, size: size_t) -> *mut ngx_array_t;
}
extern "C" {
    pub fn ngx_array_destroy(a: *mut ngx_array_t);
}
extern "C" {
    pub fn ngx_array_push(a: *mut ngx_array_t) -> *mut libc::c_void;
}
extern "C" {
    pub fn ngx_array_push_n(a: *mut ngx_array_t, n: ngx_uint_t) -> *mut libc::c_void;
}
pub type ngx_list_part_t = ngx_list_part_s;
#[repr(C)]
pub struct ngx_list_part_s {
    pub elts: *mut libc::c_void,
    pub nelts: ngx_uint_t,
    pub next: *mut ngx_list_part_t,
}
impl ::std::fmt::Debug for ngx_list_part_s {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_list_part_s {{ elts: {:?}, next: {:?} }}",
            self.elts, self.next
        )
    }
}
#[repr(C)]
pub struct ngx_list_t {
    pub last: *mut ngx_list_part_t,
    pub part: ngx_list_part_t,
    pub size: size_t,
    pub nalloc: ngx_uint_t,
    pub pool: *mut ngx_pool_t,
}
impl ::std::fmt::Debug for ngx_list_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_list_t {{ last: {:?}, part: {:?}, pool: {:?} }}",
            self.last, self.part, self.pool
        )
    }
}
extern "C" {
    pub fn ngx_list_create(pool: *mut ngx_pool_t, n: ngx_uint_t, size: size_t) -> *mut ngx_list_t;
}
extern "C" {
    pub fn ngx_list_push(list: *mut ngx_list_t) -> *mut libc::c_void;
}
#[repr(C)]
pub struct ngx_hash_elt_t {
    pub value: *mut libc::c_void,
    pub len: u_short,
    pub name: [u_char; 1usize],
}
impl ::std::fmt::Debug for ngx_hash_elt_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_hash_elt_t {{ value: {:?}, name: {:?} }}",
            self.value, self.name
        )
    }
}
#[repr(C)]
pub struct ngx_hash_t {
    pub buckets: *mut *mut ngx_hash_elt_t,
    pub size: ngx_uint_t,
}
impl ::std::fmt::Debug for ngx_hash_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "ngx_hash_t {{ buckets: {:?} }}", self.buckets)
    }
}
#[repr(C)]
pub struct ngx_hash_wildcard_t {
    pub hash: ngx_hash_t,
    pub value: *mut libc::c_void,
}
impl ::std::fmt::Debug for ngx_hash_wildcard_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_hash_wildcard_t {{ hash: {:?}, value: {:?} }}",
            self.hash, self.value
        )
    }
}
#[repr(C)]
pub struct ngx_hash_key_t {
    pub key: ngx_str_t,
    pub key_hash: ngx_uint_t,
    pub value: *mut libc::c_void,
}
impl ::std::fmt::Debug for ngx_hash_key_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_hash_key_t {{ key: {:?}, value: {:?} }}",
            self.key, self.value
        )
    }
}
pub type ngx_hash_key_pt =
    ::std::option::Option<unsafe extern "C" fn(data: *mut u_char, len: size_t) -> ngx_uint_t>;
#[repr(C)]
pub struct ngx_hash_combined_t {
    pub hash: ngx_hash_t,
    pub wc_head: *mut ngx_hash_wildcard_t,
    pub wc_tail: *mut ngx_hash_wildcard_t,
}
impl ::std::fmt::Debug for ngx_hash_combined_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_hash_combined_t {{ hash: {:?}, wc_head: {:?}, wc_tail: {:?} }}",
            self.hash, self.wc_head, self.wc_tail
        )
    }
}
#[repr(C)]
pub struct ngx_hash_init_t {
    pub hash: *mut ngx_hash_t,
    pub key: ngx_hash_key_pt,
    pub max_size: ngx_uint_t,
    pub bucket_size: ngx_uint_t,
    pub name: *mut libc::c_char,
    pub pool: *mut ngx_pool_t,
    pub temp_pool: *mut ngx_pool_t,
}
impl ::std::fmt::Debug for ngx_hash_init_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_hash_init_t {{ hash: {:?}, key: {:?}, name: {:?}, pool: {:?}, temp_pool: {:?} }}",
            self.hash, self.key, self.name, self.pool, self.temp_pool
        )
    }
}
#[repr(C)]
pub struct ngx_hash_keys_arrays_t {
    pub hsize: ngx_uint_t,
    pub pool: *mut ngx_pool_t,
    pub temp_pool: *mut ngx_pool_t,
    pub keys: ngx_array_t,
    pub keys_hash: *mut ngx_array_t,
    pub dns_wc_head: ngx_array_t,
    pub dns_wc_head_hash: *mut ngx_array_t,
    pub dns_wc_tail: ngx_array_t,
    pub dns_wc_tail_hash: *mut ngx_array_t,
}
impl ::std::fmt::Debug for ngx_hash_keys_arrays_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "ngx_hash_keys_arrays_t {{ pool: {:?}, temp_pool: {:?}, keys: {:?}, keys_hash: {:?}, dns_wc_head: {:?}, dns_wc_head_hash: {:?}, dns_wc_tail: {:?}, dns_wc_tail_hash: {:?} }}" , self . pool , self . temp_pool , self . keys , self . keys_hash , self . dns_wc_head , self . dns_wc_head_hash , self . dns_wc_tail , self . dns_wc_tail_hash )
    }
}
#[repr(C)]
pub struct ngx_table_elt_t {
    pub hash: ngx_uint_t,
    pub key: ngx_str_t,
    pub value: ngx_str_t,
    pub lowcase_key: *mut u_char,
}
impl ::std::fmt::Debug for ngx_table_elt_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_table_elt_t {{ key: {:?}, value: {:?}, lowcase_key: {:?} }}",
            self.key, self.value, self.lowcase_key
        )
    }
}
extern "C" {
    pub fn ngx_hash_find(
        hash: *mut ngx_hash_t,
        key: ngx_uint_t,
        name: *mut u_char,
        len: size_t,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn ngx_hash_find_wc_head(
        hwc: *mut ngx_hash_wildcard_t,
        name: *mut u_char,
        len: size_t,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn ngx_hash_find_wc_tail(
        hwc: *mut ngx_hash_wildcard_t,
        name: *mut u_char,
        len: size_t,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn ngx_hash_find_combined(
        hash: *mut ngx_hash_combined_t,
        key: ngx_uint_t,
        name: *mut u_char,
        len: size_t,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn ngx_hash_init(
        hinit: *mut ngx_hash_init_t,
        names: *mut ngx_hash_key_t,
        nelts: ngx_uint_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_hash_wildcard_init(
        hinit: *mut ngx_hash_init_t,
        names: *mut ngx_hash_key_t,
        nelts: ngx_uint_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_hash_key(data: *mut u_char, len: size_t) -> ngx_uint_t;
}
extern "C" {
    pub fn ngx_hash_key_lc(data: *mut u_char, len: size_t) -> ngx_uint_t;
}
extern "C" {
    pub fn ngx_hash_strlow(dst: *mut u_char, src: *mut u_char, n: size_t) -> ngx_uint_t;
}
extern "C" {
    pub fn ngx_hash_keys_array_init(
        ha: *mut ngx_hash_keys_arrays_t,
        type_: ngx_uint_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_hash_add_key(
        ha: *mut ngx_hash_keys_arrays_t,
        key: *mut ngx_str_t,
        value: *mut libc::c_void,
        flags: ngx_uint_t,
    ) -> ngx_int_t;
}
#[repr(C)]
pub struct ngx_file_s {
    pub fd: ngx_fd_t,
    pub name: ngx_str_t,
    pub info: ngx_file_info_t,
    pub offset: off_t,
    pub sys_offset: off_t,
    pub log: *mut ngx_log_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl ::std::fmt::Debug for ngx_file_s {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_file_s {{ fd: {:?}, name: {:?}, log: {:?}, valid_info : {:?}, directio : {:?} }}",
            self.fd,
            self.name,
            self.log,
            self.valid_info(),
            self.directio()
        )
    }
}
impl ngx_file_s {
    #[inline]
    pub fn valid_info(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_valid_info(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn directio(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_directio(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        valid_info: libc::c_uint,
        directio: libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let valid_info: u32 = unsafe { ::std::mem::transmute(valid_info) };
            valid_info as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let directio: u32 = unsafe { ::std::mem::transmute(directio) };
            directio as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type ngx_path_manager_pt =
    ::std::option::Option<unsafe extern "C" fn(data: *mut libc::c_void) -> ngx_msec_t>;
pub type ngx_path_purger_pt =
    ::std::option::Option<unsafe extern "C" fn(data: *mut libc::c_void) -> ngx_msec_t>;
pub type ngx_path_loader_pt = ::std::option::Option<unsafe extern "C" fn(data: *mut libc::c_void)>;
#[repr(C)]
pub struct ngx_path_t {
    pub name: ngx_str_t,
    pub len: size_t,
    pub level: [size_t; 3usize],
    pub manager: ngx_path_manager_pt,
    pub purger: ngx_path_purger_pt,
    pub loader: ngx_path_loader_pt,
    pub data: *mut libc::c_void,
    pub conf_file: *mut u_char,
    pub line: ngx_uint_t,
}
impl ::std::fmt::Debug for ngx_path_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "ngx_path_t {{ name: {:?}, level: {:?}, manager: {:?}, purger: {:?}, loader: {:?}, data: {:?}, conf_file: {:?} }}" , self . name , self . level , self . manager , self . purger , self . loader , self . data , self . conf_file )
    }
}
#[repr(C)]
pub struct ngx_path_init_t {
    pub name: ngx_str_t,
    pub level: [size_t; 3usize],
}
impl ::std::fmt::Debug for ngx_path_init_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_path_init_t {{ name: {:?}, level: {:?} }}",
            self.name, self.level
        )
    }
}
#[repr(C)]
pub struct ngx_temp_file_t {
    pub file: ngx_file_t,
    pub offset: off_t,
    pub path: *mut ngx_path_t,
    pub pool: *mut ngx_pool_t,
    pub warn: *mut libc::c_char,
    pub access: ngx_uint_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub __bindgen_padding_0: [u16; 3usize],
}
impl ::std::fmt::Debug for ngx_temp_file_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "ngx_temp_file_t {{ file: {:?}, path: {:?}, pool: {:?}, warn: {:?}, log_level : {:?}, persistent : {:?}, clean : {:?}, thread_write : {:?} }}" , self . file , self . path , self . pool , self . warn , self . log_level ( ) , self . persistent ( ) , self . clean ( ) , self . thread_write ( ) )
    }
}
impl ngx_temp_file_t {
    #[inline]
    pub fn log_level(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_log_level(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn persistent(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_persistent(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clean(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clean(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn thread_write(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_thread_write(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        log_level: libc::c_uint,
        persistent: libc::c_uint,
        clean: libc::c_uint,
        thread_write: libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let log_level: u32 = unsafe { ::std::mem::transmute(log_level) };
            log_level as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let persistent: u32 = unsafe { ::std::mem::transmute(persistent) };
            persistent as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let clean: u32 = unsafe { ::std::mem::transmute(clean) };
            clean as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let thread_write: u32 = unsafe { ::std::mem::transmute(thread_write) };
            thread_write as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct ngx_ext_rename_file_t {
    pub access: ngx_uint_t,
    pub path_access: ngx_uint_t,
    pub time: time_t,
    pub fd: ngx_fd_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub log: *mut ngx_log_t,
}
impl ::std::fmt::Debug for ngx_ext_rename_file_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "ngx_ext_rename_file_t {{ fd: {:?}, create_path : {:?}, delete_file : {:?}, log: {:?} }}" , self . fd , self . create_path ( ) , self . delete_file ( ) , self . log )
    }
}
impl ngx_ext_rename_file_t {
    #[inline]
    pub fn create_path(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_create_path(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn delete_file(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_delete_file(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        create_path: libc::c_uint,
        delete_file: libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let create_path: u32 = unsafe { ::std::mem::transmute(create_path) };
            create_path as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let delete_file: u32 = unsafe { ::std::mem::transmute(delete_file) };
            delete_file as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct ngx_copy_file_t {
    pub size: off_t,
    pub buf_size: size_t,
    pub access: ngx_uint_t,
    pub time: time_t,
    pub log: *mut ngx_log_t,
}
impl ::std::fmt::Debug for ngx_copy_file_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "ngx_copy_file_t {{ log: {:?} }}", self.log)
    }
}
pub type ngx_tree_ctx_t = ngx_tree_ctx_s;
pub type ngx_tree_init_handler_pt = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut libc::c_void, prev: *mut libc::c_void) -> ngx_int_t,
>;
pub type ngx_tree_handler_pt = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ngx_tree_ctx_t, name: *mut ngx_str_t) -> ngx_int_t,
>;
#[repr(C)]
pub struct ngx_tree_ctx_s {
    pub size: off_t,
    pub fs_size: off_t,
    pub access: ngx_uint_t,
    pub mtime: time_t,
    pub init_handler: ngx_tree_init_handler_pt,
    pub file_handler: ngx_tree_handler_pt,
    pub pre_tree_handler: ngx_tree_handler_pt,
    pub post_tree_handler: ngx_tree_handler_pt,
    pub spec_handler: ngx_tree_handler_pt,
    pub data: *mut libc::c_void,
    pub alloc: size_t,
    pub log: *mut ngx_log_t,
}
impl ::std::fmt::Debug for ngx_tree_ctx_s {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "ngx_tree_ctx_s {{ init_handler: {:?}, file_handler: {:?}, pre_tree_handler: {:?}, post_tree_handler: {:?}, spec_handler: {:?}, data: {:?}, log: {:?} }}" , self . init_handler , self . file_handler , self . pre_tree_handler , self . post_tree_handler , self . spec_handler , self . data , self . log )
    }
}
extern "C" {
    pub fn ngx_get_full_name(
        pool: *mut ngx_pool_t,
        prefix: *mut ngx_str_t,
        name: *mut ngx_str_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_write_chain_to_temp_file(
        tf: *mut ngx_temp_file_t,
        chain: *mut ngx_chain_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn ngx_create_temp_file(
        file: *mut ngx_file_t,
        path: *mut ngx_path_t,
        pool: *mut ngx_pool_t,
        persistent: ngx_uint_t,
        clean: ngx_uint_t,
        access: ngx_uint_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_create_hashed_filename(path: *mut ngx_path_t, file: *mut u_char, len: size_t);
}
extern "C" {
    pub fn ngx_create_path(file: *mut ngx_file_t, path: *mut ngx_path_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_create_full_path(dir: *mut u_char, access: ngx_uint_t) -> ngx_err_t;
}
extern "C" {
    pub fn ngx_add_path(cf: *mut ngx_conf_t, slot: *mut *mut ngx_path_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_create_paths(cycle: *mut ngx_cycle_t, user: ngx_uid_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_ext_rename_file(
        src: *mut ngx_str_t,
        to: *mut ngx_str_t,
        ext: *mut ngx_ext_rename_file_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_copy_file(from: *mut u_char, to: *mut u_char, cf: *mut ngx_copy_file_t)
        -> ngx_int_t;
}
extern "C" {
    pub fn ngx_walk_tree(ctx: *mut ngx_tree_ctx_t, tree: *mut ngx_str_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_next_temp_number(collision: ngx_uint_t) -> ngx_atomic_uint_t;
}
extern "C" {
    pub fn ngx_conf_set_path_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut libc::c_void,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn ngx_conf_merge_path_value(
        cf: *mut ngx_conf_t,
        path: *mut *mut ngx_path_t,
        prev: *mut ngx_path_t,
        init: *mut ngx_path_init_t,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn ngx_conf_set_access_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut libc::c_void,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub static mut ngx_temp_number: *mut ngx_atomic_t;
}
extern "C" {
    pub static mut ngx_random_number: ngx_atomic_int_t;
}
extern "C" {
    pub static mut ngx_crc32_table_short: *mut u32;
}
extern "C" {
    pub static mut ngx_crc32_table256: [u32; 0usize];
}
extern "C" {
    pub fn ngx_crc32_table_init() -> ngx_int_t;
}
extern "C" {
    pub fn ngx_murmur_hash2(data: *mut u_char, len: size_t) -> u32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_regex_t {
    pub code: *mut pcre,
    pub extra: *mut pcre_extra,
}
#[repr(C)]
pub struct ngx_regex_compile_t {
    pub pattern: ngx_str_t,
    pub pool: *mut ngx_pool_t,
    pub options: ngx_int_t,
    pub regex: *mut ngx_regex_t,
    pub captures: libc::c_int,
    pub named_captures: libc::c_int,
    pub name_size: libc::c_int,
    pub names: *mut u_char,
    pub err: ngx_str_t,
}
impl ::std::fmt::Debug for ngx_regex_compile_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "ngx_regex_compile_t {{ pattern: {:?}, pool: {:?}, regex: {:?}, captures: {:?}, named_captures: {:?}, name_size: {:?}, names: {:?}, err: {:?} }}" , self . pattern , self . pool , self . regex , self . captures , self . named_captures , self . name_size , self . names , self . err )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_regex_elt_t {
    pub regex: *mut ngx_regex_t,
    pub name: *mut u_char,
}
extern "C" {
    pub fn ngx_regex_init();
}
extern "C" {
    pub fn ngx_regex_compile(rc: *mut ngx_regex_compile_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_regex_exec_array(
        a: *mut ngx_array_t,
        s: *mut ngx_str_t,
        log: *mut ngx_log_t,
    ) -> ngx_int_t;
}
pub type ngx_radix_node_t = ngx_radix_node_s;
#[repr(C)]
pub struct ngx_radix_node_s {
    pub right: *mut ngx_radix_node_t,
    pub left: *mut ngx_radix_node_t,
    pub parent: *mut ngx_radix_node_t,
    pub value: usize,
}
impl ::std::fmt::Debug for ngx_radix_node_s {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_radix_node_s {{ right: {:?}, left: {:?}, parent: {:?} }}",
            self.right, self.left, self.parent
        )
    }
}
#[repr(C)]
pub struct ngx_radix_tree_t {
    pub root: *mut ngx_radix_node_t,
    pub pool: *mut ngx_pool_t,
    pub free: *mut ngx_radix_node_t,
    pub start: *mut libc::c_char,
    pub size: size_t,
}
impl ::std::fmt::Debug for ngx_radix_tree_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_radix_tree_t {{ root: {:?}, pool: {:?}, free: {:?}, start: {:?} }}",
            self.root, self.pool, self.free, self.start
        )
    }
}
extern "C" {
    pub fn ngx_radix_tree_create(
        pool: *mut ngx_pool_t,
        preallocate: ngx_int_t,
    ) -> *mut ngx_radix_tree_t;
}
extern "C" {
    pub fn ngx_radix32tree_insert(
        tree: *mut ngx_radix_tree_t,
        key: u32,
        mask: u32,
        value: usize,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_radix32tree_delete(tree: *mut ngx_radix_tree_t, key: u32, mask: u32) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_radix32tree_find(tree: *mut ngx_radix_tree_t, key: u32) -> usize;
}
extern "C" {
    pub fn ngx_radix128tree_insert(
        tree: *mut ngx_radix_tree_t,
        key: *mut u_char,
        mask: *mut u_char,
        value: usize,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_radix128tree_delete(
        tree: *mut ngx_radix_tree_t,
        key: *mut u_char,
        mask: *mut u_char,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_radix128tree_find(tree: *mut ngx_radix_tree_t, key: *mut u_char) -> usize;
}
#[repr(C)]
pub struct ngx_time_t {
    pub sec: time_t,
    pub msec: ngx_uint_t,
    pub gmtoff: ngx_int_t,
}
impl ::std::fmt::Debug for ngx_time_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "ngx_time_t {{  }}")
    }
}
extern "C" {
    pub fn ngx_time_init();
}
extern "C" {
    pub fn ngx_time_update();
}
extern "C" {
    pub fn ngx_time_sigsafe_update();
}
extern "C" {
    pub fn ngx_http_time(buf: *mut u_char, t: time_t) -> *mut u_char;
}
extern "C" {
    pub fn ngx_http_cookie_time(buf: *mut u_char, t: time_t) -> *mut u_char;
}
extern "C" {
    pub fn ngx_gmtime(t: time_t, tp: *mut ngx_tm_t);
}
extern "C" {
    pub fn ngx_next_time(when: time_t) -> time_t;
}
extern "C" {
    pub static mut ngx_cached_time: *mut ngx_time_t;
}
extern "C" {
    pub static mut ngx_cached_err_log_time: ngx_str_t;
}
extern "C" {
    pub static mut ngx_cached_http_time: ngx_str_t;
}
extern "C" {
    pub static mut ngx_cached_http_log_time: ngx_str_t;
}
extern "C" {
    pub static mut ngx_cached_http_log_iso8601: ngx_str_t;
}
extern "C" {
    pub static mut ngx_cached_syslog_time: ngx_str_t;
}
extern "C" {
    pub static mut ngx_current_msec: ngx_msec_t;
}
extern "C" {
    pub fn ngx_rwlock_wlock(lock: *mut ngx_atomic_t);
}
extern "C" {
    pub fn ngx_rwlock_rlock(lock: *mut ngx_atomic_t);
}
extern "C" {
    pub fn ngx_rwlock_unlock(lock: *mut ngx_atomic_t);
}
extern "C" {
    pub fn ngx_rwlock_downgrade(lock: *mut ngx_atomic_t);
}
#[repr(C)]
pub struct ngx_shmtx_sh_t {
    pub lock: ngx_atomic_t,
}
impl ::std::fmt::Debug for ngx_shmtx_sh_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "ngx_shmtx_sh_t {{  }}")
    }
}
#[repr(C)]
pub struct ngx_shmtx_t {
    pub lock: *mut ngx_atomic_t,
    pub spin: ngx_uint_t,
}
impl ::std::fmt::Debug for ngx_shmtx_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "ngx_shmtx_t {{ lock: {:?} }}", self.lock)
    }
}
extern "C" {
    pub fn ngx_shmtx_create(
        mtx: *mut ngx_shmtx_t,
        addr: *mut ngx_shmtx_sh_t,
        name: *mut u_char,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_shmtx_destroy(mtx: *mut ngx_shmtx_t);
}
extern "C" {
    pub fn ngx_shmtx_trylock(mtx: *mut ngx_shmtx_t) -> ngx_uint_t;
}
extern "C" {
    pub fn ngx_shmtx_lock(mtx: *mut ngx_shmtx_t);
}
extern "C" {
    pub fn ngx_shmtx_unlock(mtx: *mut ngx_shmtx_t);
}
extern "C" {
    pub fn ngx_shmtx_force_unlock(mtx: *mut ngx_shmtx_t, pid: ngx_pid_t) -> ngx_uint_t;
}
pub type ngx_slab_page_t = ngx_slab_page_s;
#[repr(C)]
pub struct ngx_slab_page_s {
    pub slab: usize,
    pub next: *mut ngx_slab_page_t,
    pub prev: usize,
}
impl ::std::fmt::Debug for ngx_slab_page_s {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "ngx_slab_page_s {{ next: {:?} }}", self.next)
    }
}
#[repr(C)]
pub struct ngx_slab_stat_t {
    pub total: ngx_uint_t,
    pub used: ngx_uint_t,
    pub reqs: ngx_uint_t,
    pub fails: ngx_uint_t,
}
impl ::std::fmt::Debug for ngx_slab_stat_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "ngx_slab_stat_t {{  }}")
    }
}
#[repr(C)]
pub struct ngx_slab_pool_t {
    pub lock: ngx_shmtx_sh_t,
    pub min_size: size_t,
    pub min_shift: size_t,
    pub pages: *mut ngx_slab_page_t,
    pub last: *mut ngx_slab_page_t,
    pub free: ngx_slab_page_t,
    pub stats: *mut ngx_slab_stat_t,
    pub pfree: ngx_uint_t,
    pub start: *mut u_char,
    pub end: *mut u_char,
    pub mutex: ngx_shmtx_t,
    pub log_ctx: *mut u_char,
    pub zero: u_char,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub data: *mut libc::c_void,
    pub addr: *mut libc::c_void,
}
impl ::std::fmt::Debug for ngx_slab_pool_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "ngx_slab_pool_t {{ lock: {:?}, pages: {:?}, last: {:?}, free: {:?}, stats: {:?}, start: {:?}, end: {:?}, mutex: {:?}, log_ctx: {:?}, log_nomem : {:?}, data: {:?}, addr: {:?} }}" , self . lock , self . pages , self . last , self . free , self . stats , self . start , self . end , self . mutex , self . log_ctx , self . log_nomem ( ) , self . data , self . addr )
    }
}
impl ngx_slab_pool_t {
    #[inline]
    pub fn log_nomem(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_log_nomem(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(log_nomem: libc::c_uint) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let log_nomem: u32 = unsafe { ::std::mem::transmute(log_nomem) };
            log_nomem as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn ngx_slab_sizes_init();
}
extern "C" {
    pub fn ngx_slab_init(pool: *mut ngx_slab_pool_t);
}
extern "C" {
    pub fn ngx_slab_alloc(pool: *mut ngx_slab_pool_t, size: size_t) -> *mut libc::c_void;
}
extern "C" {
    pub fn ngx_slab_alloc_locked(pool: *mut ngx_slab_pool_t, size: size_t) -> *mut libc::c_void;
}
extern "C" {
    pub fn ngx_slab_calloc(pool: *mut ngx_slab_pool_t, size: size_t) -> *mut libc::c_void;
}
extern "C" {
    pub fn ngx_slab_calloc_locked(pool: *mut ngx_slab_pool_t, size: size_t) -> *mut libc::c_void;
}
extern "C" {
    pub fn ngx_slab_free(pool: *mut ngx_slab_pool_t, p: *mut libc::c_void);
}
extern "C" {
    pub fn ngx_slab_free_locked(pool: *mut ngx_slab_pool_t, p: *mut libc::c_void);
}
#[repr(C)]
pub struct ngx_sockaddr_t {
    pub sockaddr: __BindgenUnionField<sockaddr>,
    pub sockaddr_in: __BindgenUnionField<sockaddr_in>,
    pub sockaddr_in6: __BindgenUnionField<sockaddr_in6>,
    pub sockaddr_un: __BindgenUnionField<sockaddr_un>,
    pub bindgen_union_field: [u32; 27usize],
}
impl ::std::fmt::Debug for ngx_sockaddr_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "ngx_sockaddr_t {{ union }}")
    }
}
#[repr(C)]
pub struct ngx_in_cidr_t {
    pub addr: in_addr_t,
    pub mask: in_addr_t,
}
impl ::std::fmt::Debug for ngx_in_cidr_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "ngx_in_cidr_t {{  }}")
    }
}
#[repr(C)]
pub struct ngx_in6_cidr_t {
    pub addr: in6_addr,
    pub mask: in6_addr,
}
impl ::std::fmt::Debug for ngx_in6_cidr_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "ngx_in6_cidr_t {{  }}")
    }
}
#[repr(C)]
pub struct ngx_cidr_t {
    pub family: ngx_uint_t,
    pub u: ngx_cidr_t__bindgen_ty_1,
}
#[repr(C)]
pub struct ngx_cidr_t__bindgen_ty_1 {
    pub in_: __BindgenUnionField<ngx_in_cidr_t>,
    pub in6: __BindgenUnionField<ngx_in6_cidr_t>,
    pub bindgen_union_field: [u32; 8usize],
}
impl ::std::fmt::Debug for ngx_cidr_t__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "ngx_cidr_t__bindgen_ty_1 {{ union }}")
    }
}
impl ::std::fmt::Debug for ngx_cidr_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "ngx_cidr_t {{ u: {:?} }}", self.u)
    }
}
#[repr(C)]
pub struct ngx_addr_t {
    pub sockaddr: *mut sockaddr,
    pub socklen: socklen_t,
    pub name: ngx_str_t,
}
impl ::std::fmt::Debug for ngx_addr_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_addr_t {{ sockaddr: {:?}, name: {:?} }}",
            self.sockaddr, self.name
        )
    }
}
#[repr(C)]
pub struct ngx_url_t {
    pub url: ngx_str_t,
    pub host: ngx_str_t,
    pub port_text: ngx_str_t,
    pub uri: ngx_str_t,
    pub port: in_port_t,
    pub default_port: in_port_t,
    pub last_port: in_port_t,
    pub family: libc::c_int,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub socklen: socklen_t,
    pub sockaddr: ngx_sockaddr_t,
    pub addrs: *mut ngx_addr_t,
    pub naddrs: ngx_uint_t,
    pub err: *mut libc::c_char,
}
impl ::std::fmt::Debug for ngx_url_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "ngx_url_t {{ url: {:?}, host: {:?}, port_text: {:?}, uri: {:?}, family: {:?}, listen : {:?}, uri_part : {:?}, no_resolve : {:?}, no_port : {:?}, wildcard : {:?}, sockaddr: {:?}, addrs: {:?}, err: {:?} }}" , self . url , self . host , self . port_text , self . uri , self . family , self . listen ( ) , self . uri_part ( ) , self . no_resolve ( ) , self . no_port ( ) , self . wildcard ( ) , self . sockaddr , self . addrs , self . err )
    }
}
impl ngx_url_t {
    #[inline]
    pub fn listen(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_listen(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn uri_part(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_uri_part(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_resolve(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_resolve(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_port(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_port(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wildcard(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wildcard(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        listen: libc::c_uint,
        uri_part: libc::c_uint,
        no_resolve: libc::c_uint,
        no_port: libc::c_uint,
        wildcard: libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let listen: u32 = unsafe { ::std::mem::transmute(listen) };
            listen as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let uri_part: u32 = unsafe { ::std::mem::transmute(uri_part) };
            uri_part as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let no_resolve: u32 = unsafe { ::std::mem::transmute(no_resolve) };
            no_resolve as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let no_port: u32 = unsafe { ::std::mem::transmute(no_port) };
            no_port as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let wildcard: u32 = unsafe { ::std::mem::transmute(wildcard) };
            wildcard as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn ngx_inet_addr(text: *mut u_char, len: size_t) -> in_addr_t;
}
extern "C" {
    pub fn ngx_inet6_addr(p: *mut u_char, len: size_t, addr: *mut u_char) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_inet6_ntop(p: *mut u_char, text: *mut u_char, len: size_t) -> size_t;
}
extern "C" {
    pub fn ngx_sock_ntop(
        sa: *mut sockaddr,
        socklen: socklen_t,
        text: *mut u_char,
        len: size_t,
        port: ngx_uint_t,
    ) -> size_t;
}
extern "C" {
    pub fn ngx_inet_ntop(
        family: libc::c_int,
        addr: *mut libc::c_void,
        text: *mut u_char,
        len: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn ngx_ptocidr(text: *mut ngx_str_t, cidr: *mut ngx_cidr_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_cidr_match(sa: *mut sockaddr, cidrs: *mut ngx_array_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_parse_addr(
        pool: *mut ngx_pool_t,
        addr: *mut ngx_addr_t,
        text: *mut u_char,
        len: size_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_parse_addr_port(
        pool: *mut ngx_pool_t,
        addr: *mut ngx_addr_t,
        text: *mut u_char,
        len: size_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_parse_url(pool: *mut ngx_pool_t, u: *mut ngx_url_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_inet_resolve_host(pool: *mut ngx_pool_t, u: *mut ngx_url_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_cmp_sockaddr(
        sa1: *mut sockaddr,
        slen1: socklen_t,
        sa2: *mut sockaddr,
        slen2: socklen_t,
        cmp_port: ngx_uint_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_inet_get_port(sa: *mut sockaddr) -> in_port_t;
}
extern "C" {
    pub fn ngx_inet_set_port(sa: *mut sockaddr, port: in_port_t);
}
extern "C" {
    pub fn ngx_inet_wildcard(sa: *mut sockaddr) -> ngx_uint_t;
}
pub type ngx_shm_zone_t = ngx_shm_zone_s;
pub type ngx_shm_zone_init_pt = ::std::option::Option<
    unsafe extern "C" fn(zone: *mut ngx_shm_zone_t, data: *mut libc::c_void) -> ngx_int_t,
>;
#[repr(C)]
pub struct ngx_shm_zone_s {
    pub data: *mut libc::c_void,
    pub shm: ngx_shm_t,
    pub init: ngx_shm_zone_init_pt,
    pub tag: *mut libc::c_void,
    pub sync: *mut libc::c_void,
    pub noreuse: ngx_uint_t,
}
impl ::std::fmt::Debug for ngx_shm_zone_s {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_shm_zone_s {{ data: {:?}, shm: {:?}, init: {:?}, tag: {:?}, sync: {:?} }}",
            self.data, self.shm, self.init, self.tag, self.sync
        )
    }
}
#[repr(C)]
pub struct ngx_cycle_s {
    pub conf_ctx: *mut *mut *mut *mut libc::c_void,
    pub pool: *mut ngx_pool_t,
    pub log: *mut ngx_log_t,
    pub new_log: ngx_log_t,
    pub log_use_stderr: ngx_uint_t,
    pub files: *mut *mut ngx_connection_t,
    pub free_connections: *mut ngx_connection_t,
    pub free_connection_n: ngx_uint_t,
    pub modules: *mut *mut ngx_module_t,
    pub modules_n: ngx_uint_t,
    pub modules_used: ngx_uint_t,
    pub reusable_connections_queue: ngx_queue_t,
    pub reusable_connections_n: ngx_uint_t,
    pub listening: ngx_array_t,
    pub paths: ngx_array_t,
    pub config_dump: ngx_array_t,
    pub config_dump_rbtree: ngx_rbtree_t,
    pub config_dump_sentinel: ngx_rbtree_node_t,
    pub open_files: ngx_list_t,
    pub shared_memory: ngx_list_t,
    pub connection_n: ngx_uint_t,
    pub files_n: ngx_uint_t,
    pub connections: *mut ngx_connection_t,
    pub read_events: *mut ngx_event_t,
    pub write_events: *mut ngx_event_t,
    pub old_cycle: *mut ngx_cycle_t,
    pub conf_file: ngx_str_t,
    pub conf_param: ngx_str_t,
    pub conf_prefix: ngx_str_t,
    pub prefix: ngx_str_t,
    pub lock_file: ngx_str_t,
    pub hostname: ngx_str_t,
}
impl ::std::fmt::Debug for ngx_cycle_s {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "ngx_cycle_s {{ conf_ctx: {:?}, pool: {:?}, log: {:?}, new_log: {:?}, files: {:?}, free_connections: {:?}, modules: {:?}, reusable_connections_queue: {:?}, listening: {:?}, paths: {:?}, config_dump: {:?}, config_dump_rbtree: {:?}, config_dump_sentinel: {:?}, open_files: {:?}, shared_memory: {:?}, connections: {:?}, read_events: {:?}, write_events: {:?}, old_cycle: {:?}, conf_file: {:?}, conf_param: {:?}, conf_prefix: {:?}, prefix: {:?}, lock_file: {:?}, hostname: {:?} }}" , self . conf_ctx , self . pool , self . log , self . new_log , self . files , self . free_connections , self . modules , self . reusable_connections_queue , self . listening , self . paths , self . config_dump , self . config_dump_rbtree , self . config_dump_sentinel , self . open_files , self . shared_memory , self . connections , self . read_events , self . write_events , self . old_cycle , self . conf_file , self . conf_param , self . conf_prefix , self . prefix , self . lock_file , self . hostname )
    }
}
#[repr(C)]
pub struct ngx_core_conf_t {
    pub daemon: ngx_flag_t,
    pub master: ngx_flag_t,
    pub timer_resolution: ngx_msec_t,
    pub shutdown_timeout: ngx_msec_t,
    pub worker_processes: ngx_int_t,
    pub debug_points: ngx_int_t,
    pub rlimit_nofile: ngx_int_t,
    pub rlimit_core: off_t,
    pub priority: libc::c_int,
    pub cpu_affinity_auto: ngx_uint_t,
    pub cpu_affinity_n: ngx_uint_t,
    pub cpu_affinity: *mut ngx_cpuset_t,
    pub username: *mut libc::c_char,
    pub user: ngx_uid_t,
    pub group: ngx_gid_t,
    pub working_directory: ngx_str_t,
    pub lock_file: ngx_str_t,
    pub pid: ngx_str_t,
    pub oldpid: ngx_str_t,
    pub env: ngx_array_t,
    pub environment: *mut *mut libc::c_char,
    pub transparent: ngx_uint_t,
}
impl ::std::fmt::Debug for ngx_core_conf_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "ngx_core_conf_t {{ priority: {:?}, cpu_affinity: {:?}, username: {:?}, working_directory: {:?}, lock_file: {:?}, pid: {:?}, oldpid: {:?}, env: {:?}, environment: {:?} }}" , self . priority , self . cpu_affinity , self . username , self . working_directory , self . lock_file , self . pid , self . oldpid , self . env , self . environment )
    }
}
extern "C" {
    pub fn ngx_init_cycle(old_cycle: *mut ngx_cycle_t) -> *mut ngx_cycle_t;
}
extern "C" {
    pub fn ngx_create_pidfile(name: *mut ngx_str_t, log: *mut ngx_log_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_delete_pidfile(cycle: *mut ngx_cycle_t);
}
extern "C" {
    pub fn ngx_signal_process(cycle: *mut ngx_cycle_t, sig: *mut libc::c_char) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_reopen_files(cycle: *mut ngx_cycle_t, user: ngx_uid_t);
}
extern "C" {
    pub fn ngx_set_environment(
        cycle: *mut ngx_cycle_t,
        last: *mut ngx_uint_t,
    ) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn ngx_exec_new_binary(
        cycle: *mut ngx_cycle_t,
        argv: *const *mut libc::c_char,
    ) -> ngx_pid_t;
}
extern "C" {
    pub fn ngx_get_cpu_affinity(n: ngx_uint_t) -> *mut ngx_cpuset_t;
}
extern "C" {
    pub fn ngx_shared_memory_add(
        cf: *mut ngx_conf_t,
        name: *mut ngx_str_t,
        size: size_t,
        tag: *mut libc::c_void,
    ) -> *mut ngx_shm_zone_t;
}
extern "C" {
    pub fn ngx_set_shutdown_timer(cycle: *mut ngx_cycle_t);
}
extern "C" {
    pub static mut ngx_cycle: *mut ngx_cycle_t;
}
extern "C" {
    pub static mut ngx_old_cycles: ngx_array_t;
}
extern "C" {
    pub static mut ngx_core_module: ngx_module_t;
}
extern "C" {
    pub static mut ngx_test_config: ngx_uint_t;
}
extern "C" {
    pub static mut ngx_dump_config: ngx_uint_t;
}
extern "C" {
    pub static mut ngx_quiet_mode: ngx_uint_t;
}
pub type ngx_resolver_t = ngx_resolver_s;
#[repr(C)]
pub struct ngx_resolver_connection_t {
    pub udp: *mut ngx_connection_t,
    pub tcp: *mut ngx_connection_t,
    pub sockaddr: *mut sockaddr,
    pub socklen: socklen_t,
    pub server: ngx_str_t,
    pub log: ngx_log_t,
    pub read_buf: *mut ngx_buf_t,
    pub write_buf: *mut ngx_buf_t,
    pub resolver: *mut ngx_resolver_t,
}
impl ::std::fmt::Debug for ngx_resolver_connection_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "ngx_resolver_connection_t {{ udp: {:?}, tcp: {:?}, sockaddr: {:?}, server: {:?}, log: {:?}, read_buf: {:?}, write_buf: {:?}, resolver: {:?} }}" , self . udp , self . tcp , self . sockaddr , self . server , self . log , self . read_buf , self . write_buf , self . resolver )
    }
}
pub type ngx_resolver_ctx_t = ngx_resolver_ctx_s;
pub type ngx_resolver_handler_pt =
    ::std::option::Option<unsafe extern "C" fn(ctx: *mut ngx_resolver_ctx_t)>;
#[repr(C)]
pub struct ngx_resolver_addr_t {
    pub sockaddr: *mut sockaddr,
    pub socklen: socklen_t,
    pub name: ngx_str_t,
    pub priority: u_short,
    pub weight: u_short,
}
impl ::std::fmt::Debug for ngx_resolver_addr_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_resolver_addr_t {{ sockaddr: {:?}, name: {:?} }}",
            self.sockaddr, self.name
        )
    }
}
#[repr(C)]
pub struct ngx_resolver_srv_t {
    pub name: ngx_str_t,
    pub priority: u_short,
    pub weight: u_short,
    pub port: u_short,
}
impl ::std::fmt::Debug for ngx_resolver_srv_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "ngx_resolver_srv_t {{ name: {:?} }}", self.name)
    }
}
#[repr(C)]
pub struct ngx_resolver_srv_name_t {
    pub name: ngx_str_t,
    pub priority: u_short,
    pub weight: u_short,
    pub port: u_short,
    pub ctx: *mut ngx_resolver_ctx_t,
    pub state: ngx_int_t,
    pub naddrs: ngx_uint_t,
    pub addrs: *mut ngx_addr_t,
}
impl ::std::fmt::Debug for ngx_resolver_srv_name_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_resolver_srv_name_t {{ name: {:?}, ctx: {:?}, addrs: {:?} }}",
            self.name, self.ctx, self.addrs
        )
    }
}
#[repr(C)]
pub struct ngx_resolver_node_t {
    pub node: ngx_rbtree_node_t,
    pub queue: ngx_queue_t,
    pub name: *mut u_char,
    pub addr6: in6_addr,
    pub nlen: u_short,
    pub qlen: u_short,
    pub query: *mut u_char,
    pub query6: *mut u_char,
    pub u: ngx_resolver_node_t__bindgen_ty_1,
    pub code: u_char,
    pub naddrs: u_short,
    pub nsrvs: u_short,
    pub cnlen: u_short,
    pub u6: ngx_resolver_node_t__bindgen_ty_2,
    pub naddrs6: u_short,
    pub expire: time_t,
    pub valid: time_t,
    pub ttl: u32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub last_connection: ngx_uint_t,
    pub waiting: *mut ngx_resolver_ctx_t,
}
#[repr(C)]
pub struct ngx_resolver_node_t__bindgen_ty_1 {
    pub addr: __BindgenUnionField<in_addr_t>,
    pub addrs: __BindgenUnionField<*mut in_addr_t>,
    pub cname: __BindgenUnionField<*mut u_char>,
    pub srvs: __BindgenUnionField<*mut ngx_resolver_srv_t>,
    pub bindgen_union_field: u64,
}
impl ::std::fmt::Debug for ngx_resolver_node_t__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "ngx_resolver_node_t__bindgen_ty_1 {{ union }}")
    }
}
#[repr(C)]
pub struct ngx_resolver_node_t__bindgen_ty_2 {
    pub addr6: __BindgenUnionField<in6_addr>,
    pub addrs6: __BindgenUnionField<*mut in6_addr>,
    pub bindgen_union_field: [u64; 2usize],
}
impl ::std::fmt::Debug for ngx_resolver_node_t__bindgen_ty_2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "ngx_resolver_node_t__bindgen_ty_2 {{ union }}")
    }
}
impl ::std::fmt::Debug for ngx_resolver_node_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "ngx_resolver_node_t {{ node: {:?}, queue: {:?}, name: {:?}, query: {:?}, query6: {:?}, u: {:?}, u6: {:?}, tcp : {:?}, tcp6 : {:?}, waiting: {:?} }}" , self . node , self . queue , self . name , self . query , self . query6 , self . u , self . u6 , self . tcp ( ) , self . tcp6 ( ) , self . waiting )
    }
}
impl ngx_resolver_node_t {
    #[inline]
    pub fn tcp(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tcp(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tcp6(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tcp6(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tcp: libc::c_uint,
        tcp6: libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let tcp: u32 = unsafe { ::std::mem::transmute(tcp) };
            tcp as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let tcp6: u32 = unsafe { ::std::mem::transmute(tcp6) };
            tcp6 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct ngx_resolver_s {
    pub event: *mut ngx_event_t,
    pub dummy: *mut libc::c_void,
    pub log: *mut ngx_log_t,
    pub ident: ngx_int_t,
    pub connections: ngx_array_t,
    pub last_connection: ngx_uint_t,
    pub name_rbtree: ngx_rbtree_t,
    pub name_sentinel: ngx_rbtree_node_t,
    pub srv_rbtree: ngx_rbtree_t,
    pub srv_sentinel: ngx_rbtree_node_t,
    pub addr_rbtree: ngx_rbtree_t,
    pub addr_sentinel: ngx_rbtree_node_t,
    pub name_resend_queue: ngx_queue_t,
    pub srv_resend_queue: ngx_queue_t,
    pub addr_resend_queue: ngx_queue_t,
    pub name_expire_queue: ngx_queue_t,
    pub srv_expire_queue: ngx_queue_t,
    pub addr_expire_queue: ngx_queue_t,
    pub ipv6: ngx_uint_t,
    pub addr6_rbtree: ngx_rbtree_t,
    pub addr6_sentinel: ngx_rbtree_node_t,
    pub addr6_resend_queue: ngx_queue_t,
    pub addr6_expire_queue: ngx_queue_t,
    pub resend_timeout: time_t,
    pub tcp_timeout: time_t,
    pub expire: time_t,
    pub valid: time_t,
    pub log_level: ngx_uint_t,
}
impl ::std::fmt::Debug for ngx_resolver_s {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "ngx_resolver_s {{ event: {:?}, dummy: {:?}, log: {:?}, connections: {:?}, name_rbtree: {:?}, name_sentinel: {:?}, srv_rbtree: {:?}, srv_sentinel: {:?}, addr_rbtree: {:?}, addr_sentinel: {:?}, name_resend_queue: {:?}, srv_resend_queue: {:?}, addr_resend_queue: {:?}, name_expire_queue: {:?}, srv_expire_queue: {:?}, addr_expire_queue: {:?}, addr6_rbtree: {:?}, addr6_sentinel: {:?}, addr6_resend_queue: {:?}, addr6_expire_queue: {:?} }}" , self . event , self . dummy , self . log , self . connections , self . name_rbtree , self . name_sentinel , self . srv_rbtree , self . srv_sentinel , self . addr_rbtree , self . addr_sentinel , self . name_resend_queue , self . srv_resend_queue , self . addr_resend_queue , self . name_expire_queue , self . srv_expire_queue , self . addr_expire_queue , self . addr6_rbtree , self . addr6_sentinel , self . addr6_resend_queue , self . addr6_expire_queue )
    }
}
#[repr(C)]
pub struct ngx_resolver_ctx_s {
    pub next: *mut ngx_resolver_ctx_t,
    pub resolver: *mut ngx_resolver_t,
    pub node: *mut ngx_resolver_node_t,
    pub ident: ngx_int_t,
    pub state: ngx_int_t,
    pub name: ngx_str_t,
    pub service: ngx_str_t,
    pub valid: time_t,
    pub naddrs: ngx_uint_t,
    pub addrs: *mut ngx_resolver_addr_t,
    pub addr: ngx_resolver_addr_t,
    pub sin: sockaddr_in,
    pub count: ngx_uint_t,
    pub nsrvs: ngx_uint_t,
    pub srvs: *mut ngx_resolver_srv_name_t,
    pub handler: ngx_resolver_handler_pt,
    pub data: *mut libc::c_void,
    pub timeout: ngx_msec_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub recursion: ngx_uint_t,
    pub event: *mut ngx_event_t,
}
impl ::std::fmt::Debug for ngx_resolver_ctx_s {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "ngx_resolver_ctx_s {{ next: {:?}, resolver: {:?}, node: {:?}, name: {:?}, service: {:?}, addrs: {:?}, addr: {:?}, srvs: {:?}, handler: {:?}, data: {:?}, quick : {:?}, async : {:?}, cancelable : {:?}, event: {:?} }}" , self . next , self . resolver , self . node , self . name , self . service , self . addrs , self . addr , self . srvs , self . handler , self . data , self . quick ( ) , self . async_ ( ) , self . cancelable ( ) , self . event )
    }
}
impl ngx_resolver_ctx_s {
    #[inline]
    pub fn quick(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_quick(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn async_(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_async(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cancelable(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cancelable(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        quick: libc::c_uint,
        async_: libc::c_uint,
        cancelable: libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let quick: u32 = unsafe { ::std::mem::transmute(quick) };
            quick as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let async_: u32 = unsafe { ::std::mem::transmute(async_) };
            async_ as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let cancelable: u32 = unsafe { ::std::mem::transmute(cancelable) };
            cancelable as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn ngx_resolver_create(
        cf: *mut ngx_conf_t,
        names: *mut ngx_str_t,
        n: ngx_uint_t,
    ) -> *mut ngx_resolver_t;
}
extern "C" {
    pub fn ngx_resolve_start(
        r: *mut ngx_resolver_t,
        temp: *mut ngx_resolver_ctx_t,
    ) -> *mut ngx_resolver_ctx_t;
}
extern "C" {
    pub fn ngx_resolve_name(ctx: *mut ngx_resolver_ctx_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_resolve_name_done(ctx: *mut ngx_resolver_ctx_t);
}
extern "C" {
    pub fn ngx_resolve_addr(ctx: *mut ngx_resolver_ctx_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_resolve_addr_done(ctx: *mut ngx_resolver_ctx_t);
}
extern "C" {
    pub fn ngx_resolver_strerror(err: ngx_int_t) -> *mut libc::c_char;
}
#[repr(C)]
pub struct ngx_cache_manager_ctx_t {
    pub handler: ngx_event_handler_pt,
    pub name: *mut libc::c_char,
    pub delay: ngx_msec_t,
}
impl ::std::fmt::Debug for ngx_cache_manager_ctx_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_cache_manager_ctx_t {{ handler: {:?}, name: {:?} }}",
            self.handler, self.name
        )
    }
}
extern "C" {
    pub fn ngx_master_process_cycle(cycle: *mut ngx_cycle_t);
}
extern "C" {
    pub fn ngx_single_process_cycle(cycle: *mut ngx_cycle_t);
}
extern "C" {
    pub static mut ngx_process: ngx_uint_t;
}
extern "C" {
    pub static mut ngx_worker: ngx_uint_t;
}
extern "C" {
    pub static mut ngx_new_binary: ngx_pid_t;
}
extern "C" {
    pub static mut ngx_inherited: ngx_uint_t;
}
extern "C" {
    pub static mut ngx_daemonized: ngx_uint_t;
}
extern "C" {
    pub static mut ngx_exiting: ngx_uint_t;
}
extern "C" {
    pub static mut ngx_reap: sig_atomic_t;
}
extern "C" {
    pub static mut ngx_sigio: sig_atomic_t;
}
extern "C" {
    pub static mut ngx_sigalrm: sig_atomic_t;
}
extern "C" {
    pub static mut ngx_quit: sig_atomic_t;
}
extern "C" {
    pub static mut ngx_debug_quit: sig_atomic_t;
}
extern "C" {
    pub static mut ngx_terminate: sig_atomic_t;
}
extern "C" {
    pub static mut ngx_noaccept: sig_atomic_t;
}
extern "C" {
    pub static mut ngx_reconfigure: sig_atomic_t;
}
extern "C" {
    pub static mut ngx_reopen: sig_atomic_t;
}
extern "C" {
    pub static mut ngx_change_binary: sig_atomic_t;
}
#[repr(C)]
pub struct ngx_command_s {
    pub name: ngx_str_t,
    pub type_: ngx_uint_t,
    pub set: ::std::option::Option<
        unsafe extern "C" fn(
            cf: *mut ngx_conf_t,
            cmd: *mut ngx_command_t,
            conf: *mut libc::c_void,
        ) -> *mut libc::c_char,
    >,
    pub conf: ngx_uint_t,
    pub offset: ngx_uint_t,
    pub post: *mut libc::c_void,
}
impl ::std::fmt::Debug for ngx_command_s {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_command_s {{ name: {:?}, set: {:?}, post: {:?} }}",
            self.name, self.set, self.post
        )
    }
}
#[repr(C)]
pub struct ngx_open_file_s {
    pub fd: ngx_fd_t,
    pub name: ngx_str_t,
    pub flush: ::std::option::Option<
        unsafe extern "C" fn(file: *mut ngx_open_file_t, log: *mut ngx_log_t),
    >,
    pub data: *mut libc::c_void,
}
impl ::std::fmt::Debug for ngx_open_file_s {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_open_file_s {{ fd: {:?}, name: {:?}, flush: {:?}, data: {:?} }}",
            self.fd, self.name, self.flush, self.data
        )
    }
}
#[repr(C)]
pub struct ngx_conf_file_t {
    pub file: ngx_file_t,
    pub buffer: *mut ngx_buf_t,
    pub dump: *mut ngx_buf_t,
    pub line: ngx_uint_t,
}
impl ::std::fmt::Debug for ngx_conf_file_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_conf_file_t {{ file: {:?}, buffer: {:?}, dump: {:?} }}",
            self.file, self.buffer, self.dump
        )
    }
}
#[repr(C)]
pub struct ngx_conf_dump_t {
    pub name: ngx_str_t,
    pub buffer: *mut ngx_buf_t,
}
impl ::std::fmt::Debug for ngx_conf_dump_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_conf_dump_t {{ name: {:?}, buffer: {:?} }}",
            self.name, self.buffer
        )
    }
}
pub type ngx_conf_handler_pt = ::std::option::Option<
    unsafe extern "C" fn(
        cf: *mut ngx_conf_t,
        dummy: *mut ngx_command_t,
        conf: *mut libc::c_void,
    ) -> *mut libc::c_char,
>;
#[repr(C)]
pub struct ngx_conf_s {
    pub name: *mut libc::c_char,
    pub args: *mut ngx_array_t,
    pub cycle: *mut ngx_cycle_t,
    pub pool: *mut ngx_pool_t,
    pub temp_pool: *mut ngx_pool_t,
    pub conf_file: *mut ngx_conf_file_t,
    pub log: *mut ngx_log_t,
    pub ctx: *mut libc::c_void,
    pub module_type: ngx_uint_t,
    pub cmd_type: ngx_uint_t,
    pub handler: ngx_conf_handler_pt,
    pub handler_conf: *mut libc::c_void,
}
impl ::std::fmt::Debug for ngx_conf_s {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "ngx_conf_s {{ name: {:?}, args: {:?}, cycle: {:?}, pool: {:?}, temp_pool: {:?}, conf_file: {:?}, log: {:?}, ctx: {:?}, handler: {:?}, handler_conf: {:?} }}" , self . name , self . args , self . cycle , self . pool , self . temp_pool , self . conf_file , self . log , self . ctx , self . handler , self . handler_conf )
    }
}
pub type ngx_conf_post_handler_pt = ::std::option::Option<
    unsafe extern "C" fn(
        cf: *mut ngx_conf_t,
        data: *mut libc::c_void,
        conf: *mut libc::c_void,
    ) -> *mut libc::c_char,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_conf_post_t {
    pub post_handler: ngx_conf_post_handler_pt,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_conf_deprecated_t {
    pub post_handler: ngx_conf_post_handler_pt,
    pub old_name: *mut libc::c_char,
    pub new_name: *mut libc::c_char,
}
#[repr(C)]
pub struct ngx_conf_num_bounds_t {
    pub post_handler: ngx_conf_post_handler_pt,
    pub low: ngx_int_t,
    pub high: ngx_int_t,
}
impl ::std::fmt::Debug for ngx_conf_num_bounds_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_conf_num_bounds_t {{ post_handler: {:?} }}",
            self.post_handler
        )
    }
}
#[repr(C)]
pub struct ngx_conf_enum_t {
    pub name: ngx_str_t,
    pub value: ngx_uint_t,
}
impl ::std::fmt::Debug for ngx_conf_enum_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "ngx_conf_enum_t {{ name: {:?} }}", self.name)
    }
}
#[repr(C)]
pub struct ngx_conf_bitmask_t {
    pub name: ngx_str_t,
    pub mask: ngx_uint_t,
}
impl ::std::fmt::Debug for ngx_conf_bitmask_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "ngx_conf_bitmask_t {{ name: {:?} }}", self.name)
    }
}
extern "C" {
    pub fn ngx_conf_deprecated(
        cf: *mut ngx_conf_t,
        post: *mut libc::c_void,
        data: *mut libc::c_void,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn ngx_conf_check_num_bounds(
        cf: *mut ngx_conf_t,
        post: *mut libc::c_void,
        data: *mut libc::c_void,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn ngx_conf_param(cf: *mut ngx_conf_t) -> *mut libc::c_char;
}
extern "C" {
    pub fn ngx_conf_parse(cf: *mut ngx_conf_t, filename: *mut ngx_str_t) -> *mut libc::c_char;
}
extern "C" {
    pub fn ngx_conf_include(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut libc::c_void,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn ngx_conf_full_name(
        cycle: *mut ngx_cycle_t,
        name: *mut ngx_str_t,
        conf_prefix: ngx_uint_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_conf_open_file(
        cycle: *mut ngx_cycle_t,
        name: *mut ngx_str_t,
    ) -> *mut ngx_open_file_t;
}
extern "C" {
    pub fn ngx_conf_log_error(
        level: ngx_uint_t,
        cf: *mut ngx_conf_t,
        err: ngx_err_t,
        fmt: *const libc::c_char,
        ...
    );
}
extern "C" {
    pub fn ngx_conf_set_flag_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut libc::c_void,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn ngx_conf_set_str_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut libc::c_void,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn ngx_conf_set_str_array_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut libc::c_void,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn ngx_conf_set_keyval_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut libc::c_void,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn ngx_conf_set_num_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut libc::c_void,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn ngx_conf_set_size_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut libc::c_void,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn ngx_conf_set_off_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut libc::c_void,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn ngx_conf_set_msec_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut libc::c_void,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn ngx_conf_set_sec_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut libc::c_void,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn ngx_conf_set_bufs_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut libc::c_void,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn ngx_conf_set_enum_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut libc::c_void,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn ngx_conf_set_bitmask_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut libc::c_void,
    ) -> *mut libc::c_char;
}
#[repr(C)]
pub struct ngx_module_s {
    pub ctx_index: ngx_uint_t,
    pub index: ngx_uint_t,
    pub name: *mut libc::c_char,
    pub spare0: ngx_uint_t,
    pub spare1: ngx_uint_t,
    pub version: ngx_uint_t,
    pub signature: *const libc::c_char,
    pub ctx: *mut libc::c_void,
    pub commands: *mut ngx_command_t,
    pub type_: ngx_uint_t,
    pub init_master: ::std::option::Option<unsafe extern "C" fn(log: *mut ngx_log_t) -> ngx_int_t>,
    pub init_module:
        ::std::option::Option<unsafe extern "C" fn(cycle: *mut ngx_cycle_t) -> ngx_int_t>,
    pub init_process:
        ::std::option::Option<unsafe extern "C" fn(cycle: *mut ngx_cycle_t) -> ngx_int_t>,
    pub init_thread:
        ::std::option::Option<unsafe extern "C" fn(cycle: *mut ngx_cycle_t) -> ngx_int_t>,
    pub exit_thread: ::std::option::Option<unsafe extern "C" fn(cycle: *mut ngx_cycle_t)>,
    pub exit_process: ::std::option::Option<unsafe extern "C" fn(cycle: *mut ngx_cycle_t)>,
    pub exit_master: ::std::option::Option<unsafe extern "C" fn(cycle: *mut ngx_cycle_t)>,
    pub spare_hook0: usize,
    pub spare_hook1: usize,
    pub spare_hook2: usize,
    pub spare_hook3: usize,
    pub spare_hook4: usize,
    pub spare_hook5: usize,
    pub spare_hook6: usize,
    pub spare_hook7: usize,
}
impl ::std::fmt::Debug for ngx_module_s {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "ngx_module_s {{ name: {:?}, signature: {:?}, ctx: {:?}, commands: {:?}, init_master: {:?}, init_module: {:?}, init_process: {:?}, init_thread: {:?}, exit_thread: {:?}, exit_process: {:?}, exit_master: {:?} }}" , self . name , self . signature , self . ctx , self . commands , self . init_master , self . init_module , self . init_process , self . init_thread , self . exit_thread , self . exit_process , self . exit_master )
    }
}
#[repr(C)]
pub struct ngx_core_module_t {
    pub name: ngx_str_t,
    pub create_conf:
        ::std::option::Option<unsafe extern "C" fn(cycle: *mut ngx_cycle_t) -> *mut libc::c_void>,
    pub init_conf: ::std::option::Option<
        unsafe extern "C" fn(cycle: *mut ngx_cycle_t, conf: *mut libc::c_void) -> *mut libc::c_char,
    >,
}
impl ::std::fmt::Debug for ngx_core_module_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_core_module_t {{ name: {:?}, create_conf: {:?}, init_conf: {:?} }}",
            self.name, self.create_conf, self.init_conf
        )
    }
}
extern "C" {
    pub fn ngx_preinit_modules() -> ngx_int_t;
}
extern "C" {
    pub fn ngx_cycle_modules(cycle: *mut ngx_cycle_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_init_modules(cycle: *mut ngx_cycle_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_count_modules(cycle: *mut ngx_cycle_t, type_: ngx_uint_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_add_module(
        cf: *mut ngx_conf_t,
        file: *mut ngx_str_t,
        module: *mut ngx_module_t,
        order: *mut *mut libc::c_char,
    ) -> ngx_int_t;
}
extern "C" {
    pub static mut ngx_modules: [*mut ngx_module_t; 0usize];
}
extern "C" {
    pub static mut ngx_max_module: ngx_uint_t;
}
extern "C" {
    pub static mut ngx_module_names: [*mut libc::c_char; 0usize];
}
#[repr(C)]
pub struct ngx_open_file_info_t {
    pub fd: ngx_fd_t,
    pub uniq: ngx_file_uniq_t,
    pub mtime: time_t,
    pub size: off_t,
    pub fs_size: off_t,
    pub directio: off_t,
    pub read_ahead: size_t,
    pub err: ngx_err_t,
    pub failed: *mut libc::c_char,
    pub valid: time_t,
    pub min_uses: ngx_uint_t,
    pub disable_symlinks_from: size_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub __bindgen_padding_0: [u16; 3usize],
}
impl ::std::fmt::Debug for ngx_open_file_info_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "ngx_open_file_info_t {{ fd: {:?}, err: {:?}, failed: {:?}, disable_symlinks : {:?}, test_dir : {:?}, test_only : {:?}, log : {:?}, errors : {:?}, events : {:?}, is_dir : {:?}, is_file : {:?}, is_link : {:?}, is_exec : {:?}, is_directio : {:?} }}" , self . fd , self . err , self . failed , self . disable_symlinks ( ) , self . test_dir ( ) , self . test_only ( ) , self . log ( ) , self . errors ( ) , self . events ( ) , self . is_dir ( ) , self . is_file ( ) , self . is_link ( ) , self . is_exec ( ) , self . is_directio ( ) )
    }
}
impl ngx_open_file_info_t {
    #[inline]
    pub fn disable_symlinks(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_disable_symlinks(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn test_dir(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_test_dir(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn test_only(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_test_only(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn log(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_log(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn errors(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_errors(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn events(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_events(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_dir(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_dir(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_file(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_file(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_link(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_link(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_exec(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_exec(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_directio(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_directio(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        disable_symlinks: libc::c_uint,
        test_dir: libc::c_uint,
        test_only: libc::c_uint,
        log: libc::c_uint,
        errors: libc::c_uint,
        events: libc::c_uint,
        is_dir: libc::c_uint,
        is_file: libc::c_uint,
        is_link: libc::c_uint,
        is_exec: libc::c_uint,
        is_directio: libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let disable_symlinks: u32 = unsafe { ::std::mem::transmute(disable_symlinks) };
            disable_symlinks as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let test_dir: u32 = unsafe { ::std::mem::transmute(test_dir) };
            test_dir as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let test_only: u32 = unsafe { ::std::mem::transmute(test_only) };
            test_only as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let log: u32 = unsafe { ::std::mem::transmute(log) };
            log as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let errors: u32 = unsafe { ::std::mem::transmute(errors) };
            errors as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let events: u32 = unsafe { ::std::mem::transmute(events) };
            events as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let is_dir: u32 = unsafe { ::std::mem::transmute(is_dir) };
            is_dir as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let is_file: u32 = unsafe { ::std::mem::transmute(is_file) };
            is_file as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let is_link: u32 = unsafe { ::std::mem::transmute(is_link) };
            is_link as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let is_exec: u32 = unsafe { ::std::mem::transmute(is_exec) };
            is_exec as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let is_directio: u32 = unsafe { ::std::mem::transmute(is_directio) };
            is_directio as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type ngx_cached_open_file_t = ngx_cached_open_file_s;
#[repr(C)]
pub struct ngx_cached_open_file_s {
    pub node: ngx_rbtree_node_t,
    pub queue: ngx_queue_t,
    pub name: *mut u_char,
    pub created: time_t,
    pub accessed: time_t,
    pub fd: ngx_fd_t,
    pub uniq: ngx_file_uniq_t,
    pub mtime: time_t,
    pub size: off_t,
    pub err: ngx_err_t,
    pub uses: u32,
    pub disable_symlinks_from: size_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u32>,
    pub event: *mut ngx_event_t,
}
impl ::std::fmt::Debug for ngx_cached_open_file_s {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "ngx_cached_open_file_s {{ node: {:?}, queue: {:?}, name: {:?}, fd: {:?}, err: {:?}, disable_symlinks : {:?}, count : {:?}, close : {:?}, use_event : {:?}, is_dir : {:?}, is_file : {:?}, is_link : {:?}, is_exec : {:?}, is_directio : {:?}, event: {:?} }}" , self . node , self . queue , self . name , self . fd , self . err , self . disable_symlinks ( ) , self . count ( ) , self . close ( ) , self . use_event ( ) , self . is_dir ( ) , self . is_file ( ) , self . is_link ( ) , self . is_exec ( ) , self . is_directio ( ) , self . event )
    }
}
impl ngx_cached_open_file_s {
    #[inline]
    pub fn disable_symlinks(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_disable_symlinks(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn count(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_count(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn close(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_close(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn use_event(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_event(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_dir(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_dir(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_file(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_file(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_link(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_link(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_exec(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_exec(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_directio(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_directio(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        disable_symlinks: libc::c_uint,
        count: libc::c_uint,
        close: libc::c_uint,
        use_event: libc::c_uint,
        is_dir: libc::c_uint,
        is_file: libc::c_uint,
        is_link: libc::c_uint,
        is_exec: libc::c_uint,
        is_directio: libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 8usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let disable_symlinks: u32 = unsafe { ::std::mem::transmute(disable_symlinks) };
            disable_symlinks as u64
        });
        __bindgen_bitfield_unit.set(2usize, 24u8, {
            let count: u32 = unsafe { ::std::mem::transmute(count) };
            count as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let close: u32 = unsafe { ::std::mem::transmute(close) };
            close as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let use_event: u32 = unsafe { ::std::mem::transmute(use_event) };
            use_event as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let is_dir: u32 = unsafe { ::std::mem::transmute(is_dir) };
            is_dir as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let is_file: u32 = unsafe { ::std::mem::transmute(is_file) };
            is_file as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let is_link: u32 = unsafe { ::std::mem::transmute(is_link) };
            is_link as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let is_exec: u32 = unsafe { ::std::mem::transmute(is_exec) };
            is_exec as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let is_directio: u32 = unsafe { ::std::mem::transmute(is_directio) };
            is_directio as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct ngx_open_file_cache_t {
    pub rbtree: ngx_rbtree_t,
    pub sentinel: ngx_rbtree_node_t,
    pub expire_queue: ngx_queue_t,
    pub current: ngx_uint_t,
    pub max: ngx_uint_t,
    pub inactive: time_t,
}
impl ::std::fmt::Debug for ngx_open_file_cache_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_open_file_cache_t {{ rbtree: {:?}, sentinel: {:?}, expire_queue: {:?} }}",
            self.rbtree, self.sentinel, self.expire_queue
        )
    }
}
#[repr(C)]
pub struct ngx_open_file_cache_cleanup_t {
    pub cache: *mut ngx_open_file_cache_t,
    pub file: *mut ngx_cached_open_file_t,
    pub min_uses: ngx_uint_t,
    pub log: *mut ngx_log_t,
}
impl ::std::fmt::Debug for ngx_open_file_cache_cleanup_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_open_file_cache_cleanup_t {{ cache: {:?}, file: {:?}, log: {:?} }}",
            self.cache, self.file, self.log
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_open_file_cache_event_t {
    pub data: *mut libc::c_void,
    pub read: *mut ngx_event_t,
    pub write: *mut ngx_event_t,
    pub fd: ngx_fd_t,
    pub file: *mut ngx_cached_open_file_t,
    pub cache: *mut ngx_open_file_cache_t,
}
extern "C" {
    pub fn ngx_open_file_cache_init(
        pool: *mut ngx_pool_t,
        max: ngx_uint_t,
        inactive: time_t,
    ) -> *mut ngx_open_file_cache_t;
}
extern "C" {
    pub fn ngx_open_cached_file(
        cache: *mut ngx_open_file_cache_t,
        name: *mut ngx_str_t,
        of: *mut ngx_open_file_info_t,
        pool: *mut ngx_pool_t,
    ) -> ngx_int_t;
}
pub type ngx_recv_pt = ::std::option::Option<
    unsafe extern "C" fn(c: *mut ngx_connection_t, buf: *mut u_char, size: size_t) -> ssize_t,
>;
pub type ngx_recv_chain_pt = ::std::option::Option<
    unsafe extern "C" fn(c: *mut ngx_connection_t, in_: *mut ngx_chain_t, limit: off_t) -> ssize_t,
>;
pub type ngx_send_pt = ::std::option::Option<
    unsafe extern "C" fn(c: *mut ngx_connection_t, buf: *mut u_char, size: size_t) -> ssize_t,
>;
pub type ngx_send_chain_pt = ::std::option::Option<
    unsafe extern "C" fn(
        c: *mut ngx_connection_t,
        in_: *mut ngx_chain_t,
        limit: off_t,
    ) -> *mut ngx_chain_t,
>;
#[repr(C)]
pub struct ngx_os_io_t {
    pub recv: ngx_recv_pt,
    pub recv_chain: ngx_recv_chain_pt,
    pub udp_recv: ngx_recv_pt,
    pub send: ngx_send_pt,
    pub udp_send: ngx_send_pt,
    pub udp_send_chain: ngx_send_chain_pt,
    pub send_chain: ngx_send_chain_pt,
    pub flags: ngx_uint_t,
}
impl ::std::fmt::Debug for ngx_os_io_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "ngx_os_io_t {{ recv: {:?}, recv_chain: {:?}, udp_recv: {:?}, send: {:?}, udp_send: {:?}, udp_send_chain: {:?}, send_chain: {:?} }}" , self . recv , self . recv_chain , self . udp_recv , self . send , self . udp_send , self . udp_send_chain , self . send_chain )
    }
}
extern "C" {
    pub fn ngx_os_init(log: *mut ngx_log_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_os_status(log: *mut ngx_log_t);
}
extern "C" {
    pub fn ngx_os_specific_init(log: *mut ngx_log_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_os_specific_status(log: *mut ngx_log_t);
}
extern "C" {
    pub fn ngx_daemon(log: *mut ngx_log_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_os_signal_process(
        cycle: *mut ngx_cycle_t,
        sig: *mut libc::c_char,
        pid: ngx_pid_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_unix_recv(c: *mut ngx_connection_t, buf: *mut u_char, size: size_t) -> ssize_t;
}
extern "C" {
    pub fn ngx_readv_chain(
        c: *mut ngx_connection_t,
        entry: *mut ngx_chain_t,
        limit: off_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn ngx_udp_unix_recv(c: *mut ngx_connection_t, buf: *mut u_char, size: size_t) -> ssize_t;
}
extern "C" {
    pub fn ngx_unix_send(c: *mut ngx_connection_t, buf: *mut u_char, size: size_t) -> ssize_t;
}
extern "C" {
    pub fn ngx_writev_chain(
        c: *mut ngx_connection_t,
        in_: *mut ngx_chain_t,
        limit: off_t,
    ) -> *mut ngx_chain_t;
}
extern "C" {
    pub fn ngx_udp_unix_send(c: *mut ngx_connection_t, buf: *mut u_char, size: size_t) -> ssize_t;
}
extern "C" {
    pub fn ngx_udp_unix_sendmsg_chain(
        c: *mut ngx_connection_t,
        in_: *mut ngx_chain_t,
        limit: off_t,
    ) -> *mut ngx_chain_t;
}
#[repr(C)]
pub struct ngx_iovec_t {
    pub iovs: *mut iovec,
    pub count: ngx_uint_t,
    pub size: size_t,
    pub nalloc: ngx_uint_t,
}
impl ::std::fmt::Debug for ngx_iovec_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "ngx_iovec_t {{ iovs: {:?} }}", self.iovs)
    }
}
extern "C" {
    pub fn ngx_output_chain_to_iovec(
        vec: *mut ngx_iovec_t,
        in_: *mut ngx_chain_t,
        limit: size_t,
        log: *mut ngx_log_t,
    ) -> *mut ngx_chain_t;
}
extern "C" {
    pub fn ngx_writev(c: *mut ngx_connection_t, vec: *mut ngx_iovec_t) -> ssize_t;
}
extern "C" {
    pub static mut ngx_os_io: ngx_os_io_t;
}
extern "C" {
    pub static mut ngx_ncpu: ngx_int_t;
}
extern "C" {
    pub static mut ngx_max_sockets: ngx_int_t;
}
extern "C" {
    pub static mut ngx_inherited_nonblocking: ngx_uint_t;
}
extern "C" {
    pub static mut ngx_tcp_nodelay_and_tcp_nopush: ngx_uint_t;
}
extern "C" {
    pub fn ngx_debug_init();
}
extern "C" {
    pub fn ngx_darwin_sendfile_chain(
        c: *mut ngx_connection_t,
        in_: *mut ngx_chain_t,
        limit: off_t,
    ) -> *mut ngx_chain_t;
}
extern "C" {
    pub static mut ngx_darwin_kern_osreldate: libc::c_int;
}
extern "C" {
    pub static mut ngx_darwin_hw_ncpu: libc::c_int;
}
extern "C" {
    pub static mut ngx_darwin_net_inet_tcp_sendspace: u_long;
}
extern "C" {
    pub static mut ngx_debug_malloc: ngx_uint_t;
}
pub type ngx_listening_t = ngx_listening_s;
#[repr(C)]
pub struct ngx_listening_s {
    pub fd: ngx_socket_t,
    pub sockaddr: *mut sockaddr,
    pub socklen: socklen_t,
    pub addr_text_max_len: size_t,
    pub addr_text: ngx_str_t,
    pub type_: libc::c_int,
    pub backlog: libc::c_int,
    pub rcvbuf: libc::c_int,
    pub sndbuf: libc::c_int,
    pub handler: ngx_connection_handler_pt,
    pub servers: *mut libc::c_void,
    pub log: ngx_log_t,
    pub logp: *mut ngx_log_t,
    pub pool_size: size_t,
    pub post_accept_buffer_size: size_t,
    pub post_accept_timeout: ngx_msec_t,
    pub previous: *mut ngx_listening_t,
    pub connection: *mut ngx_connection_t,
    pub rbtree: ngx_rbtree_t,
    pub sentinel: ngx_rbtree_node_t,
    pub worker: ngx_uint_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize], u8>,
    pub fastopen: libc::c_int,
}
impl ::std::fmt::Debug for ngx_listening_s {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "ngx_listening_s {{ fd: {:?}, sockaddr: {:?}, addr_text: {:?}, type: {:?}, backlog: {:?}, rcvbuf: {:?}, sndbuf: {:?}, handler: {:?}, servers: {:?}, log: {:?}, logp: {:?}, previous: {:?}, connection: {:?}, rbtree: {:?}, sentinel: {:?}, open : {:?}, remain : {:?}, ignore : {:?}, bound : {:?}, inherited : {:?}, nonblocking_accept : {:?}, listen : {:?}, nonblocking : {:?}, shared : {:?}, addr_ntop : {:?}, wildcard : {:?}, ipv6only : {:?}, reuseport : {:?}, add_reuseport : {:?}, keepalive : {:?}, deferred_accept : {:?}, delete_deferred : {:?}, add_deferred : {:?}, fastopen: {:?} }}" , self . fd , self . sockaddr , self . addr_text , self . type_ , self . backlog , self . rcvbuf , self . sndbuf , self . handler , self . servers , self . log , self . logp , self . previous , self . connection , self . rbtree , self . sentinel , self . open ( ) , self . remain ( ) , self . ignore ( ) , self . bound ( ) , self . inherited ( ) , self . nonblocking_accept ( ) , self . listen ( ) , self . nonblocking ( ) , self . shared ( ) , self . addr_ntop ( ) , self . wildcard ( ) , self . ipv6only ( ) , self . reuseport ( ) , self . add_reuseport ( ) , self . keepalive ( ) , self . deferred_accept ( ) , self . delete_deferred ( ) , self . add_deferred ( ) , self . fastopen )
    }
}
impl ngx_listening_s {
    #[inline]
    pub fn open(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_open(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn remain(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_remain(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ignore(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ignore(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bound(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bound(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inherited(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inherited(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nonblocking_accept(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_nonblocking_accept(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn listen(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_listen(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nonblocking(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_nonblocking(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shared(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_shared(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn addr_ntop(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_addr_ntop(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wildcard(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wildcard(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ipv6only(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ipv6only(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reuseport(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reuseport(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn add_reuseport(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_add_reuseport(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn keepalive(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_keepalive(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn deferred_accept(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_deferred_accept(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn delete_deferred(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_delete_deferred(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn add_deferred(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_add_deferred(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        open: libc::c_uint,
        remain: libc::c_uint,
        ignore: libc::c_uint,
        bound: libc::c_uint,
        inherited: libc::c_uint,
        nonblocking_accept: libc::c_uint,
        listen: libc::c_uint,
        nonblocking: libc::c_uint,
        shared: libc::c_uint,
        addr_ntop: libc::c_uint,
        wildcard: libc::c_uint,
        ipv6only: libc::c_uint,
        reuseport: libc::c_uint,
        add_reuseport: libc::c_uint,
        keepalive: libc::c_uint,
        deferred_accept: libc::c_uint,
        delete_deferred: libc::c_uint,
        add_deferred: libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 3usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let open: u32 = unsafe { ::std::mem::transmute(open) };
            open as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let remain: u32 = unsafe { ::std::mem::transmute(remain) };
            remain as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ignore: u32 = unsafe { ::std::mem::transmute(ignore) };
            ignore as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let bound: u32 = unsafe { ::std::mem::transmute(bound) };
            bound as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let inherited: u32 = unsafe { ::std::mem::transmute(inherited) };
            inherited as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let nonblocking_accept: u32 = unsafe { ::std::mem::transmute(nonblocking_accept) };
            nonblocking_accept as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let listen: u32 = unsafe { ::std::mem::transmute(listen) };
            listen as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let nonblocking: u32 = unsafe { ::std::mem::transmute(nonblocking) };
            nonblocking as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let shared: u32 = unsafe { ::std::mem::transmute(shared) };
            shared as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let addr_ntop: u32 = unsafe { ::std::mem::transmute(addr_ntop) };
            addr_ntop as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let wildcard: u32 = unsafe { ::std::mem::transmute(wildcard) };
            wildcard as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let ipv6only: u32 = unsafe { ::std::mem::transmute(ipv6only) };
            ipv6only as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let reuseport: u32 = unsafe { ::std::mem::transmute(reuseport) };
            reuseport as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let add_reuseport: u32 = unsafe { ::std::mem::transmute(add_reuseport) };
            add_reuseport as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let keepalive: u32 = unsafe { ::std::mem::transmute(keepalive) };
            keepalive as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let deferred_accept: u32 = unsafe { ::std::mem::transmute(deferred_accept) };
            deferred_accept as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let delete_deferred: u32 = unsafe { ::std::mem::transmute(delete_deferred) };
            delete_deferred as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let add_deferred: u32 = unsafe { ::std::mem::transmute(add_deferred) };
            add_deferred as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const NGX_ERROR_ALERT: ngx_connection_log_error_e = 0;
pub const NGX_ERROR_ERR: ngx_connection_log_error_e = 1;
pub const NGX_ERROR_INFO: ngx_connection_log_error_e = 2;
pub const NGX_ERROR_IGNORE_ECONNRESET: ngx_connection_log_error_e = 3;
pub const NGX_ERROR_IGNORE_EINVAL: ngx_connection_log_error_e = 4;
pub type ngx_connection_log_error_e = u32;
pub const NGX_TCP_NODELAY_UNSET: ngx_connection_tcp_nodelay_e = 0;
pub const NGX_TCP_NODELAY_SET: ngx_connection_tcp_nodelay_e = 1;
pub const NGX_TCP_NODELAY_DISABLED: ngx_connection_tcp_nodelay_e = 2;
pub type ngx_connection_tcp_nodelay_e = u32;
pub const NGX_TCP_NOPUSH_UNSET: ngx_connection_tcp_nopush_e = 0;
pub const NGX_TCP_NOPUSH_SET: ngx_connection_tcp_nopush_e = 1;
pub const NGX_TCP_NOPUSH_DISABLED: ngx_connection_tcp_nopush_e = 2;
pub type ngx_connection_tcp_nopush_e = u32;
#[repr(C)]
pub struct ngx_connection_s {
    pub data: *mut libc::c_void,
    pub read: *mut ngx_event_t,
    pub write: *mut ngx_event_t,
    pub fd: ngx_socket_t,
    pub recv: ngx_recv_pt,
    pub send: ngx_send_pt,
    pub recv_chain: ngx_recv_chain_pt,
    pub send_chain: ngx_send_chain_pt,
    pub listening: *mut ngx_listening_t,
    pub sent: off_t,
    pub log: *mut ngx_log_t,
    pub pool: *mut ngx_pool_t,
    pub type_: libc::c_int,
    pub sockaddr: *mut sockaddr,
    pub socklen: socklen_t,
    pub addr_text: ngx_str_t,
    pub proxy_protocol: *mut ngx_proxy_protocol_t,
    pub udp: *mut ngx_udp_connection_t,
    pub local_sockaddr: *mut sockaddr,
    pub local_socklen: socklen_t,
    pub buffer: *mut ngx_buf_t,
    pub queue: ngx_queue_t,
    pub number: ngx_atomic_uint_t,
    pub requests: ngx_uint_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
    pub __bindgen_padding_0: u32,
}
impl ::std::fmt::Debug for ngx_connection_s {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "ngx_connection_s {{ data: {:?}, read: {:?}, write: {:?}, fd: {:?}, recv: {:?}, send: {:?}, recv_chain: {:?}, send_chain: {:?}, listening: {:?}, log: {:?}, pool: {:?}, type: {:?}, sockaddr: {:?}, addr_text: {:?}, proxy_protocol: {:?}, udp: {:?}, local_sockaddr: {:?}, buffer: {:?}, queue: {:?}, buffered : {:?}, log_error : {:?}, timedout : {:?}, error : {:?}, destroyed : {:?}, idle : {:?}, reusable : {:?}, close : {:?}, shared : {:?}, sendfile : {:?}, sndlowat : {:?}, tcp_nodelay : {:?}, tcp_nopush : {:?}, need_last_buf : {:?} }}" , self . data , self . read , self . write , self . fd , self . recv , self . send , self . recv_chain , self . send_chain , self . listening , self . log , self . pool , self . type_ , self . sockaddr , self . addr_text , self . proxy_protocol , self . udp , self . local_sockaddr , self . buffer , self . queue , self . buffered ( ) , self . log_error ( ) , self . timedout ( ) , self . error ( ) , self . destroyed ( ) , self . idle ( ) , self . reusable ( ) , self . close ( ) , self . shared ( ) , self . sendfile ( ) , self . sndlowat ( ) , self . tcp_nodelay ( ) , self . tcp_nopush ( ) , self . need_last_buf ( ) )
    }
}
impl ngx_connection_s {
    #[inline]
    pub fn buffered(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_buffered(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn log_error(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_log_error(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn timedout(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_timedout(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn error(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_error(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn destroyed(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_destroyed(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn idle(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_idle(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reusable(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reusable(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn close(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_close(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shared(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_shared(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sendfile(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sendfile(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sndlowat(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sndlowat(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tcp_nodelay(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_tcp_nodelay(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn tcp_nopush(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_tcp_nopush(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn need_last_buf(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_need_last_buf(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        buffered: libc::c_uint,
        log_error: libc::c_uint,
        timedout: libc::c_uint,
        error: libc::c_uint,
        destroyed: libc::c_uint,
        idle: libc::c_uint,
        reusable: libc::c_uint,
        close: libc::c_uint,
        shared: libc::c_uint,
        sendfile: libc::c_uint,
        sndlowat: libc::c_uint,
        tcp_nodelay: libc::c_uint,
        tcp_nopush: libc::c_uint,
        need_last_buf: libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let buffered: u32 = unsafe { ::std::mem::transmute(buffered) };
            buffered as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let log_error: u32 = unsafe { ::std::mem::transmute(log_error) };
            log_error as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let timedout: u32 = unsafe { ::std::mem::transmute(timedout) };
            timedout as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let error: u32 = unsafe { ::std::mem::transmute(error) };
            error as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let destroyed: u32 = unsafe { ::std::mem::transmute(destroyed) };
            destroyed as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let idle: u32 = unsafe { ::std::mem::transmute(idle) };
            idle as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let reusable: u32 = unsafe { ::std::mem::transmute(reusable) };
            reusable as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let close: u32 = unsafe { ::std::mem::transmute(close) };
            close as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let shared: u32 = unsafe { ::std::mem::transmute(shared) };
            shared as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let sendfile: u32 = unsafe { ::std::mem::transmute(sendfile) };
            sendfile as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let sndlowat: u32 = unsafe { ::std::mem::transmute(sndlowat) };
            sndlowat as u64
        });
        __bindgen_bitfield_unit.set(20usize, 2u8, {
            let tcp_nodelay: u32 = unsafe { ::std::mem::transmute(tcp_nodelay) };
            tcp_nodelay as u64
        });
        __bindgen_bitfield_unit.set(22usize, 2u8, {
            let tcp_nopush: u32 = unsafe { ::std::mem::transmute(tcp_nopush) };
            tcp_nopush as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let need_last_buf: u32 = unsafe { ::std::mem::transmute(need_last_buf) };
            need_last_buf as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn ngx_create_listening(
        cf: *mut ngx_conf_t,
        sockaddr: *mut sockaddr,
        socklen: socklen_t,
    ) -> *mut ngx_listening_t;
}
extern "C" {
    pub fn ngx_clone_listening(cycle: *mut ngx_cycle_t, ls: *mut ngx_listening_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_set_inherited_sockets(cycle: *mut ngx_cycle_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_open_listening_sockets(cycle: *mut ngx_cycle_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_configure_listening_sockets(cycle: *mut ngx_cycle_t);
}
extern "C" {
    pub fn ngx_close_listening_sockets(cycle: *mut ngx_cycle_t);
}
extern "C" {
    pub fn ngx_close_connection(c: *mut ngx_connection_t);
}
extern "C" {
    pub fn ngx_close_idle_connections(cycle: *mut ngx_cycle_t);
}
extern "C" {
    pub fn ngx_connection_local_sockaddr(
        c: *mut ngx_connection_t,
        s: *mut ngx_str_t,
        port: ngx_uint_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_tcp_nodelay(c: *mut ngx_connection_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_connection_error(
        c: *mut ngx_connection_t,
        err: ngx_err_t,
        text: *mut libc::c_char,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_get_connection(s: ngx_socket_t, log: *mut ngx_log_t) -> *mut ngx_connection_t;
}
extern "C" {
    pub fn ngx_free_connection(c: *mut ngx_connection_t);
}
extern "C" {
    pub fn ngx_reusable_connection(c: *mut ngx_connection_t, reusable: ngx_uint_t);
}
#[repr(C)]
pub struct ngx_syslog_peer_t {
    pub facility: ngx_uint_t,
    pub severity: ngx_uint_t,
    pub tag: ngx_str_t,
    pub server: ngx_addr_t,
    pub conn: ngx_connection_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl ::std::fmt::Debug for ngx_syslog_peer_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "ngx_syslog_peer_t {{ tag: {:?}, server: {:?}, conn: {:?}, busy : {:?}, nohostname : {:?} }}" , self . tag , self . server , self . conn , self . busy ( ) , self . nohostname ( ) )
    }
}
impl ngx_syslog_peer_t {
    #[inline]
    pub fn busy(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_busy(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nohostname(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_nohostname(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        busy: libc::c_uint,
        nohostname: libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let busy: u32 = unsafe { ::std::mem::transmute(busy) };
            busy as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let nohostname: u32 = unsafe { ::std::mem::transmute(nohostname) };
            nohostname as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn ngx_syslog_process_conf(
        cf: *mut ngx_conf_t,
        peer: *mut ngx_syslog_peer_t,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn ngx_syslog_add_header(peer: *mut ngx_syslog_peer_t, buf: *mut u_char) -> *mut u_char;
}
extern "C" {
    pub fn ngx_syslog_writer(log: *mut ngx_log_t, level: ngx_uint_t, buf: *mut u_char, len: size_t);
}
extern "C" {
    pub fn ngx_syslog_send(peer: *mut ngx_syslog_peer_t, buf: *mut u_char, len: size_t) -> ssize_t;
}
#[repr(C)]
pub struct ngx_proxy_protocol_s {
    pub src_addr: ngx_str_t,
    pub dst_addr: ngx_str_t,
    pub src_port: in_port_t,
    pub dst_port: in_port_t,
}
impl ::std::fmt::Debug for ngx_proxy_protocol_s {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_proxy_protocol_s {{ src_addr: {:?}, dst_addr: {:?} }}",
            self.src_addr, self.dst_addr
        )
    }
}
extern "C" {
    pub fn ngx_proxy_protocol_read(
        c: *mut ngx_connection_t,
        buf: *mut u_char,
        last: *mut u_char,
    ) -> *mut u_char;
}
extern "C" {
    pub fn ngx_proxy_protocol_write(
        c: *mut ngx_connection_t,
        buf: *mut u_char,
        last: *mut u_char,
    ) -> *mut u_char;
}
extern "C" {
    pub fn ngx_cpuinfo();
}
pub type ngx_http_request_t = ngx_http_request_s;
pub type ngx_http_upstream_t = ngx_http_upstream_s;
pub type ngx_http_cache_t = ngx_http_cache_s;
pub type ngx_http_file_cache_t = ngx_http_file_cache_s;
pub type ngx_http_log_ctx_t = ngx_http_log_ctx_s;
pub type ngx_http_chunked_t = ngx_http_chunked_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_v2_stream_s {
    _unused: [u8; 0],
}
pub type ngx_http_v2_stream_t = ngx_http_v2_stream_s;
pub type ngx_http_header_handler_pt = ::std::option::Option<
    unsafe extern "C" fn(
        r: *mut ngx_http_request_t,
        h: *mut ngx_table_elt_t,
        offset: ngx_uint_t,
    ) -> ngx_int_t,
>;
pub type ngx_http_log_handler_pt = ::std::option::Option<
    unsafe extern "C" fn(
        r: *mut ngx_http_request_t,
        sr: *mut ngx_http_request_t,
        buf: *mut u_char,
        len: size_t,
    ) -> *mut u_char,
>;
pub type ngx_http_variable_value_t = ngx_variable_value_t;
pub type ngx_http_variable_t = ngx_http_variable_s;
pub type ngx_http_set_variable_pt = ::std::option::Option<
    unsafe extern "C" fn(
        r: *mut ngx_http_request_t,
        v: *mut ngx_http_variable_value_t,
        data: usize,
    ),
>;
pub type ngx_http_get_variable_pt = ::std::option::Option<
    unsafe extern "C" fn(
        r: *mut ngx_http_request_t,
        v: *mut ngx_http_variable_value_t,
        data: usize,
    ) -> ngx_int_t,
>;
#[repr(C)]
pub struct ngx_http_variable_s {
    pub name: ngx_str_t,
    pub set_handler: ngx_http_set_variable_pt,
    pub get_handler: ngx_http_get_variable_pt,
    pub data: usize,
    pub flags: ngx_uint_t,
    pub index: ngx_uint_t,
}
impl ::std::fmt::Debug for ngx_http_variable_s {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_http_variable_s {{ name: {:?}, set_handler: {:?}, get_handler: {:?} }}",
            self.name, self.set_handler, self.get_handler
        )
    }
}
extern "C" {
    pub fn ngx_http_add_variable(
        cf: *mut ngx_conf_t,
        name: *mut ngx_str_t,
        flags: ngx_uint_t,
    ) -> *mut ngx_http_variable_t;
}
extern "C" {
    pub fn ngx_http_get_variable_index(cf: *mut ngx_conf_t, name: *mut ngx_str_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_get_indexed_variable(
        r: *mut ngx_http_request_t,
        index: ngx_uint_t,
    ) -> *mut ngx_http_variable_value_t;
}
extern "C" {
    pub fn ngx_http_get_flushed_variable(
        r: *mut ngx_http_request_t,
        index: ngx_uint_t,
    ) -> *mut ngx_http_variable_value_t;
}
extern "C" {
    pub fn ngx_http_get_variable(
        r: *mut ngx_http_request_t,
        name: *mut ngx_str_t,
        key: ngx_uint_t,
    ) -> *mut ngx_http_variable_value_t;
}
extern "C" {
    pub fn ngx_http_variable_unknown_header(
        v: *mut ngx_http_variable_value_t,
        var: *mut ngx_str_t,
        part: *mut ngx_list_part_t,
        prefix: size_t,
    ) -> ngx_int_t;
}
#[repr(C)]
pub struct ngx_http_regex_variable_t {
    pub capture: ngx_uint_t,
    pub index: ngx_int_t,
}
impl ::std::fmt::Debug for ngx_http_regex_variable_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "ngx_http_regex_variable_t {{  }}")
    }
}
#[repr(C)]
pub struct ngx_http_regex_t {
    pub regex: *mut ngx_regex_t,
    pub ncaptures: ngx_uint_t,
    pub variables: *mut ngx_http_regex_variable_t,
    pub nvariables: ngx_uint_t,
    pub name: ngx_str_t,
}
impl ::std::fmt::Debug for ngx_http_regex_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_http_regex_t {{ regex: {:?}, variables: {:?}, name: {:?} }}",
            self.regex, self.variables, self.name
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_map_regex_t {
    pub regex: *mut ngx_http_regex_t,
    pub value: *mut libc::c_void,
}
extern "C" {
    pub fn ngx_http_regex_compile(
        cf: *mut ngx_conf_t,
        rc: *mut ngx_regex_compile_t,
    ) -> *mut ngx_http_regex_t;
}
extern "C" {
    pub fn ngx_http_regex_exec(
        r: *mut ngx_http_request_t,
        re: *mut ngx_http_regex_t,
        s: *mut ngx_str_t,
    ) -> ngx_int_t;
}
#[repr(C)]
pub struct ngx_http_map_t {
    pub hash: ngx_hash_combined_t,
    pub regex: *mut ngx_http_map_regex_t,
    pub nregex: ngx_uint_t,
}
impl ::std::fmt::Debug for ngx_http_map_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_http_map_t {{ hash: {:?}, regex: {:?} }}",
            self.hash, self.regex
        )
    }
}
extern "C" {
    pub fn ngx_http_map_find(
        r: *mut ngx_http_request_t,
        map: *mut ngx_http_map_t,
        match_: *mut ngx_str_t,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn ngx_http_variables_add_core_vars(cf: *mut ngx_conf_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_variables_init_vars(cf: *mut ngx_conf_t) -> ngx_int_t;
}
extern "C" {
    pub static mut ngx_http_variable_null_value: ngx_http_variable_value_t;
}
extern "C" {
    pub static mut ngx_http_variable_true_value: ngx_http_variable_value_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_conf_ctx_t {
    pub main_conf: *mut *mut libc::c_void,
    pub srv_conf: *mut *mut libc::c_void,
    pub loc_conf: *mut *mut libc::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_module_t {
    pub preconfiguration:
        ::std::option::Option<unsafe extern "C" fn(cf: *mut ngx_conf_t) -> ngx_int_t>,
    pub postconfiguration:
        ::std::option::Option<unsafe extern "C" fn(cf: *mut ngx_conf_t) -> ngx_int_t>,
    pub create_main_conf:
        ::std::option::Option<unsafe extern "C" fn(cf: *mut ngx_conf_t) -> *mut libc::c_void>,
    pub init_main_conf: ::std::option::Option<
        unsafe extern "C" fn(cf: *mut ngx_conf_t, conf: *mut libc::c_void) -> *mut libc::c_char,
    >,
    pub create_srv_conf:
        ::std::option::Option<unsafe extern "C" fn(cf: *mut ngx_conf_t) -> *mut libc::c_void>,
    pub merge_srv_conf: ::std::option::Option<
        unsafe extern "C" fn(
            cf: *mut ngx_conf_t,
            prev: *mut libc::c_void,
            conf: *mut libc::c_void,
        ) -> *mut libc::c_char,
    >,
    pub create_loc_conf:
        ::std::option::Option<unsafe extern "C" fn(cf: *mut ngx_conf_t) -> *mut libc::c_void>,
    pub merge_loc_conf: ::std::option::Option<
        unsafe extern "C" fn(
            cf: *mut ngx_conf_t,
            prev: *mut libc::c_void,
            conf: *mut libc::c_void,
        ) -> *mut libc::c_char,
    >,
}
pub const NGX_HTTP_INITING_REQUEST_STATE: ngx_http_state_e = 0;
pub const NGX_HTTP_READING_REQUEST_STATE: ngx_http_state_e = 1;
pub const NGX_HTTP_PROCESS_REQUEST_STATE: ngx_http_state_e = 2;
pub const NGX_HTTP_CONNECT_UPSTREAM_STATE: ngx_http_state_e = 3;
pub const NGX_HTTP_WRITING_UPSTREAM_STATE: ngx_http_state_e = 4;
pub const NGX_HTTP_READING_UPSTREAM_STATE: ngx_http_state_e = 5;
pub const NGX_HTTP_WRITING_REQUEST_STATE: ngx_http_state_e = 6;
pub const NGX_HTTP_LINGERING_CLOSE_STATE: ngx_http_state_e = 7;
pub const NGX_HTTP_KEEPALIVE_STATE: ngx_http_state_e = 8;
pub type ngx_http_state_e = u32;
#[repr(C)]
pub struct ngx_http_header_t {
    pub name: ngx_str_t,
    pub offset: ngx_uint_t,
    pub handler: ngx_http_header_handler_pt,
}
impl ::std::fmt::Debug for ngx_http_header_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_http_header_t {{ name: {:?}, handler: {:?} }}",
            self.name, self.handler
        )
    }
}
#[repr(C)]
pub struct ngx_http_header_out_t {
    pub name: ngx_str_t,
    pub offset: ngx_uint_t,
}
impl ::std::fmt::Debug for ngx_http_header_out_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "ngx_http_header_out_t {{ name: {:?} }}", self.name)
    }
}
#[repr(C)]
pub struct ngx_http_headers_in_t {
    pub headers: ngx_list_t,
    pub host: *mut ngx_table_elt_t,
    pub connection: *mut ngx_table_elt_t,
    pub if_modified_since: *mut ngx_table_elt_t,
    pub if_unmodified_since: *mut ngx_table_elt_t,
    pub if_match: *mut ngx_table_elt_t,
    pub if_none_match: *mut ngx_table_elt_t,
    pub user_agent: *mut ngx_table_elt_t,
    pub referer: *mut ngx_table_elt_t,
    pub content_length: *mut ngx_table_elt_t,
    pub content_range: *mut ngx_table_elt_t,
    pub content_type: *mut ngx_table_elt_t,
    pub range: *mut ngx_table_elt_t,
    pub if_range: *mut ngx_table_elt_t,
    pub transfer_encoding: *mut ngx_table_elt_t,
    pub te: *mut ngx_table_elt_t,
    pub expect: *mut ngx_table_elt_t,
    pub upgrade: *mut ngx_table_elt_t,
    pub accept_encoding: *mut ngx_table_elt_t,
    pub via: *mut ngx_table_elt_t,
    pub authorization: *mut ngx_table_elt_t,
    pub keep_alive: *mut ngx_table_elt_t,
    pub x_forwarded_for: ngx_array_t,
    pub user: ngx_str_t,
    pub passwd: ngx_str_t,
    pub cookies: ngx_array_t,
    pub server: ngx_str_t,
    pub content_length_n: off_t,
    pub keep_alive_n: time_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub __bindgen_padding_0: [u16; 3usize],
}
impl ::std::fmt::Debug for ngx_http_headers_in_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "ngx_http_headers_in_t {{ headers: {:?}, host: {:?}, connection: {:?}, if_modified_since: {:?}, if_unmodified_since: {:?}, if_match: {:?}, if_none_match: {:?}, user_agent: {:?}, referer: {:?}, content_length: {:?}, content_range: {:?}, content_type: {:?}, range: {:?}, if_range: {:?}, transfer_encoding: {:?}, te: {:?}, expect: {:?}, upgrade: {:?}, accept_encoding: {:?}, via: {:?}, authorization: {:?}, keep_alive: {:?}, x_forwarded_for: {:?}, user: {:?}, passwd: {:?}, cookies: {:?}, server: {:?}, connection_type : {:?}, chunked : {:?}, msie : {:?}, msie6 : {:?}, opera : {:?}, gecko : {:?}, chrome : {:?}, safari : {:?}, konqueror : {:?} }}" , self . headers , self . host , self . connection , self . if_modified_since , self . if_unmodified_since , self . if_match , self . if_none_match , self . user_agent , self . referer , self . content_length , self . content_range , self . content_type , self . range , self . if_range , self . transfer_encoding , self . te , self . expect , self . upgrade , self . accept_encoding , self . via , self . authorization , self . keep_alive , self . x_forwarded_for , self . user , self . passwd , self . cookies , self . server , self . connection_type ( ) , self . chunked ( ) , self . msie ( ) , self . msie6 ( ) , self . opera ( ) , self . gecko ( ) , self . chrome ( ) , self . safari ( ) , self . konqueror ( ) )
    }
}
impl ngx_http_headers_in_t {
    #[inline]
    pub fn connection_type(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_connection_type(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn chunked(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_chunked(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn msie(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_msie(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn msie6(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_msie6(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn opera(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_opera(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn gecko(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_gecko(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn chrome(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_chrome(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn safari(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_safari(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn konqueror(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_konqueror(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        connection_type: libc::c_uint,
        chunked: libc::c_uint,
        msie: libc::c_uint,
        msie6: libc::c_uint,
        opera: libc::c_uint,
        gecko: libc::c_uint,
        chrome: libc::c_uint,
        safari: libc::c_uint,
        konqueror: libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let connection_type: u32 = unsafe { ::std::mem::transmute(connection_type) };
            connection_type as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let chunked: u32 = unsafe { ::std::mem::transmute(chunked) };
            chunked as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let msie: u32 = unsafe { ::std::mem::transmute(msie) };
            msie as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let msie6: u32 = unsafe { ::std::mem::transmute(msie6) };
            msie6 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let opera: u32 = unsafe { ::std::mem::transmute(opera) };
            opera as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let gecko: u32 = unsafe { ::std::mem::transmute(gecko) };
            gecko as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let chrome: u32 = unsafe { ::std::mem::transmute(chrome) };
            chrome as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let safari: u32 = unsafe { ::std::mem::transmute(safari) };
            safari as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let konqueror: u32 = unsafe { ::std::mem::transmute(konqueror) };
            konqueror as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct ngx_http_headers_out_t {
    pub headers: ngx_list_t,
    pub trailers: ngx_list_t,
    pub status: ngx_uint_t,
    pub status_line: ngx_str_t,
    pub server: *mut ngx_table_elt_t,
    pub date: *mut ngx_table_elt_t,
    pub content_length: *mut ngx_table_elt_t,
    pub content_encoding: *mut ngx_table_elt_t,
    pub location: *mut ngx_table_elt_t,
    pub refresh: *mut ngx_table_elt_t,
    pub last_modified: *mut ngx_table_elt_t,
    pub content_range: *mut ngx_table_elt_t,
    pub accept_ranges: *mut ngx_table_elt_t,
    pub www_authenticate: *mut ngx_table_elt_t,
    pub expires: *mut ngx_table_elt_t,
    pub etag: *mut ngx_table_elt_t,
    pub override_charset: *mut ngx_str_t,
    pub content_type_len: size_t,
    pub content_type: ngx_str_t,
    pub charset: ngx_str_t,
    pub content_type_lowcase: *mut u_char,
    pub content_type_hash: ngx_uint_t,
    pub cache_control: ngx_array_t,
    pub link: ngx_array_t,
    pub content_length_n: off_t,
    pub content_offset: off_t,
    pub date_time: time_t,
    pub last_modified_time: time_t,
}
impl ::std::fmt::Debug for ngx_http_headers_out_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "ngx_http_headers_out_t {{ headers: {:?}, trailers: {:?}, status_line: {:?}, server: {:?}, date: {:?}, content_length: {:?}, content_encoding: {:?}, location: {:?}, refresh: {:?}, last_modified: {:?}, content_range: {:?}, accept_ranges: {:?}, www_authenticate: {:?}, expires: {:?}, etag: {:?}, override_charset: {:?}, content_type: {:?}, charset: {:?}, content_type_lowcase: {:?}, cache_control: {:?}, link: {:?} }}" , self . headers , self . trailers , self . status_line , self . server , self . date , self . content_length , self . content_encoding , self . location , self . refresh , self . last_modified , self . content_range , self . accept_ranges , self . www_authenticate , self . expires , self . etag , self . override_charset , self . content_type , self . charset , self . content_type_lowcase , self . cache_control , self . link )
    }
}
pub type ngx_http_client_body_handler_pt =
    ::std::option::Option<unsafe extern "C" fn(r: *mut ngx_http_request_t)>;
#[repr(C)]
pub struct ngx_http_request_body_t {
    pub temp_file: *mut ngx_temp_file_t,
    pub bufs: *mut ngx_chain_t,
    pub buf: *mut ngx_buf_t,
    pub rest: off_t,
    pub received: off_t,
    pub free: *mut ngx_chain_t,
    pub busy: *mut ngx_chain_t,
    pub chunked: *mut ngx_http_chunked_t,
    pub post_handler: ngx_http_client_body_handler_pt,
}
impl ::std::fmt::Debug for ngx_http_request_body_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "ngx_http_request_body_t {{ temp_file: {:?}, bufs: {:?}, buf: {:?}, free: {:?}, busy: {:?}, chunked: {:?}, post_handler: {:?} }}" , self . temp_file , self . bufs , self . buf , self . free , self . busy , self . chunked , self . post_handler )
    }
}
pub type ngx_http_addr_conf_t = ngx_http_addr_conf_s;
#[repr(C)]
pub struct ngx_http_connection_t {
    pub addr_conf: *mut ngx_http_addr_conf_t,
    pub conf_ctx: *mut ngx_http_conf_ctx_t,
    pub busy: *mut ngx_chain_t,
    pub nbusy: ngx_int_t,
    pub free: *mut ngx_chain_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl ::std::fmt::Debug for ngx_http_connection_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "ngx_http_connection_t {{ addr_conf: {:?}, conf_ctx: {:?}, busy: {:?}, free: {:?}, ssl : {:?}, proxy_protocol : {:?} }}" , self . addr_conf , self . conf_ctx , self . busy , self . free , self . ssl ( ) , self . proxy_protocol ( ) )
    }
}
impl ngx_http_connection_t {
    #[inline]
    pub fn ssl(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ssl(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn proxy_protocol(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_proxy_protocol(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ssl: libc::c_uint,
        proxy_protocol: libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ssl: u32 = unsafe { ::std::mem::transmute(ssl) };
            ssl as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let proxy_protocol: u32 = unsafe { ::std::mem::transmute(proxy_protocol) };
            proxy_protocol as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type ngx_http_cleanup_pt = ::std::option::Option<unsafe extern "C" fn(data: *mut libc::c_void)>;
pub type ngx_http_cleanup_t = ngx_http_cleanup_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_cleanup_s {
    pub handler: ngx_http_cleanup_pt,
    pub data: *mut libc::c_void,
    pub next: *mut ngx_http_cleanup_t,
}
pub type ngx_http_post_subrequest_pt = ::std::option::Option<
    unsafe extern "C" fn(
        r: *mut ngx_http_request_t,
        data: *mut libc::c_void,
        rc: ngx_int_t,
    ) -> ngx_int_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_post_subrequest_t {
    pub handler: ngx_http_post_subrequest_pt,
    pub data: *mut libc::c_void,
}
pub type ngx_http_postponed_request_t = ngx_http_postponed_request_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_postponed_request_s {
    pub request: *mut ngx_http_request_t,
    pub out: *mut ngx_chain_t,
    pub next: *mut ngx_http_postponed_request_t,
}
pub type ngx_http_posted_request_t = ngx_http_posted_request_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_posted_request_s {
    pub request: *mut ngx_http_request_t,
    pub next: *mut ngx_http_posted_request_t,
}
pub type ngx_http_handler_pt =
    ::std::option::Option<unsafe extern "C" fn(r: *mut ngx_http_request_t) -> ngx_int_t>;
pub type ngx_http_event_handler_pt =
    ::std::option::Option<unsafe extern "C" fn(r: *mut ngx_http_request_t)>;
#[repr(C)]
pub struct ngx_http_request_s {
    pub signature: u32,
    pub connection: *mut ngx_connection_t,
    pub ctx: *mut *mut libc::c_void,
    pub main_conf: *mut *mut libc::c_void,
    pub srv_conf: *mut *mut libc::c_void,
    pub loc_conf: *mut *mut libc::c_void,
    pub read_event_handler: ngx_http_event_handler_pt,
    pub write_event_handler: ngx_http_event_handler_pt,
    pub cache: *mut ngx_http_cache_t,
    pub upstream: *mut ngx_http_upstream_t,
    pub upstream_states: *mut ngx_array_t,
    pub pool: *mut ngx_pool_t,
    pub header_in: *mut ngx_buf_t,
    pub headers_in: ngx_http_headers_in_t,
    pub headers_out: ngx_http_headers_out_t,
    pub request_body: *mut ngx_http_request_body_t,
    pub lingering_time: time_t,
    pub start_sec: time_t,
    pub start_msec: ngx_msec_t,
    pub method: ngx_uint_t,
    pub http_version: ngx_uint_t,
    pub request_line: ngx_str_t,
    pub uri: ngx_str_t,
    pub args: ngx_str_t,
    pub exten: ngx_str_t,
    pub unparsed_uri: ngx_str_t,
    pub method_name: ngx_str_t,
    pub http_protocol: ngx_str_t,
    pub schema: ngx_str_t,
    pub out: *mut ngx_chain_t,
    pub main: *mut ngx_http_request_t,
    pub parent: *mut ngx_http_request_t,
    pub postponed: *mut ngx_http_postponed_request_t,
    pub post_subrequest: *mut ngx_http_post_subrequest_t,
    pub posted_requests: *mut ngx_http_posted_request_t,
    pub phase_handler: ngx_int_t,
    pub content_handler: ngx_http_handler_pt,
    pub access_code: ngx_uint_t,
    pub variables: *mut ngx_http_variable_value_t,
    pub ncaptures: ngx_uint_t,
    pub captures: *mut libc::c_int,
    pub captures_data: *mut u_char,
    pub limit_rate: size_t,
    pub limit_rate_after: size_t,
    pub header_size: size_t,
    pub request_length: off_t,
    pub err_status: ngx_uint_t,
    pub http_connection: *mut ngx_http_connection_t,
    pub stream: *mut ngx_http_v2_stream_t,
    pub log_handler: ngx_http_log_handler_pt,
    pub cleanup: *mut ngx_http_cleanup_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 16usize], u16>,
    pub state: ngx_uint_t,
    pub header_hash: ngx_uint_t,
    pub lowcase_index: ngx_uint_t,
    pub lowcase_header: [u_char; 32usize],
    pub header_name_start: *mut u_char,
    pub header_name_end: *mut u_char,
    pub header_start: *mut u_char,
    pub header_end: *mut u_char,
    pub uri_start: *mut u_char,
    pub uri_end: *mut u_char,
    pub uri_ext: *mut u_char,
    pub args_start: *mut u_char,
    pub request_start: *mut u_char,
    pub request_end: *mut u_char,
    pub method_end: *mut u_char,
    pub schema_start: *mut u_char,
    pub schema_end: *mut u_char,
    pub host_start: *mut u_char,
    pub host_end: *mut u_char,
    pub port_start: *mut u_char,
    pub port_end: *mut u_char,
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub __bindgen_padding_0: u32,
}
impl ::std::fmt::Debug for ngx_http_request_s {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "ngx_http_request_s {{ connection: {:?}, ctx: {:?}, main_conf: {:?}, srv_conf: {:?}, loc_conf: {:?}, read_event_handler: {:?}, write_event_handler: {:?}, cache: {:?}, upstream: {:?}, upstream_states: {:?}, pool: {:?}, header_in: {:?}, headers_in: {:?}, headers_out: {:?}, request_body: {:?}, request_line: {:?}, uri: {:?}, args: {:?}, exten: {:?}, unparsed_uri: {:?}, method_name: {:?}, http_protocol: {:?}, schema: {:?}, out: {:?}, main: {:?}, parent: {:?}, postponed: {:?}, post_subrequest: {:?}, posted_requests: {:?}, content_handler: {:?}, variables: {:?}, captures: {:?}, captures_data: {:?}, http_connection: {:?}, stream: {:?}, log_handler: {:?}, cleanup: {:?}, count : {:?}, subrequests : {:?}, blocked : {:?}, aio : {:?}, http_state : {:?}, complex_uri : {:?}, quoted_uri : {:?}, plus_in_uri : {:?}, space_in_uri : {:?}, invalid_header : {:?}, add_uri_to_alias : {:?}, valid_location : {:?}, valid_unparsed_uri : {:?}, uri_changed : {:?}, uri_changes : {:?}, request_body_in_single_buf : {:?}, request_body_in_file_only : {:?}, request_body_in_persistent_file : {:?}, request_body_in_clean_file : {:?}, request_body_file_group_access : {:?}, request_body_file_log_level : {:?}, request_body_no_buffering : {:?}, subrequest_in_memory : {:?}, waited : {:?}, cached : {:?}, gzip_tested : {:?}, gzip_ok : {:?}, gzip_vary : {:?}, realloc_captures : {:?}, proxy : {:?}, bypass_cache : {:?}, no_cache : {:?}, limit_conn_status : {:?}, limit_req_status : {:?}, limit_rate_set : {:?}, limit_rate_after_set : {:?}, pipeline : {:?}, chunked : {:?}, header_only : {:?}, expect_trailers : {:?}, keepalive : {:?}, lingering_close : {:?}, discard_body : {:?}, reading_body : {:?}, internal : {:?}, error_page : {:?}, filter_finalize : {:?}, post_action : {:?}, request_complete : {:?}, request_output : {:?}, header_sent : {:?}, expect_tested : {:?}, root_tested : {:?}, done : {:?}, logged : {:?}, buffered : {:?}, main_filter_need_in_memory : {:?}, filter_need_in_memory : {:?}, filter_need_temporary : {:?}, preserve_body : {:?}, allow_ranges : {:?}, subrequest_ranges : {:?}, single_range : {:?}, disable_not_modified : {:?}, stat_reading : {:?}, stat_writing : {:?}, stat_processing : {:?}, background : {:?}, health_check : {:?}, lowcase_header: [{}], header_name_start: {:?}, header_name_end: {:?}, header_start: {:?}, header_end: {:?}, uri_start: {:?}, uri_end: {:?}, uri_ext: {:?}, args_start: {:?}, request_start: {:?}, request_end: {:?}, method_end: {:?}, schema_start: {:?}, schema_end: {:?}, host_start: {:?}, host_end: {:?}, port_start: {:?}, port_end: {:?}, http_minor : {:?}, http_major : {:?} }}" , self . connection , self . ctx , self . main_conf , self . srv_conf , self . loc_conf , self . read_event_handler , self . write_event_handler , self . cache , self . upstream , self . upstream_states , self . pool , self . header_in , self . headers_in , self . headers_out , self . request_body , self . request_line , self . uri , self . args , self . exten , self . unparsed_uri , self . method_name , self . http_protocol , self . schema , self . out , self . main , self . parent , self . postponed , self . post_subrequest , self . posted_requests , self . content_handler , self . variables , self . captures , self . captures_data , self . http_connection , self . stream , self . log_handler , self . cleanup , self . count ( ) , self . subrequests ( ) , self . blocked ( ) , self . aio ( ) , self . http_state ( ) , self . complex_uri ( ) , self . quoted_uri ( ) , self . plus_in_uri ( ) , self . space_in_uri ( ) , self . invalid_header ( ) , self . add_uri_to_alias ( ) , self . valid_location ( ) , self . valid_unparsed_uri ( ) , self . uri_changed ( ) , self . uri_changes ( ) , self . request_body_in_single_buf ( ) , self . request_body_in_file_only ( ) , self . request_body_in_persistent_file ( ) , self . request_body_in_clean_file ( ) , self . request_body_file_group_access ( ) , self . request_body_file_log_level ( ) , self . request_body_no_buffering ( ) , self . subrequest_in_memory ( ) , self . waited ( ) , self . cached ( ) , self . gzip_tested ( ) , self . gzip_ok ( ) , self . gzip_vary ( ) , self . realloc_captures ( ) , self . proxy ( ) , self . bypass_cache ( ) , self . no_cache ( ) , self . limit_conn_status ( ) , self . limit_req_status ( ) , self . limit_rate_set ( ) , self . limit_rate_after_set ( ) , self . pipeline ( ) , self . chunked ( ) , self . header_only ( ) , self . expect_trailers ( ) , self . keepalive ( ) , self . lingering_close ( ) , self . discard_body ( ) , self . reading_body ( ) , self . internal ( ) , self . error_page ( ) , self . filter_finalize ( ) , self . post_action ( ) , self . request_complete ( ) , self . request_output ( ) , self . header_sent ( ) , self . expect_tested ( ) , self . root_tested ( ) , self . done ( ) , self . logged ( ) , self . buffered ( ) , self . main_filter_need_in_memory ( ) , self . filter_need_in_memory ( ) , self . filter_need_temporary ( ) , self . preserve_body ( ) , self . allow_ranges ( ) , self . subrequest_ranges ( ) , self . single_range ( ) , self . disable_not_modified ( ) , self . stat_reading ( ) , self . stat_writing ( ) , self . stat_processing ( ) , self . background ( ) , self . health_check ( ) , self . lowcase_header . iter ( ) . enumerate ( ) . map ( | ( i , v ) | format ! ( "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: < String > ( ) , self . header_name_start , self . header_name_end , self . header_start , self . header_end , self . uri_start , self . uri_end , self . uri_ext , self . args_start , self . request_start , self . request_end , self . method_end , self . schema_start , self . schema_end , self . host_start , self . host_end , self . port_start , self . port_end , self . http_minor ( ) , self . http_major ( ) )
    }
}
impl ngx_http_request_s {
    #[inline]
    pub fn count(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_count(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn subrequests(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_subrequests(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn blocked(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_blocked(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn aio(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_aio(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn http_state(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(33usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_http_state(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(33usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn complex_uri(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(37usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_complex_uri(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(37usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn quoted_uri(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(38usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_quoted_uri(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(38usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn plus_in_uri(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(39usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_plus_in_uri(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(39usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn space_in_uri(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_space_in_uri(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn invalid_header(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(41usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_invalid_header(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(41usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn add_uri_to_alias(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(42usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_add_uri_to_alias(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(42usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn valid_location(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(43usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_valid_location(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(43usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn valid_unparsed_uri(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(44usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_valid_unparsed_uri(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(44usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn uri_changed(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(45usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_uri_changed(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(45usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn uri_changes(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(46usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_uri_changes(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(46usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn request_body_in_single_buf(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(50usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_request_body_in_single_buf(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(50usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn request_body_in_file_only(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(51usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_request_body_in_file_only(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(51usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn request_body_in_persistent_file(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(52usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_request_body_in_persistent_file(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(52usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn request_body_in_clean_file(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(53usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_request_body_in_clean_file(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(53usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn request_body_file_group_access(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(54usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_request_body_file_group_access(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(54usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn request_body_file_log_level(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(55usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_request_body_file_log_level(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(55usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn request_body_no_buffering(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(58usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_request_body_no_buffering(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(58usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn subrequest_in_memory(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(59usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_subrequest_in_memory(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(59usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn waited(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(60usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_waited(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(60usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cached(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(61usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cached(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(61usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn gzip_tested(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(62usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_gzip_tested(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(62usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn gzip_ok(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(63usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_gzip_ok(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(63usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn gzip_vary(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(64usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_gzip_vary(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(64usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn realloc_captures(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(65usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_realloc_captures(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(65usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn proxy(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(66usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_proxy(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(66usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bypass_cache(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(67usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bypass_cache(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(67usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_cache(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(68usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_cache(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(68usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn limit_conn_status(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(69usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_limit_conn_status(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(69usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn limit_req_status(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(71usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_limit_req_status(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(71usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn limit_rate_set(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(74usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_limit_rate_set(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(74usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn limit_rate_after_set(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(75usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_limit_rate_after_set(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(75usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pipeline(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(76usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pipeline(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(76usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn chunked(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(77usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_chunked(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(77usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn header_only(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(78usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_header_only(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(78usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn expect_trailers(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(79usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_expect_trailers(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(79usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn keepalive(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(80usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_keepalive(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(80usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lingering_close(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(81usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lingering_close(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(81usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn discard_body(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(82usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_discard_body(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(82usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reading_body(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(83usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reading_body(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(83usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn internal(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(84usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_internal(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(84usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn error_page(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(85usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_error_page(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(85usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn filter_finalize(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(86usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_filter_finalize(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(86usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn post_action(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(87usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_post_action(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(87usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn request_complete(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(88usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_request_complete(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(88usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn request_output(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(89usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_request_output(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(89usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn header_sent(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(90usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_header_sent(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(90usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn expect_tested(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(91usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_expect_tested(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(91usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn root_tested(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(92usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_root_tested(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(92usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn done(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(93usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_done(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(93usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn logged(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(94usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_logged(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(94usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn buffered(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(96usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_buffered(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(96usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn main_filter_need_in_memory(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(100usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_main_filter_need_in_memory(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(100usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn filter_need_in_memory(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(101usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_filter_need_in_memory(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(101usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn filter_need_temporary(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(102usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_filter_need_temporary(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(102usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn preserve_body(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(103usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_preserve_body(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(103usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn allow_ranges(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(104usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_allow_ranges(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(104usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn subrequest_ranges(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(105usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_subrequest_ranges(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(105usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn single_range(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(106usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_single_range(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(106usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disable_not_modified(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(107usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disable_not_modified(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(107usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn stat_reading(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(108usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_stat_reading(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(108usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn stat_writing(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(109usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_stat_writing(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(109usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn stat_processing(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(110usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_stat_processing(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(110usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn background(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(111usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_background(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(111usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn health_check(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(112usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_health_check(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(112usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        count: libc::c_uint,
        subrequests: libc::c_uint,
        blocked: libc::c_uint,
        aio: libc::c_uint,
        http_state: libc::c_uint,
        complex_uri: libc::c_uint,
        quoted_uri: libc::c_uint,
        plus_in_uri: libc::c_uint,
        space_in_uri: libc::c_uint,
        invalid_header: libc::c_uint,
        add_uri_to_alias: libc::c_uint,
        valid_location: libc::c_uint,
        valid_unparsed_uri: libc::c_uint,
        uri_changed: libc::c_uint,
        uri_changes: libc::c_uint,
        request_body_in_single_buf: libc::c_uint,
        request_body_in_file_only: libc::c_uint,
        request_body_in_persistent_file: libc::c_uint,
        request_body_in_clean_file: libc::c_uint,
        request_body_file_group_access: libc::c_uint,
        request_body_file_log_level: libc::c_uint,
        request_body_no_buffering: libc::c_uint,
        subrequest_in_memory: libc::c_uint,
        waited: libc::c_uint,
        cached: libc::c_uint,
        gzip_tested: libc::c_uint,
        gzip_ok: libc::c_uint,
        gzip_vary: libc::c_uint,
        realloc_captures: libc::c_uint,
        proxy: libc::c_uint,
        bypass_cache: libc::c_uint,
        no_cache: libc::c_uint,
        limit_conn_status: libc::c_uint,
        limit_req_status: libc::c_uint,
        limit_rate_set: libc::c_uint,
        limit_rate_after_set: libc::c_uint,
        pipeline: libc::c_uint,
        chunked: libc::c_uint,
        header_only: libc::c_uint,
        expect_trailers: libc::c_uint,
        keepalive: libc::c_uint,
        lingering_close: libc::c_uint,
        discard_body: libc::c_uint,
        reading_body: libc::c_uint,
        internal: libc::c_uint,
        error_page: libc::c_uint,
        filter_finalize: libc::c_uint,
        post_action: libc::c_uint,
        request_complete: libc::c_uint,
        request_output: libc::c_uint,
        header_sent: libc::c_uint,
        expect_tested: libc::c_uint,
        root_tested: libc::c_uint,
        done: libc::c_uint,
        logged: libc::c_uint,
        buffered: libc::c_uint,
        main_filter_need_in_memory: libc::c_uint,
        filter_need_in_memory: libc::c_uint,
        filter_need_temporary: libc::c_uint,
        preserve_body: libc::c_uint,
        allow_ranges: libc::c_uint,
        subrequest_ranges: libc::c_uint,
        single_range: libc::c_uint,
        disable_not_modified: libc::c_uint,
        stat_reading: libc::c_uint,
        stat_writing: libc::c_uint,
        stat_processing: libc::c_uint,
        background: libc::c_uint,
        health_check: libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 16usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let count: u32 = unsafe { ::std::mem::transmute(count) };
            count as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let subrequests: u32 = unsafe { ::std::mem::transmute(subrequests) };
            subrequests as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let blocked: u32 = unsafe { ::std::mem::transmute(blocked) };
            blocked as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let aio: u32 = unsafe { ::std::mem::transmute(aio) };
            aio as u64
        });
        __bindgen_bitfield_unit.set(33usize, 4u8, {
            let http_state: u32 = unsafe { ::std::mem::transmute(http_state) };
            http_state as u64
        });
        __bindgen_bitfield_unit.set(37usize, 1u8, {
            let complex_uri: u32 = unsafe { ::std::mem::transmute(complex_uri) };
            complex_uri as u64
        });
        __bindgen_bitfield_unit.set(38usize, 1u8, {
            let quoted_uri: u32 = unsafe { ::std::mem::transmute(quoted_uri) };
            quoted_uri as u64
        });
        __bindgen_bitfield_unit.set(39usize, 1u8, {
            let plus_in_uri: u32 = unsafe { ::std::mem::transmute(plus_in_uri) };
            plus_in_uri as u64
        });
        __bindgen_bitfield_unit.set(40usize, 1u8, {
            let space_in_uri: u32 = unsafe { ::std::mem::transmute(space_in_uri) };
            space_in_uri as u64
        });
        __bindgen_bitfield_unit.set(41usize, 1u8, {
            let invalid_header: u32 = unsafe { ::std::mem::transmute(invalid_header) };
            invalid_header as u64
        });
        __bindgen_bitfield_unit.set(42usize, 1u8, {
            let add_uri_to_alias: u32 = unsafe { ::std::mem::transmute(add_uri_to_alias) };
            add_uri_to_alias as u64
        });
        __bindgen_bitfield_unit.set(43usize, 1u8, {
            let valid_location: u32 = unsafe { ::std::mem::transmute(valid_location) };
            valid_location as u64
        });
        __bindgen_bitfield_unit.set(44usize, 1u8, {
            let valid_unparsed_uri: u32 = unsafe { ::std::mem::transmute(valid_unparsed_uri) };
            valid_unparsed_uri as u64
        });
        __bindgen_bitfield_unit.set(45usize, 1u8, {
            let uri_changed: u32 = unsafe { ::std::mem::transmute(uri_changed) };
            uri_changed as u64
        });
        __bindgen_bitfield_unit.set(46usize, 4u8, {
            let uri_changes: u32 = unsafe { ::std::mem::transmute(uri_changes) };
            uri_changes as u64
        });
        __bindgen_bitfield_unit.set(50usize, 1u8, {
            let request_body_in_single_buf: u32 =
                unsafe { ::std::mem::transmute(request_body_in_single_buf) };
            request_body_in_single_buf as u64
        });
        __bindgen_bitfield_unit.set(51usize, 1u8, {
            let request_body_in_file_only: u32 =
                unsafe { ::std::mem::transmute(request_body_in_file_only) };
            request_body_in_file_only as u64
        });
        __bindgen_bitfield_unit.set(52usize, 1u8, {
            let request_body_in_persistent_file: u32 =
                unsafe { ::std::mem::transmute(request_body_in_persistent_file) };
            request_body_in_persistent_file as u64
        });
        __bindgen_bitfield_unit.set(53usize, 1u8, {
            let request_body_in_clean_file: u32 =
                unsafe { ::std::mem::transmute(request_body_in_clean_file) };
            request_body_in_clean_file as u64
        });
        __bindgen_bitfield_unit.set(54usize, 1u8, {
            let request_body_file_group_access: u32 =
                unsafe { ::std::mem::transmute(request_body_file_group_access) };
            request_body_file_group_access as u64
        });
        __bindgen_bitfield_unit.set(55usize, 3u8, {
            let request_body_file_log_level: u32 =
                unsafe { ::std::mem::transmute(request_body_file_log_level) };
            request_body_file_log_level as u64
        });
        __bindgen_bitfield_unit.set(58usize, 1u8, {
            let request_body_no_buffering: u32 =
                unsafe { ::std::mem::transmute(request_body_no_buffering) };
            request_body_no_buffering as u64
        });
        __bindgen_bitfield_unit.set(59usize, 1u8, {
            let subrequest_in_memory: u32 = unsafe { ::std::mem::transmute(subrequest_in_memory) };
            subrequest_in_memory as u64
        });
        __bindgen_bitfield_unit.set(60usize, 1u8, {
            let waited: u32 = unsafe { ::std::mem::transmute(waited) };
            waited as u64
        });
        __bindgen_bitfield_unit.set(61usize, 1u8, {
            let cached: u32 = unsafe { ::std::mem::transmute(cached) };
            cached as u64
        });
        __bindgen_bitfield_unit.set(62usize, 1u8, {
            let gzip_tested: u32 = unsafe { ::std::mem::transmute(gzip_tested) };
            gzip_tested as u64
        });
        __bindgen_bitfield_unit.set(63usize, 1u8, {
            let gzip_ok: u32 = unsafe { ::std::mem::transmute(gzip_ok) };
            gzip_ok as u64
        });
        __bindgen_bitfield_unit.set(64usize, 1u8, {
            let gzip_vary: u32 = unsafe { ::std::mem::transmute(gzip_vary) };
            gzip_vary as u64
        });
        __bindgen_bitfield_unit.set(65usize, 1u8, {
            let realloc_captures: u32 = unsafe { ::std::mem::transmute(realloc_captures) };
            realloc_captures as u64
        });
        __bindgen_bitfield_unit.set(66usize, 1u8, {
            let proxy: u32 = unsafe { ::std::mem::transmute(proxy) };
            proxy as u64
        });
        __bindgen_bitfield_unit.set(67usize, 1u8, {
            let bypass_cache: u32 = unsafe { ::std::mem::transmute(bypass_cache) };
            bypass_cache as u64
        });
        __bindgen_bitfield_unit.set(68usize, 1u8, {
            let no_cache: u32 = unsafe { ::std::mem::transmute(no_cache) };
            no_cache as u64
        });
        __bindgen_bitfield_unit.set(69usize, 2u8, {
            let limit_conn_status: u32 = unsafe { ::std::mem::transmute(limit_conn_status) };
            limit_conn_status as u64
        });
        __bindgen_bitfield_unit.set(71usize, 3u8, {
            let limit_req_status: u32 = unsafe { ::std::mem::transmute(limit_req_status) };
            limit_req_status as u64
        });
        __bindgen_bitfield_unit.set(74usize, 1u8, {
            let limit_rate_set: u32 = unsafe { ::std::mem::transmute(limit_rate_set) };
            limit_rate_set as u64
        });
        __bindgen_bitfield_unit.set(75usize, 1u8, {
            let limit_rate_after_set: u32 = unsafe { ::std::mem::transmute(limit_rate_after_set) };
            limit_rate_after_set as u64
        });
        __bindgen_bitfield_unit.set(76usize, 1u8, {
            let pipeline: u32 = unsafe { ::std::mem::transmute(pipeline) };
            pipeline as u64
        });
        __bindgen_bitfield_unit.set(77usize, 1u8, {
            let chunked: u32 = unsafe { ::std::mem::transmute(chunked) };
            chunked as u64
        });
        __bindgen_bitfield_unit.set(78usize, 1u8, {
            let header_only: u32 = unsafe { ::std::mem::transmute(header_only) };
            header_only as u64
        });
        __bindgen_bitfield_unit.set(79usize, 1u8, {
            let expect_trailers: u32 = unsafe { ::std::mem::transmute(expect_trailers) };
            expect_trailers as u64
        });
        __bindgen_bitfield_unit.set(80usize, 1u8, {
            let keepalive: u32 = unsafe { ::std::mem::transmute(keepalive) };
            keepalive as u64
        });
        __bindgen_bitfield_unit.set(81usize, 1u8, {
            let lingering_close: u32 = unsafe { ::std::mem::transmute(lingering_close) };
            lingering_close as u64
        });
        __bindgen_bitfield_unit.set(82usize, 1u8, {
            let discard_body: u32 = unsafe { ::std::mem::transmute(discard_body) };
            discard_body as u64
        });
        __bindgen_bitfield_unit.set(83usize, 1u8, {
            let reading_body: u32 = unsafe { ::std::mem::transmute(reading_body) };
            reading_body as u64
        });
        __bindgen_bitfield_unit.set(84usize, 1u8, {
            let internal: u32 = unsafe { ::std::mem::transmute(internal) };
            internal as u64
        });
        __bindgen_bitfield_unit.set(85usize, 1u8, {
            let error_page: u32 = unsafe { ::std::mem::transmute(error_page) };
            error_page as u64
        });
        __bindgen_bitfield_unit.set(86usize, 1u8, {
            let filter_finalize: u32 = unsafe { ::std::mem::transmute(filter_finalize) };
            filter_finalize as u64
        });
        __bindgen_bitfield_unit.set(87usize, 1u8, {
            let post_action: u32 = unsafe { ::std::mem::transmute(post_action) };
            post_action as u64
        });
        __bindgen_bitfield_unit.set(88usize, 1u8, {
            let request_complete: u32 = unsafe { ::std::mem::transmute(request_complete) };
            request_complete as u64
        });
        __bindgen_bitfield_unit.set(89usize, 1u8, {
            let request_output: u32 = unsafe { ::std::mem::transmute(request_output) };
            request_output as u64
        });
        __bindgen_bitfield_unit.set(90usize, 1u8, {
            let header_sent: u32 = unsafe { ::std::mem::transmute(header_sent) };
            header_sent as u64
        });
        __bindgen_bitfield_unit.set(91usize, 1u8, {
            let expect_tested: u32 = unsafe { ::std::mem::transmute(expect_tested) };
            expect_tested as u64
        });
        __bindgen_bitfield_unit.set(92usize, 1u8, {
            let root_tested: u32 = unsafe { ::std::mem::transmute(root_tested) };
            root_tested as u64
        });
        __bindgen_bitfield_unit.set(93usize, 1u8, {
            let done: u32 = unsafe { ::std::mem::transmute(done) };
            done as u64
        });
        __bindgen_bitfield_unit.set(94usize, 1u8, {
            let logged: u32 = unsafe { ::std::mem::transmute(logged) };
            logged as u64
        });
        __bindgen_bitfield_unit.set(96usize, 4u8, {
            let buffered: u32 = unsafe { ::std::mem::transmute(buffered) };
            buffered as u64
        });
        __bindgen_bitfield_unit.set(100usize, 1u8, {
            let main_filter_need_in_memory: u32 =
                unsafe { ::std::mem::transmute(main_filter_need_in_memory) };
            main_filter_need_in_memory as u64
        });
        __bindgen_bitfield_unit.set(101usize, 1u8, {
            let filter_need_in_memory: u32 =
                unsafe { ::std::mem::transmute(filter_need_in_memory) };
            filter_need_in_memory as u64
        });
        __bindgen_bitfield_unit.set(102usize, 1u8, {
            let filter_need_temporary: u32 =
                unsafe { ::std::mem::transmute(filter_need_temporary) };
            filter_need_temporary as u64
        });
        __bindgen_bitfield_unit.set(103usize, 1u8, {
            let preserve_body: u32 = unsafe { ::std::mem::transmute(preserve_body) };
            preserve_body as u64
        });
        __bindgen_bitfield_unit.set(104usize, 1u8, {
            let allow_ranges: u32 = unsafe { ::std::mem::transmute(allow_ranges) };
            allow_ranges as u64
        });
        __bindgen_bitfield_unit.set(105usize, 1u8, {
            let subrequest_ranges: u32 = unsafe { ::std::mem::transmute(subrequest_ranges) };
            subrequest_ranges as u64
        });
        __bindgen_bitfield_unit.set(106usize, 1u8, {
            let single_range: u32 = unsafe { ::std::mem::transmute(single_range) };
            single_range as u64
        });
        __bindgen_bitfield_unit.set(107usize, 1u8, {
            let disable_not_modified: u32 = unsafe { ::std::mem::transmute(disable_not_modified) };
            disable_not_modified as u64
        });
        __bindgen_bitfield_unit.set(108usize, 1u8, {
            let stat_reading: u32 = unsafe { ::std::mem::transmute(stat_reading) };
            stat_reading as u64
        });
        __bindgen_bitfield_unit.set(109usize, 1u8, {
            let stat_writing: u32 = unsafe { ::std::mem::transmute(stat_writing) };
            stat_writing as u64
        });
        __bindgen_bitfield_unit.set(110usize, 1u8, {
            let stat_processing: u32 = unsafe { ::std::mem::transmute(stat_processing) };
            stat_processing as u64
        });
        __bindgen_bitfield_unit.set(111usize, 1u8, {
            let background: u32 = unsafe { ::std::mem::transmute(background) };
            background as u64
        });
        __bindgen_bitfield_unit.set(112usize, 1u8, {
            let health_check: u32 = unsafe { ::std::mem::transmute(health_check) };
            health_check as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn http_minor(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_http_minor(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn http_major(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_http_major(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        http_minor: libc::c_uint,
        http_major: libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let http_minor: u32 = unsafe { ::std::mem::transmute(http_minor) };
            http_minor as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let http_major: u32 = unsafe { ::std::mem::transmute(http_major) };
            http_major as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_ephemeral_t {
    pub terminal_posted_request: ngx_http_posted_request_t,
}
extern "C" {
    pub static mut ngx_http_headers_in: [ngx_http_header_t; 0usize];
}
extern "C" {
    pub static mut ngx_http_headers_out: [ngx_http_header_out_t; 0usize];
}
#[repr(C)]
pub struct ngx_http_script_engine_t {
    pub ip: *mut u_char,
    pub pos: *mut u_char,
    pub sp: *mut ngx_http_variable_value_t,
    pub buf: ngx_str_t,
    pub line: ngx_str_t,
    pub args: *mut u_char,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub status: ngx_int_t,
    pub request: *mut ngx_http_request_t,
}
impl ::std::fmt::Debug for ngx_http_script_engine_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "ngx_http_script_engine_t {{ ip: {:?}, pos: {:?}, sp: {:?}, buf: {:?}, line: {:?}, args: {:?}, flushed : {:?}, skip : {:?}, quote : {:?}, is_args : {:?}, log : {:?}, request: {:?} }}" , self . ip , self . pos , self . sp , self . buf , self . line , self . args , self . flushed ( ) , self . skip ( ) , self . quote ( ) , self . is_args ( ) , self . log ( ) , self . request )
    }
}
impl ngx_http_script_engine_t {
    #[inline]
    pub fn flushed(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flushed(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn skip(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skip(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn quote(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_quote(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_args(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_args(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn log(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_log(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        flushed: libc::c_uint,
        skip: libc::c_uint,
        quote: libc::c_uint,
        is_args: libc::c_uint,
        log: libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let flushed: u32 = unsafe { ::std::mem::transmute(flushed) };
            flushed as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let skip: u32 = unsafe { ::std::mem::transmute(skip) };
            skip as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let quote: u32 = unsafe { ::std::mem::transmute(quote) };
            quote as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let is_args: u32 = unsafe { ::std::mem::transmute(is_args) };
            is_args as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let log: u32 = unsafe { ::std::mem::transmute(log) };
            log as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct ngx_http_script_compile_t {
    pub cf: *mut ngx_conf_t,
    pub source: *mut ngx_str_t,
    pub flushes: *mut *mut ngx_array_t,
    pub lengths: *mut *mut ngx_array_t,
    pub values: *mut *mut ngx_array_t,
    pub variables: ngx_uint_t,
    pub ncaptures: ngx_uint_t,
    pub captures_mask: ngx_uint_t,
    pub size: ngx_uint_t,
    pub main: *mut libc::c_void,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl ::std::fmt::Debug for ngx_http_script_compile_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "ngx_http_script_compile_t {{ cf: {:?}, source: {:?}, flushes: {:?}, lengths: {:?}, values: {:?}, main: {:?}, compile_args : {:?}, complete_lengths : {:?}, complete_values : {:?}, zero : {:?}, conf_prefix : {:?}, root_prefix : {:?}, dup_capture : {:?}, args : {:?} }}" , self . cf , self . source , self . flushes , self . lengths , self . values , self . main , self . compile_args ( ) , self . complete_lengths ( ) , self . complete_values ( ) , self . zero ( ) , self . conf_prefix ( ) , self . root_prefix ( ) , self . dup_capture ( ) , self . args ( ) )
    }
}
impl ngx_http_script_compile_t {
    #[inline]
    pub fn compile_args(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_compile_args(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn complete_lengths(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_complete_lengths(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn complete_values(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_complete_values(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn zero(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_zero(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn conf_prefix(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_conf_prefix(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn root_prefix(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_root_prefix(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dup_capture(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dup_capture(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn args(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_args(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        compile_args: libc::c_uint,
        complete_lengths: libc::c_uint,
        complete_values: libc::c_uint,
        zero: libc::c_uint,
        conf_prefix: libc::c_uint,
        root_prefix: libc::c_uint,
        dup_capture: libc::c_uint,
        args: libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let compile_args: u32 = unsafe { ::std::mem::transmute(compile_args) };
            compile_args as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let complete_lengths: u32 = unsafe { ::std::mem::transmute(complete_lengths) };
            complete_lengths as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let complete_values: u32 = unsafe { ::std::mem::transmute(complete_values) };
            complete_values as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let zero: u32 = unsafe { ::std::mem::transmute(zero) };
            zero as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let conf_prefix: u32 = unsafe { ::std::mem::transmute(conf_prefix) };
            conf_prefix as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let root_prefix: u32 = unsafe { ::std::mem::transmute(root_prefix) };
            root_prefix as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let dup_capture: u32 = unsafe { ::std::mem::transmute(dup_capture) };
            dup_capture as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let args: u32 = unsafe { ::std::mem::transmute(args) };
            args as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct ngx_http_complex_value_t {
    pub value: ngx_str_t,
    pub flushes: *mut ngx_uint_t,
    pub lengths: *mut libc::c_void,
    pub values: *mut libc::c_void,
    pub u: ngx_http_complex_value_t__bindgen_ty_1,
}
#[repr(C)]
pub struct ngx_http_complex_value_t__bindgen_ty_1 {
    pub size: __BindgenUnionField<size_t>,
    pub bindgen_union_field: u64,
}
impl ::std::fmt::Debug for ngx_http_complex_value_t__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "ngx_http_complex_value_t__bindgen_ty_1 {{ union }}")
    }
}
impl ::std::fmt::Debug for ngx_http_complex_value_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "ngx_http_complex_value_t {{ value: {:?}, flushes: {:?}, lengths: {:?}, values: {:?}, u: {:?} }}" , self . value , self . flushes , self . lengths , self . values , self . u )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_compile_complex_value_t {
    pub cf: *mut ngx_conf_t,
    pub value: *mut ngx_str_t,
    pub complex_value: *mut ngx_http_complex_value_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl ngx_http_compile_complex_value_t {
    #[inline]
    pub fn zero(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_zero(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn conf_prefix(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_conf_prefix(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn root_prefix(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_root_prefix(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        zero: libc::c_uint,
        conf_prefix: libc::c_uint,
        root_prefix: libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let zero: u32 = unsafe { ::std::mem::transmute(zero) };
            zero as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let conf_prefix: u32 = unsafe { ::std::mem::transmute(conf_prefix) };
            conf_prefix as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let root_prefix: u32 = unsafe { ::std::mem::transmute(root_prefix) };
            root_prefix as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type ngx_http_script_code_pt =
    ::std::option::Option<unsafe extern "C" fn(e: *mut ngx_http_script_engine_t)>;
pub type ngx_http_script_len_code_pt =
    ::std::option::Option<unsafe extern "C" fn(e: *mut ngx_http_script_engine_t) -> size_t>;
#[repr(C)]
pub struct ngx_http_script_copy_code_t {
    pub code: ngx_http_script_code_pt,
    pub len: usize,
}
impl ::std::fmt::Debug for ngx_http_script_copy_code_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "ngx_http_script_copy_code_t {{ code: {:?} }}", self.code)
    }
}
#[repr(C)]
pub struct ngx_http_script_var_code_t {
    pub code: ngx_http_script_code_pt,
    pub index: usize,
}
impl ::std::fmt::Debug for ngx_http_script_var_code_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "ngx_http_script_var_code_t {{ code: {:?} }}", self.code)
    }
}
#[repr(C)]
pub struct ngx_http_script_var_handler_code_t {
    pub code: ngx_http_script_code_pt,
    pub handler: ngx_http_set_variable_pt,
    pub data: usize,
}
impl ::std::fmt::Debug for ngx_http_script_var_handler_code_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_http_script_var_handler_code_t {{ code: {:?}, handler: {:?} }}",
            self.code, self.handler
        )
    }
}
#[repr(C)]
pub struct ngx_http_script_copy_capture_code_t {
    pub code: ngx_http_script_code_pt,
    pub n: usize,
}
impl ::std::fmt::Debug for ngx_http_script_copy_capture_code_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_http_script_copy_capture_code_t {{ code: {:?} }}",
            self.code
        )
    }
}
#[repr(C)]
pub struct ngx_http_script_regex_code_t {
    pub code: ngx_http_script_code_pt,
    pub regex: *mut ngx_http_regex_t,
    pub lengths: *mut ngx_array_t,
    pub size: usize,
    pub status: usize,
    pub next: usize,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub name: ngx_str_t,
}
impl ::std::fmt::Debug for ngx_http_script_regex_code_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "ngx_http_script_regex_code_t {{ code: {:?}, regex: {:?}, lengths: {:?}, test : {:?}, negative_test : {:?}, uri : {:?}, args : {:?}, add_args : {:?}, redirect : {:?}, break_cycle : {:?}, name: {:?} }}" , self . code , self . regex , self . lengths , self . test ( ) , self . negative_test ( ) , self . uri ( ) , self . args ( ) , self . add_args ( ) , self . redirect ( ) , self . break_cycle ( ) , self . name )
    }
}
impl ngx_http_script_regex_code_t {
    #[inline]
    pub fn test(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_test(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn negative_test(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_negative_test(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn uri(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_uri(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn args(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_args(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn add_args(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_add_args(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn redirect(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_redirect(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn break_cycle(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_break_cycle(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        test: libc::c_uint,
        negative_test: libc::c_uint,
        uri: libc::c_uint,
        args: libc::c_uint,
        add_args: libc::c_uint,
        redirect: libc::c_uint,
        break_cycle: libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let test: u32 = unsafe { ::std::mem::transmute(test) };
            test as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let negative_test: u32 = unsafe { ::std::mem::transmute(negative_test) };
            negative_test as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let uri: u32 = unsafe { ::std::mem::transmute(uri) };
            uri as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let args: u32 = unsafe { ::std::mem::transmute(args) };
            args as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let add_args: u32 = unsafe { ::std::mem::transmute(add_args) };
            add_args as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let redirect: u32 = unsafe { ::std::mem::transmute(redirect) };
            redirect as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let break_cycle: u32 = unsafe { ::std::mem::transmute(break_cycle) };
            break_cycle as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_script_regex_end_code_t {
    pub code: ngx_http_script_code_pt,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl ngx_http_script_regex_end_code_t {
    #[inline]
    pub fn uri(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_uri(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn args(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_args(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn add_args(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_add_args(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn redirect(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_redirect(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        uri: libc::c_uint,
        args: libc::c_uint,
        add_args: libc::c_uint,
        redirect: libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let uri: u32 = unsafe { ::std::mem::transmute(uri) };
            uri as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let args: u32 = unsafe { ::std::mem::transmute(args) };
            args as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let add_args: u32 = unsafe { ::std::mem::transmute(add_args) };
            add_args as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let redirect: u32 = unsafe { ::std::mem::transmute(redirect) };
            redirect as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct ngx_http_script_full_name_code_t {
    pub code: ngx_http_script_code_pt,
    pub conf_prefix: usize,
}
impl ::std::fmt::Debug for ngx_http_script_full_name_code_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_http_script_full_name_code_t {{ code: {:?} }}",
            self.code
        )
    }
}
#[repr(C)]
pub struct ngx_http_script_return_code_t {
    pub code: ngx_http_script_code_pt,
    pub status: usize,
    pub text: ngx_http_complex_value_t,
}
impl ::std::fmt::Debug for ngx_http_script_return_code_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_http_script_return_code_t {{ code: {:?}, text: {:?} }}",
            self.code, self.text
        )
    }
}
pub const ngx_http_script_file_plain: ngx_http_script_file_op_e = 0;
pub const ngx_http_script_file_not_plain: ngx_http_script_file_op_e = 1;
pub const ngx_http_script_file_dir: ngx_http_script_file_op_e = 2;
pub const ngx_http_script_file_not_dir: ngx_http_script_file_op_e = 3;
pub const ngx_http_script_file_exists: ngx_http_script_file_op_e = 4;
pub const ngx_http_script_file_not_exists: ngx_http_script_file_op_e = 5;
pub const ngx_http_script_file_exec: ngx_http_script_file_op_e = 6;
pub const ngx_http_script_file_not_exec: ngx_http_script_file_op_e = 7;
pub type ngx_http_script_file_op_e = u32;
#[repr(C)]
pub struct ngx_http_script_file_code_t {
    pub code: ngx_http_script_code_pt,
    pub op: usize,
}
impl ::std::fmt::Debug for ngx_http_script_file_code_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "ngx_http_script_file_code_t {{ code: {:?} }}", self.code)
    }
}
#[repr(C)]
pub struct ngx_http_script_if_code_t {
    pub code: ngx_http_script_code_pt,
    pub next: usize,
    pub loc_conf: *mut *mut libc::c_void,
}
impl ::std::fmt::Debug for ngx_http_script_if_code_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_http_script_if_code_t {{ code: {:?}, loc_conf: {:?} }}",
            self.code, self.loc_conf
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_script_complex_value_code_t {
    pub code: ngx_http_script_code_pt,
    pub lengths: *mut ngx_array_t,
}
#[repr(C)]
pub struct ngx_http_script_value_code_t {
    pub code: ngx_http_script_code_pt,
    pub value: usize,
    pub text_len: usize,
    pub text_data: usize,
}
impl ::std::fmt::Debug for ngx_http_script_value_code_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_http_script_value_code_t {{ code: {:?} }}",
            self.code
        )
    }
}
extern "C" {
    pub fn ngx_http_script_flush_complex_value(
        r: *mut ngx_http_request_t,
        val: *mut ngx_http_complex_value_t,
    );
}
extern "C" {
    pub fn ngx_http_complex_value(
        r: *mut ngx_http_request_t,
        val: *mut ngx_http_complex_value_t,
        value: *mut ngx_str_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_complex_value_size(
        r: *mut ngx_http_request_t,
        val: *mut ngx_http_complex_value_t,
        default_value: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn ngx_http_compile_complex_value(ccv: *mut ngx_http_compile_complex_value_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_set_complex_value_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut libc::c_void,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn ngx_http_set_complex_value_size_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut libc::c_void,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn ngx_http_test_predicates(
        r: *mut ngx_http_request_t,
        predicates: *mut ngx_array_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_test_required_predicates(
        r: *mut ngx_http_request_t,
        predicates: *mut ngx_array_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_set_predicate_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut libc::c_void,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn ngx_http_script_variables_count(value: *mut ngx_str_t) -> ngx_uint_t;
}
extern "C" {
    pub fn ngx_http_script_compile(sc: *mut ngx_http_script_compile_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_script_run(
        r: *mut ngx_http_request_t,
        value: *mut ngx_str_t,
        code_lengths: *mut libc::c_void,
        reserved: size_t,
        code_values: *mut libc::c_void,
    ) -> *mut u_char;
}
extern "C" {
    pub fn ngx_http_script_flush_no_cacheable_variables(
        r: *mut ngx_http_request_t,
        indices: *mut ngx_array_t,
    );
}
extern "C" {
    pub fn ngx_http_script_start_code(
        pool: *mut ngx_pool_t,
        codes: *mut *mut ngx_array_t,
        size: size_t,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn ngx_http_script_add_code(
        codes: *mut ngx_array_t,
        size: size_t,
        code: *mut libc::c_void,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn ngx_http_script_copy_len_code(e: *mut ngx_http_script_engine_t) -> size_t;
}
extern "C" {
    pub fn ngx_http_script_copy_code(e: *mut ngx_http_script_engine_t);
}
extern "C" {
    pub fn ngx_http_script_copy_var_len_code(e: *mut ngx_http_script_engine_t) -> size_t;
}
extern "C" {
    pub fn ngx_http_script_copy_var_code(e: *mut ngx_http_script_engine_t);
}
extern "C" {
    pub fn ngx_http_script_copy_capture_len_code(e: *mut ngx_http_script_engine_t) -> size_t;
}
extern "C" {
    pub fn ngx_http_script_copy_capture_code(e: *mut ngx_http_script_engine_t);
}
extern "C" {
    pub fn ngx_http_script_mark_args_code(e: *mut ngx_http_script_engine_t) -> size_t;
}
extern "C" {
    pub fn ngx_http_script_start_args_code(e: *mut ngx_http_script_engine_t);
}
extern "C" {
    pub fn ngx_http_script_regex_start_code(e: *mut ngx_http_script_engine_t);
}
extern "C" {
    pub fn ngx_http_script_regex_end_code(e: *mut ngx_http_script_engine_t);
}
extern "C" {
    pub fn ngx_http_script_return_code(e: *mut ngx_http_script_engine_t);
}
extern "C" {
    pub fn ngx_http_script_break_code(e: *mut ngx_http_script_engine_t);
}
extern "C" {
    pub fn ngx_http_script_if_code(e: *mut ngx_http_script_engine_t);
}
extern "C" {
    pub fn ngx_http_script_equal_code(e: *mut ngx_http_script_engine_t);
}
extern "C" {
    pub fn ngx_http_script_not_equal_code(e: *mut ngx_http_script_engine_t);
}
extern "C" {
    pub fn ngx_http_script_file_code(e: *mut ngx_http_script_engine_t);
}
extern "C" {
    pub fn ngx_http_script_complex_value_code(e: *mut ngx_http_script_engine_t);
}
extern "C" {
    pub fn ngx_http_script_value_code(e: *mut ngx_http_script_engine_t);
}
extern "C" {
    pub fn ngx_http_script_set_var_code(e: *mut ngx_http_script_engine_t);
}
extern "C" {
    pub fn ngx_http_script_var_set_handler_code(e: *mut ngx_http_script_engine_t);
}
extern "C" {
    pub fn ngx_http_script_var_code(e: *mut ngx_http_script_engine_t);
}
extern "C" {
    pub fn ngx_http_script_nop_code(e: *mut ngx_http_script_engine_t);
}
#[repr(C)]
pub struct ngx_event_s {
    pub data: *mut libc::c_void,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize], u8>,
    pub kq_errno: libc::c_int,
    pub available: libc::c_int,
    pub handler: ngx_event_handler_pt,
    pub index: ngx_uint_t,
    pub log: *mut ngx_log_t,
    pub timer: ngx_rbtree_node_t,
    pub queue: ngx_queue_t,
}
impl ::std::fmt::Debug for ngx_event_s {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "ngx_event_s {{ data: {:?}, write : {:?}, accept : {:?}, instance : {:?}, active : {:?}, disabled : {:?}, ready : {:?}, oneshot : {:?}, complete : {:?}, eof : {:?}, error : {:?}, timedout : {:?}, timer_set : {:?}, delayed : {:?}, deferred_accept : {:?}, pending_eof : {:?}, posted : {:?}, closed : {:?}, channel : {:?}, resolver : {:?}, cancelable : {:?}, kq_vnode : {:?}, kq_errno: {:?}, available: {:?}, handler: {:?}, log: {:?}, timer: {:?}, queue: {:?} }}" , self . data , self . write ( ) , self . accept ( ) , self . instance ( ) , self . active ( ) , self . disabled ( ) , self . ready ( ) , self . oneshot ( ) , self . complete ( ) , self . eof ( ) , self . error ( ) , self . timedout ( ) , self . timer_set ( ) , self . delayed ( ) , self . deferred_accept ( ) , self . pending_eof ( ) , self . posted ( ) , self . closed ( ) , self . channel ( ) , self . resolver ( ) , self . cancelable ( ) , self . kq_vnode ( ) , self . kq_errno , self . available , self . handler , self . log , self . timer , self . queue )
    }
}
impl ngx_event_s {
    #[inline]
    pub fn write(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_write(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn accept(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_accept(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn instance(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_instance(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn active(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_active(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disabled(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disabled(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ready(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ready(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn oneshot(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_oneshot(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn complete(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_complete(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn eof(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_eof(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn error(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_error(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn timedout(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_timedout(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn timer_set(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_timer_set(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn delayed(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_delayed(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn deferred_accept(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_deferred_accept(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pending_eof(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pending_eof(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn posted(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_posted(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn closed(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_closed(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn resolver(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_resolver(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cancelable(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cancelable(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn kq_vnode(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_kq_vnode(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        write: libc::c_uint,
        accept: libc::c_uint,
        instance: libc::c_uint,
        active: libc::c_uint,
        disabled: libc::c_uint,
        ready: libc::c_uint,
        oneshot: libc::c_uint,
        complete: libc::c_uint,
        eof: libc::c_uint,
        error: libc::c_uint,
        timedout: libc::c_uint,
        timer_set: libc::c_uint,
        delayed: libc::c_uint,
        deferred_accept: libc::c_uint,
        pending_eof: libc::c_uint,
        posted: libc::c_uint,
        closed: libc::c_uint,
        channel: libc::c_uint,
        resolver: libc::c_uint,
        cancelable: libc::c_uint,
        kq_vnode: libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 3usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let write: u32 = unsafe { ::std::mem::transmute(write) };
            write as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let accept: u32 = unsafe { ::std::mem::transmute(accept) };
            accept as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let instance: u32 = unsafe { ::std::mem::transmute(instance) };
            instance as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let active: u32 = unsafe { ::std::mem::transmute(active) };
            active as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let disabled: u32 = unsafe { ::std::mem::transmute(disabled) };
            disabled as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let ready: u32 = unsafe { ::std::mem::transmute(ready) };
            ready as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let oneshot: u32 = unsafe { ::std::mem::transmute(oneshot) };
            oneshot as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let complete: u32 = unsafe { ::std::mem::transmute(complete) };
            complete as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let eof: u32 = unsafe { ::std::mem::transmute(eof) };
            eof as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let error: u32 = unsafe { ::std::mem::transmute(error) };
            error as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let timedout: u32 = unsafe { ::std::mem::transmute(timedout) };
            timedout as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let timer_set: u32 = unsafe { ::std::mem::transmute(timer_set) };
            timer_set as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let delayed: u32 = unsafe { ::std::mem::transmute(delayed) };
            delayed as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let deferred_accept: u32 = unsafe { ::std::mem::transmute(deferred_accept) };
            deferred_accept as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let pending_eof: u32 = unsafe { ::std::mem::transmute(pending_eof) };
            pending_eof as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let posted: u32 = unsafe { ::std::mem::transmute(posted) };
            posted as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let closed: u32 = unsafe { ::std::mem::transmute(closed) };
            closed as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let channel: u32 = unsafe { ::std::mem::transmute(channel) };
            channel as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let resolver: u32 = unsafe { ::std::mem::transmute(resolver) };
            resolver as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let cancelable: u32 = unsafe { ::std::mem::transmute(cancelable) };
            cancelable as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let kq_vnode: u32 = unsafe { ::std::mem::transmute(kq_vnode) };
            kq_vnode as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_event_actions_t {
    pub add: ::std::option::Option<
        unsafe extern "C" fn(
            ev: *mut ngx_event_t,
            event: ngx_int_t,
            flags: ngx_uint_t,
        ) -> ngx_int_t,
    >,
    pub del: ::std::option::Option<
        unsafe extern "C" fn(
            ev: *mut ngx_event_t,
            event: ngx_int_t,
            flags: ngx_uint_t,
        ) -> ngx_int_t,
    >,
    pub enable: ::std::option::Option<
        unsafe extern "C" fn(
            ev: *mut ngx_event_t,
            event: ngx_int_t,
            flags: ngx_uint_t,
        ) -> ngx_int_t,
    >,
    pub disable: ::std::option::Option<
        unsafe extern "C" fn(
            ev: *mut ngx_event_t,
            event: ngx_int_t,
            flags: ngx_uint_t,
        ) -> ngx_int_t,
    >,
    pub add_conn:
        ::std::option::Option<unsafe extern "C" fn(c: *mut ngx_connection_t) -> ngx_int_t>,
    pub del_conn: ::std::option::Option<
        unsafe extern "C" fn(c: *mut ngx_connection_t, flags: ngx_uint_t) -> ngx_int_t,
    >,
    pub notify:
        ::std::option::Option<unsafe extern "C" fn(handler: ngx_event_handler_pt) -> ngx_int_t>,
    pub process_events: ::std::option::Option<
        unsafe extern "C" fn(
            cycle: *mut ngx_cycle_t,
            timer: ngx_msec_t,
            flags: ngx_uint_t,
        ) -> ngx_int_t,
    >,
    pub init: ::std::option::Option<
        unsafe extern "C" fn(cycle: *mut ngx_cycle_t, timer: ngx_msec_t) -> ngx_int_t,
    >,
    pub done: ::std::option::Option<unsafe extern "C" fn(cycle: *mut ngx_cycle_t)>,
}
extern "C" {
    pub static mut ngx_event_actions: ngx_event_actions_t;
}
extern "C" {
    pub static mut ngx_io: ngx_os_io_t;
}
#[repr(C)]
pub struct ngx_event_conf_t {
    pub connections: ngx_uint_t,
    pub use_: ngx_uint_t,
    pub multi_accept: ngx_flag_t,
    pub accept_mutex: ngx_flag_t,
    pub accept_mutex_delay: ngx_msec_t,
    pub name: *mut u_char,
}
impl ::std::fmt::Debug for ngx_event_conf_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "ngx_event_conf_t {{ name: {:?} }}", self.name)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_event_module_t {
    pub name: *mut ngx_str_t,
    pub create_conf:
        ::std::option::Option<unsafe extern "C" fn(cycle: *mut ngx_cycle_t) -> *mut libc::c_void>,
    pub init_conf: ::std::option::Option<
        unsafe extern "C" fn(cycle: *mut ngx_cycle_t, conf: *mut libc::c_void) -> *mut libc::c_char,
    >,
    pub actions: ngx_event_actions_t,
}
extern "C" {
    pub static mut ngx_connection_counter: *mut ngx_atomic_t;
}
extern "C" {
    pub static mut ngx_accept_mutex_ptr: *mut ngx_atomic_t;
}
extern "C" {
    pub static mut ngx_accept_mutex: ngx_shmtx_t;
}
extern "C" {
    pub static mut ngx_use_accept_mutex: ngx_uint_t;
}
extern "C" {
    pub static mut ngx_accept_events: ngx_uint_t;
}
extern "C" {
    pub static mut ngx_accept_mutex_held: ngx_uint_t;
}
extern "C" {
    pub static mut ngx_accept_mutex_delay: ngx_msec_t;
}
extern "C" {
    pub static mut ngx_accept_disabled: ngx_int_t;
}
extern "C" {
    pub static mut ngx_event_timer_alarm: sig_atomic_t;
}
extern "C" {
    pub static mut ngx_event_flags: ngx_uint_t;
}
extern "C" {
    pub static mut ngx_events_module: ngx_module_t;
}
extern "C" {
    pub static mut ngx_event_core_module: ngx_module_t;
}
extern "C" {
    pub fn ngx_event_accept(ev: *mut ngx_event_t);
}
extern "C" {
    pub fn ngx_event_recvmsg(ev: *mut ngx_event_t);
}
extern "C" {
    pub fn ngx_udp_rbtree_insert_value(
        temp: *mut ngx_rbtree_node_t,
        node: *mut ngx_rbtree_node_t,
        sentinel: *mut ngx_rbtree_node_t,
    );
}
extern "C" {
    pub fn ngx_delete_udp_connection(data: *mut libc::c_void);
}
extern "C" {
    pub fn ngx_trylock_accept_mutex(cycle: *mut ngx_cycle_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_enable_accept_events(cycle: *mut ngx_cycle_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_accept_log_error(log: *mut ngx_log_t, buf: *mut u_char, len: size_t) -> *mut u_char;
}
extern "C" {
    pub fn ngx_process_events_and_timers(cycle: *mut ngx_cycle_t);
}
extern "C" {
    pub fn ngx_handle_read_event(rev: *mut ngx_event_t, flags: ngx_uint_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_handle_write_event(wev: *mut ngx_event_t, lowat: size_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_send_lowat(c: *mut ngx_connection_t, lowat: size_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_event_timer_init(log: *mut ngx_log_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_event_find_timer() -> ngx_msec_t;
}
extern "C" {
    pub fn ngx_event_expire_timers();
}
extern "C" {
    pub fn ngx_event_no_timers_left() -> ngx_int_t;
}
extern "C" {
    pub static mut ngx_event_timer_rbtree: ngx_rbtree_t;
}
extern "C" {
    pub fn ngx_event_process_posted(cycle: *mut ngx_cycle_t, posted: *mut ngx_queue_t);
}
extern "C" {
    pub fn ngx_event_move_posted_next(cycle: *mut ngx_cycle_t);
}
extern "C" {
    pub static mut ngx_posted_accept_events: ngx_queue_t;
}
extern "C" {
    pub static mut ngx_posted_next_events: ngx_queue_t;
}
extern "C" {
    pub static mut ngx_posted_events: ngx_queue_t;
}
pub type ngx_peer_connection_t = ngx_peer_connection_s;
pub type ngx_event_get_peer_pt = ::std::option::Option<
    unsafe extern "C" fn(pc: *mut ngx_peer_connection_t, data: *mut libc::c_void) -> ngx_int_t,
>;
pub type ngx_event_free_peer_pt = ::std::option::Option<
    unsafe extern "C" fn(
        pc: *mut ngx_peer_connection_t,
        data: *mut libc::c_void,
        state: ngx_uint_t,
    ),
>;
pub type ngx_event_notify_peer_pt = ::std::option::Option<
    unsafe extern "C" fn(
        pc: *mut ngx_peer_connection_t,
        data: *mut libc::c_void,
        type_: ngx_uint_t,
    ),
>;
pub type ngx_event_set_peer_session_pt = ::std::option::Option<
    unsafe extern "C" fn(pc: *mut ngx_peer_connection_t, data: *mut libc::c_void) -> ngx_int_t,
>;
pub type ngx_event_save_peer_session_pt = ::std::option::Option<
    unsafe extern "C" fn(pc: *mut ngx_peer_connection_t, data: *mut libc::c_void),
>;
#[repr(C)]
pub struct ngx_peer_connection_s {
    pub connection: *mut ngx_connection_t,
    pub sockaddr: *mut sockaddr,
    pub socklen: socklen_t,
    pub name: *mut ngx_str_t,
    pub tries: ngx_uint_t,
    pub start_time: ngx_msec_t,
    pub get: ngx_event_get_peer_pt,
    pub free: ngx_event_free_peer_pt,
    pub notify: ngx_event_notify_peer_pt,
    pub data: *mut libc::c_void,
    pub local: *mut ngx_addr_t,
    pub type_: libc::c_int,
    pub rcvbuf: libc::c_int,
    pub log: *mut ngx_log_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl ::std::fmt::Debug for ngx_peer_connection_s {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "ngx_peer_connection_s {{ connection: {:?}, sockaddr: {:?}, name: {:?}, get: {:?}, free: {:?}, notify: {:?}, data: {:?}, local: {:?}, type: {:?}, rcvbuf: {:?}, log: {:?}, cached : {:?}, transparent : {:?}, so_keepalive : {:?}, down : {:?}, log_error : {:?} }}" , self . connection , self . sockaddr , self . name , self . get , self . free , self . notify , self . data , self . local , self . type_ , self . rcvbuf , self . log , self . cached ( ) , self . transparent ( ) , self . so_keepalive ( ) , self . down ( ) , self . log_error ( ) )
    }
}
impl ngx_peer_connection_s {
    #[inline]
    pub fn cached(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cached(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn transparent(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_transparent(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn so_keepalive(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_so_keepalive(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn down(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_down(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn log_error(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_log_error(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cached: libc::c_uint,
        transparent: libc::c_uint,
        so_keepalive: libc::c_uint,
        down: libc::c_uint,
        log_error: libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let cached: u32 = unsafe { ::std::mem::transmute(cached) };
            cached as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let transparent: u32 = unsafe { ::std::mem::transmute(transparent) };
            transparent as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let so_keepalive: u32 = unsafe { ::std::mem::transmute(so_keepalive) };
            so_keepalive as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let down: u32 = unsafe { ::std::mem::transmute(down) };
            down as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let log_error: u32 = unsafe { ::std::mem::transmute(log_error) };
            log_error as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn ngx_event_connect_peer(pc: *mut ngx_peer_connection_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_event_get_peer(pc: *mut ngx_peer_connection_t, data: *mut libc::c_void)
        -> ngx_int_t;
}
pub type ngx_event_pipe_t = ngx_event_pipe_s;
pub type ngx_event_pipe_input_filter_pt = ::std::option::Option<
    unsafe extern "C" fn(p: *mut ngx_event_pipe_t, buf: *mut ngx_buf_t) -> ngx_int_t,
>;
pub type ngx_event_pipe_output_filter_pt = ::std::option::Option<
    unsafe extern "C" fn(data: *mut libc::c_void, chain: *mut ngx_chain_t) -> ngx_int_t,
>;
#[repr(C)]
pub struct ngx_event_pipe_s {
    pub upstream: *mut ngx_connection_t,
    pub downstream: *mut ngx_connection_t,
    pub free_raw_bufs: *mut ngx_chain_t,
    pub in_: *mut ngx_chain_t,
    pub last_in: *mut *mut ngx_chain_t,
    pub writing: *mut ngx_chain_t,
    pub out: *mut ngx_chain_t,
    pub free: *mut ngx_chain_t,
    pub busy: *mut ngx_chain_t,
    pub input_filter: ngx_event_pipe_input_filter_pt,
    pub input_ctx: *mut libc::c_void,
    pub output_filter: ngx_event_pipe_output_filter_pt,
    pub output_ctx: *mut libc::c_void,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub allocated: ngx_int_t,
    pub bufs: ngx_bufs_t,
    pub tag: ngx_buf_tag_t,
    pub busy_size: ssize_t,
    pub read_length: off_t,
    pub length: off_t,
    pub max_temp_file_size: off_t,
    pub temp_file_write_size: ssize_t,
    pub read_timeout: ngx_msec_t,
    pub send_timeout: ngx_msec_t,
    pub send_lowat: ssize_t,
    pub pool: *mut ngx_pool_t,
    pub log: *mut ngx_log_t,
    pub preread_bufs: *mut ngx_chain_t,
    pub preread_size: size_t,
    pub buf_to_file: *mut ngx_buf_t,
    pub limit_rate: size_t,
    pub start_sec: time_t,
    pub temp_file: *mut ngx_temp_file_t,
    pub num: libc::c_int,
}
impl ::std::fmt::Debug for ngx_event_pipe_s {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "ngx_event_pipe_s {{ upstream: {:?}, downstream: {:?}, free_raw_bufs: {:?}, in: {:?}, last_in: {:?}, writing: {:?}, out: {:?}, free: {:?}, busy: {:?}, input_filter: {:?}, input_ctx: {:?}, output_filter: {:?}, output_ctx: {:?}, read : {:?}, cacheable : {:?}, single_buf : {:?}, free_bufs : {:?}, upstream_done : {:?}, upstream_error : {:?}, upstream_eof : {:?}, upstream_blocked : {:?}, downstream_done : {:?}, downstream_error : {:?}, cyclic_temp_file : {:?}, aio : {:?}, bufs: {:?}, tag: {:?}, pool: {:?}, log: {:?}, preread_bufs: {:?}, buf_to_file: {:?}, temp_file: {:?}, num: {:?} }}" , self . upstream , self . downstream , self . free_raw_bufs , self . in_ , self . last_in , self . writing , self . out , self . free , self . busy , self . input_filter , self . input_ctx , self . output_filter , self . output_ctx , self . read ( ) , self . cacheable ( ) , self . single_buf ( ) , self . free_bufs ( ) , self . upstream_done ( ) , self . upstream_error ( ) , self . upstream_eof ( ) , self . upstream_blocked ( ) , self . downstream_done ( ) , self . downstream_error ( ) , self . cyclic_temp_file ( ) , self . aio ( ) , self . bufs , self . tag , self . pool , self . log , self . preread_bufs , self . buf_to_file , self . temp_file , self . num )
    }
}
impl ngx_event_pipe_s {
    #[inline]
    pub fn read(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_read(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cacheable(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cacheable(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn single_buf(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_single_buf(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn free_bufs(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_free_bufs(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn upstream_done(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_upstream_done(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn upstream_error(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_upstream_error(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn upstream_eof(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_upstream_eof(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn upstream_blocked(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_upstream_blocked(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn downstream_done(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_downstream_done(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn downstream_error(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_downstream_error(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cyclic_temp_file(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cyclic_temp_file(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn aio(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_aio(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        read: libc::c_uint,
        cacheable: libc::c_uint,
        single_buf: libc::c_uint,
        free_bufs: libc::c_uint,
        upstream_done: libc::c_uint,
        upstream_error: libc::c_uint,
        upstream_eof: libc::c_uint,
        upstream_blocked: libc::c_uint,
        downstream_done: libc::c_uint,
        downstream_error: libc::c_uint,
        cyclic_temp_file: libc::c_uint,
        aio: libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let read: u32 = unsafe { ::std::mem::transmute(read) };
            read as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let cacheable: u32 = unsafe { ::std::mem::transmute(cacheable) };
            cacheable as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let single_buf: u32 = unsafe { ::std::mem::transmute(single_buf) };
            single_buf as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let free_bufs: u32 = unsafe { ::std::mem::transmute(free_bufs) };
            free_bufs as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let upstream_done: u32 = unsafe { ::std::mem::transmute(upstream_done) };
            upstream_done as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let upstream_error: u32 = unsafe { ::std::mem::transmute(upstream_error) };
            upstream_error as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let upstream_eof: u32 = unsafe { ::std::mem::transmute(upstream_eof) };
            upstream_eof as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let upstream_blocked: u32 = unsafe { ::std::mem::transmute(upstream_blocked) };
            upstream_blocked as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let downstream_done: u32 = unsafe { ::std::mem::transmute(downstream_done) };
            downstream_done as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let downstream_error: u32 = unsafe { ::std::mem::transmute(downstream_error) };
            downstream_error as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let cyclic_temp_file: u32 = unsafe { ::std::mem::transmute(cyclic_temp_file) };
            cyclic_temp_file as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let aio: u32 = unsafe { ::std::mem::transmute(aio) };
            aio as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn ngx_event_pipe(p: *mut ngx_event_pipe_t, do_write: ngx_int_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_event_pipe_copy_input_filter(
        p: *mut ngx_event_pipe_t,
        buf: *mut ngx_buf_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_event_pipe_add_free_buf(p: *mut ngx_event_pipe_t, b: *mut ngx_buf_t) -> ngx_int_t;
}
#[repr(C)]
pub struct ngx_http_upstream_state_t {
    pub status: ngx_uint_t,
    pub response_time: ngx_msec_t,
    pub connect_time: ngx_msec_t,
    pub header_time: ngx_msec_t,
    pub queue_time: ngx_msec_t,
    pub response_length: off_t,
    pub bytes_received: off_t,
    pub bytes_sent: off_t,
    pub peer: *mut ngx_str_t,
}
impl ::std::fmt::Debug for ngx_http_upstream_state_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "ngx_http_upstream_state_t {{ peer: {:?} }}", self.peer)
    }
}
#[repr(C)]
pub struct ngx_http_upstream_main_conf_t {
    pub headers_in_hash: ngx_hash_t,
    pub upstreams: ngx_array_t,
}
impl ::std::fmt::Debug for ngx_http_upstream_main_conf_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_http_upstream_main_conf_t {{ headers_in_hash: {:?}, upstreams: {:?} }}",
            self.headers_in_hash, self.upstreams
        )
    }
}
pub type ngx_http_upstream_srv_conf_t = ngx_http_upstream_srv_conf_s;
pub type ngx_http_upstream_init_pt = ::std::option::Option<
    unsafe extern "C" fn(cf: *mut ngx_conf_t, us: *mut ngx_http_upstream_srv_conf_t) -> ngx_int_t,
>;
pub type ngx_http_upstream_init_peer_pt = ::std::option::Option<
    unsafe extern "C" fn(
        r: *mut ngx_http_request_t,
        us: *mut ngx_http_upstream_srv_conf_t,
    ) -> ngx_int_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_upstream_peer_t {
    pub init_upstream: ngx_http_upstream_init_pt,
    pub init: ngx_http_upstream_init_peer_pt,
    pub data: *mut libc::c_void,
}
#[repr(C)]
pub struct ngx_http_upstream_server_t {
    pub name: ngx_str_t,
    pub addrs: *mut ngx_addr_t,
    pub naddrs: ngx_uint_t,
    pub weight: ngx_uint_t,
    pub max_conns: ngx_uint_t,
    pub max_fails: ngx_uint_t,
    pub fail_timeout: time_t,
    pub slow_start: ngx_msec_t,
    pub down: ngx_uint_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl ::std::fmt::Debug for ngx_http_upstream_server_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_http_upstream_server_t {{ name: {:?}, addrs: {:?}, backup : {:?} }}",
            self.name,
            self.addrs,
            self.backup()
        )
    }
}
impl ngx_http_upstream_server_t {
    #[inline]
    pub fn backup(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_backup(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(backup: libc::c_uint) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let backup: u32 = unsafe { ::std::mem::transmute(backup) };
            backup as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct ngx_http_upstream_srv_conf_s {
    pub peer: ngx_http_upstream_peer_t,
    pub srv_conf: *mut *mut libc::c_void,
    pub servers: *mut ngx_array_t,
    pub flags: ngx_uint_t,
    pub host: ngx_str_t,
    pub file_name: *mut u_char,
    pub line: ngx_uint_t,
    pub port: in_port_t,
    pub no_port: ngx_uint_t,
    pub shm_zone: *mut ngx_shm_zone_t,
}
impl ::std::fmt::Debug for ngx_http_upstream_srv_conf_s {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "ngx_http_upstream_srv_conf_s {{ peer: {:?}, srv_conf: {:?}, servers: {:?}, host: {:?}, file_name: {:?}, shm_zone: {:?} }}" , self . peer , self . srv_conf , self . servers , self . host , self . file_name , self . shm_zone )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_upstream_local_t {
    pub addr: *mut ngx_addr_t,
    pub value: *mut ngx_http_complex_value_t,
}
#[repr(C)]
pub struct ngx_http_upstream_conf_t {
    pub upstream: *mut ngx_http_upstream_srv_conf_t,
    pub connect_timeout: ngx_msec_t,
    pub send_timeout: ngx_msec_t,
    pub read_timeout: ngx_msec_t,
    pub next_upstream_timeout: ngx_msec_t,
    pub send_lowat: size_t,
    pub buffer_size: size_t,
    pub limit_rate: size_t,
    pub busy_buffers_size: size_t,
    pub max_temp_file_size: size_t,
    pub temp_file_write_size: size_t,
    pub busy_buffers_size_conf: size_t,
    pub max_temp_file_size_conf: size_t,
    pub temp_file_write_size_conf: size_t,
    pub bufs: ngx_bufs_t,
    pub ignore_headers: ngx_uint_t,
    pub next_upstream: ngx_uint_t,
    pub store_access: ngx_uint_t,
    pub next_upstream_tries: ngx_uint_t,
    pub buffering: ngx_flag_t,
    pub request_buffering: ngx_flag_t,
    pub pass_request_headers: ngx_flag_t,
    pub pass_request_body: ngx_flag_t,
    pub ignore_client_abort: ngx_flag_t,
    pub intercept_errors: ngx_flag_t,
    pub cyclic_temp_file: ngx_flag_t,
    pub force_ranges: ngx_flag_t,
    pub temp_path: *mut ngx_path_t,
    pub hide_headers_hash: ngx_hash_t,
    pub hide_headers: *mut ngx_array_t,
    pub pass_headers: *mut ngx_array_t,
    pub local: *mut ngx_http_upstream_local_t,
    pub socket_keepalive: ngx_flag_t,
    pub cache_zone: *mut ngx_shm_zone_t,
    pub cache_value: *mut ngx_http_complex_value_t,
    pub cache_min_uses: ngx_uint_t,
    pub cache_use_stale: ngx_uint_t,
    pub cache_methods: ngx_uint_t,
    pub cache_max_range_offset: off_t,
    pub cache_lock: ngx_flag_t,
    pub cache_lock_timeout: ngx_msec_t,
    pub cache_lock_age: ngx_msec_t,
    pub cache_revalidate: ngx_flag_t,
    pub cache_convert_head: ngx_flag_t,
    pub cache_background_update: ngx_flag_t,
    pub cache_valid: *mut ngx_array_t,
    pub cache_bypass: *mut ngx_array_t,
    pub cache_purge: *mut ngx_array_t,
    pub no_cache: *mut ngx_array_t,
    pub store_lengths: *mut ngx_array_t,
    pub store_values: *mut ngx_array_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub module: ngx_str_t,
}
impl ::std::fmt::Debug for ngx_http_upstream_conf_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "ngx_http_upstream_conf_t {{ upstream: {:?}, bufs: {:?}, temp_path: {:?}, hide_headers_hash: {:?}, hide_headers: {:?}, pass_headers: {:?}, local: {:?}, cache_zone: {:?}, cache_value: {:?}, cache_valid: {:?}, cache_bypass: {:?}, cache_purge: {:?}, no_cache: {:?}, store_lengths: {:?}, store_values: {:?}, cache : {:?}, store : {:?}, intercept_404 : {:?}, change_buffering : {:?}, pass_trailers : {:?}, preserve_output : {:?}, module: {:?} }}" , self . upstream , self . bufs , self . temp_path , self . hide_headers_hash , self . hide_headers , self . pass_headers , self . local , self . cache_zone , self . cache_value , self . cache_valid , self . cache_bypass , self . cache_purge , self . no_cache , self . store_lengths , self . store_values , self . cache ( ) , self . store ( ) , self . intercept_404 ( ) , self . change_buffering ( ) , self . pass_trailers ( ) , self . preserve_output ( ) , self . module )
    }
}
impl ngx_http_upstream_conf_t {
    #[inline]
    pub fn cache(&self) -> libc::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_cache(&mut self, val: libc::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn store(&self) -> libc::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_store(&mut self, val: libc::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn intercept_404(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_intercept_404(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn change_buffering(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_change_buffering(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pass_trailers(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pass_trailers(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn preserve_output(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_preserve_output(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cache: libc::c_int,
        store: libc::c_int,
        intercept_404: libc::c_uint,
        change_buffering: libc::c_uint,
        pass_trailers: libc::c_uint,
        preserve_output: libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let cache: u32 = unsafe { ::std::mem::transmute(cache) };
            cache as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let store: u32 = unsafe { ::std::mem::transmute(store) };
            store as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let intercept_404: u32 = unsafe { ::std::mem::transmute(intercept_404) };
            intercept_404 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let change_buffering: u32 = unsafe { ::std::mem::transmute(change_buffering) };
            change_buffering as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let pass_trailers: u32 = unsafe { ::std::mem::transmute(pass_trailers) };
            pass_trailers as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let preserve_output: u32 = unsafe { ::std::mem::transmute(preserve_output) };
            preserve_output as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct ngx_http_upstream_header_t {
    pub name: ngx_str_t,
    pub handler: ngx_http_header_handler_pt,
    pub offset: ngx_uint_t,
    pub copy_handler: ngx_http_header_handler_pt,
    pub conf: ngx_uint_t,
    pub redirect: ngx_uint_t,
}
impl ::std::fmt::Debug for ngx_http_upstream_header_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_http_upstream_header_t {{ name: {:?}, handler: {:?}, copy_handler: {:?} }}",
            self.name, self.handler, self.copy_handler
        )
    }
}
#[repr(C)]
pub struct ngx_http_upstream_headers_in_t {
    pub headers: ngx_list_t,
    pub trailers: ngx_list_t,
    pub status_n: ngx_uint_t,
    pub status_line: ngx_str_t,
    pub status: *mut ngx_table_elt_t,
    pub date: *mut ngx_table_elt_t,
    pub server: *mut ngx_table_elt_t,
    pub connection: *mut ngx_table_elt_t,
    pub expires: *mut ngx_table_elt_t,
    pub etag: *mut ngx_table_elt_t,
    pub x_accel_expires: *mut ngx_table_elt_t,
    pub x_accel_redirect: *mut ngx_table_elt_t,
    pub x_accel_limit_rate: *mut ngx_table_elt_t,
    pub content_type: *mut ngx_table_elt_t,
    pub content_length: *mut ngx_table_elt_t,
    pub last_modified: *mut ngx_table_elt_t,
    pub location: *mut ngx_table_elt_t,
    pub accept_ranges: *mut ngx_table_elt_t,
    pub www_authenticate: *mut ngx_table_elt_t,
    pub transfer_encoding: *mut ngx_table_elt_t,
    pub vary: *mut ngx_table_elt_t,
    pub content_encoding: *mut ngx_table_elt_t,
    pub cache_control: ngx_array_t,
    pub cookies: ngx_array_t,
    pub content_length_n: off_t,
    pub last_modified_time: time_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl ::std::fmt::Debug for ngx_http_upstream_headers_in_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "ngx_http_upstream_headers_in_t {{ headers: {:?}, trailers: {:?}, status_line: {:?}, status: {:?}, date: {:?}, server: {:?}, connection: {:?}, expires: {:?}, etag: {:?}, x_accel_expires: {:?}, x_accel_redirect: {:?}, x_accel_limit_rate: {:?}, content_type: {:?}, content_length: {:?}, last_modified: {:?}, location: {:?}, accept_ranges: {:?}, www_authenticate: {:?}, transfer_encoding: {:?}, vary: {:?}, content_encoding: {:?}, cache_control: {:?}, cookies: {:?}, connection_close : {:?}, chunked : {:?} }}" , self . headers , self . trailers , self . status_line , self . status , self . date , self . server , self . connection , self . expires , self . etag , self . x_accel_expires , self . x_accel_redirect , self . x_accel_limit_rate , self . content_type , self . content_length , self . last_modified , self . location , self . accept_ranges , self . www_authenticate , self . transfer_encoding , self . vary , self . content_encoding , self . cache_control , self . cookies , self . connection_close ( ) , self . chunked ( ) )
    }
}
impl ngx_http_upstream_headers_in_t {
    #[inline]
    pub fn connection_close(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_connection_close(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn chunked(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_chunked(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        connection_close: libc::c_uint,
        chunked: libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let connection_close: u32 = unsafe { ::std::mem::transmute(connection_close) };
            connection_close as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let chunked: u32 = unsafe { ::std::mem::transmute(chunked) };
            chunked as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct ngx_http_upstream_resolved_t {
    pub host: ngx_str_t,
    pub port: in_port_t,
    pub no_port: ngx_uint_t,
    pub naddrs: ngx_uint_t,
    pub addrs: *mut ngx_resolver_addr_t,
    pub sockaddr: *mut sockaddr,
    pub socklen: socklen_t,
    pub name: ngx_str_t,
    pub ctx: *mut ngx_resolver_ctx_t,
}
impl ::std::fmt::Debug for ngx_http_upstream_resolved_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "ngx_http_upstream_resolved_t {{ host: {:?}, addrs: {:?}, sockaddr: {:?}, name: {:?}, ctx: {:?} }}" , self . host , self . addrs , self . sockaddr , self . name , self . ctx )
    }
}
pub type ngx_http_upstream_handler_pt = ::std::option::Option<
    unsafe extern "C" fn(r: *mut ngx_http_request_t, u: *mut ngx_http_upstream_t),
>;
#[repr(C)]
pub struct ngx_http_upstream_s {
    pub read_event_handler: ngx_http_upstream_handler_pt,
    pub write_event_handler: ngx_http_upstream_handler_pt,
    pub peer: ngx_peer_connection_t,
    pub pipe: *mut ngx_event_pipe_t,
    pub request_bufs: *mut ngx_chain_t,
    pub output: ngx_output_chain_ctx_t,
    pub writer: ngx_chain_writer_ctx_t,
    pub conf: *mut ngx_http_upstream_conf_t,
    pub upstream: *mut ngx_http_upstream_srv_conf_t,
    pub caches: *mut ngx_array_t,
    pub headers_in: ngx_http_upstream_headers_in_t,
    pub resolved: *mut ngx_http_upstream_resolved_t,
    pub from_client: ngx_buf_t,
    pub buffer: ngx_buf_t,
    pub length: off_t,
    pub out_bufs: *mut ngx_chain_t,
    pub busy_bufs: *mut ngx_chain_t,
    pub free_bufs: *mut ngx_chain_t,
    pub input_filter_init:
        ::std::option::Option<unsafe extern "C" fn(data: *mut libc::c_void) -> ngx_int_t>,
    pub input_filter: ::std::option::Option<
        unsafe extern "C" fn(data: *mut libc::c_void, bytes: ssize_t) -> ngx_int_t,
    >,
    pub input_filter_ctx: *mut libc::c_void,
    pub create_key:
        ::std::option::Option<unsafe extern "C" fn(r: *mut ngx_http_request_t) -> ngx_int_t>,
    pub create_request:
        ::std::option::Option<unsafe extern "C" fn(r: *mut ngx_http_request_t) -> ngx_int_t>,
    pub reinit_request:
        ::std::option::Option<unsafe extern "C" fn(r: *mut ngx_http_request_t) -> ngx_int_t>,
    pub process_header:
        ::std::option::Option<unsafe extern "C" fn(r: *mut ngx_http_request_t) -> ngx_int_t>,
    pub abort_request: ::std::option::Option<unsafe extern "C" fn(r: *mut ngx_http_request_t)>,
    pub finalize_request:
        ::std::option::Option<unsafe extern "C" fn(r: *mut ngx_http_request_t, rc: ngx_int_t)>,
    pub rewrite_redirect: ::std::option::Option<
        unsafe extern "C" fn(
            r: *mut ngx_http_request_t,
            h: *mut ngx_table_elt_t,
            prefix: size_t,
        ) -> ngx_int_t,
    >,
    pub rewrite_cookie: ::std::option::Option<
        unsafe extern "C" fn(r: *mut ngx_http_request_t, h: *mut ngx_table_elt_t) -> ngx_int_t,
    >,
    pub start_time: ngx_msec_t,
    pub state: *mut ngx_http_upstream_state_t,
    pub method: ngx_str_t,
    pub schema: ngx_str_t,
    pub uri: ngx_str_t,
    pub cleanup: *mut ngx_http_cleanup_pt,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub __bindgen_padding_0: [u16; 3usize],
}
impl ::std::fmt::Debug for ngx_http_upstream_s {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "ngx_http_upstream_s {{ read_event_handler: {:?}, write_event_handler: {:?}, peer: {:?}, pipe: {:?}, request_bufs: {:?}, output: {:?}, writer: {:?}, conf: {:?}, upstream: {:?}, caches: {:?}, headers_in: {:?}, resolved: {:?}, from_client: {:?}, buffer: {:?}, out_bufs: {:?}, busy_bufs: {:?}, free_bufs: {:?}, input_filter_init: {:?}, input_filter: {:?}, input_filter_ctx: {:?}, create_key: {:?}, create_request: {:?}, reinit_request: {:?}, process_header: {:?}, abort_request: {:?}, finalize_request: {:?}, rewrite_redirect: {:?}, rewrite_cookie: {:?}, state: {:?}, method: {:?}, schema: {:?}, uri: {:?}, cleanup: {:?}, store : {:?}, cacheable : {:?}, accel : {:?}, ssl : {:?}, cache_status : {:?}, buffering : {:?}, keepalive : {:?}, upgrade : {:?}, request_sent : {:?}, request_body_sent : {:?}, request_body_blocked : {:?}, header_sent : {:?} }}" , self . read_event_handler , self . write_event_handler , self . peer , self . pipe , self . request_bufs , self . output , self . writer , self . conf , self . upstream , self . caches , self . headers_in , self . resolved , self . from_client , self . buffer , self . out_bufs , self . busy_bufs , self . free_bufs , self . input_filter_init , self . input_filter , self . input_filter_ctx , self . create_key , self . create_request , self . reinit_request , self . process_header , self . abort_request , self . finalize_request , self . rewrite_redirect , self . rewrite_cookie , self . state , self . method , self . schema , self . uri , self . cleanup , self . store ( ) , self . cacheable ( ) , self . accel ( ) , self . ssl ( ) , self . cache_status ( ) , self . buffering ( ) , self . keepalive ( ) , self . upgrade ( ) , self . request_sent ( ) , self . request_body_sent ( ) , self . request_body_blocked ( ) , self . header_sent ( ) )
    }
}
impl ngx_http_upstream_s {
    #[inline]
    pub fn store(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_store(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cacheable(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cacheable(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn accel(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_accel(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ssl(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ssl(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cache_status(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_cache_status(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn buffering(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_buffering(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn keepalive(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_keepalive(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn upgrade(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_upgrade(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn request_sent(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_request_sent(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn request_body_sent(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_request_body_sent(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn request_body_blocked(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_request_body_blocked(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn header_sent(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_header_sent(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        store: libc::c_uint,
        cacheable: libc::c_uint,
        accel: libc::c_uint,
        ssl: libc::c_uint,
        cache_status: libc::c_uint,
        buffering: libc::c_uint,
        keepalive: libc::c_uint,
        upgrade: libc::c_uint,
        request_sent: libc::c_uint,
        request_body_sent: libc::c_uint,
        request_body_blocked: libc::c_uint,
        header_sent: libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let store: u32 = unsafe { ::std::mem::transmute(store) };
            store as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let cacheable: u32 = unsafe { ::std::mem::transmute(cacheable) };
            cacheable as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let accel: u32 = unsafe { ::std::mem::transmute(accel) };
            accel as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ssl: u32 = unsafe { ::std::mem::transmute(ssl) };
            ssl as u64
        });
        __bindgen_bitfield_unit.set(4usize, 3u8, {
            let cache_status: u32 = unsafe { ::std::mem::transmute(cache_status) };
            cache_status as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let buffering: u32 = unsafe { ::std::mem::transmute(buffering) };
            buffering as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let keepalive: u32 = unsafe { ::std::mem::transmute(keepalive) };
            keepalive as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let upgrade: u32 = unsafe { ::std::mem::transmute(upgrade) };
            upgrade as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let request_sent: u32 = unsafe { ::std::mem::transmute(request_sent) };
            request_sent as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let request_body_sent: u32 = unsafe { ::std::mem::transmute(request_body_sent) };
            request_body_sent as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let request_body_blocked: u32 = unsafe { ::std::mem::transmute(request_body_blocked) };
            request_body_blocked as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let header_sent: u32 = unsafe { ::std::mem::transmute(header_sent) };
            header_sent as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct ngx_http_upstream_next_t {
    pub status: ngx_uint_t,
    pub mask: ngx_uint_t,
}
impl ::std::fmt::Debug for ngx_http_upstream_next_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "ngx_http_upstream_next_t {{  }}")
    }
}
#[repr(C)]
pub struct ngx_http_upstream_param_t {
    pub key: ngx_str_t,
    pub value: ngx_str_t,
    pub skip_empty: ngx_uint_t,
}
impl ::std::fmt::Debug for ngx_http_upstream_param_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_http_upstream_param_t {{ key: {:?}, value: {:?} }}",
            self.key, self.value
        )
    }
}
extern "C" {
    pub fn ngx_http_upstream_create(r: *mut ngx_http_request_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_upstream_init(r: *mut ngx_http_request_t);
}
extern "C" {
    pub fn ngx_http_upstream_add(
        cf: *mut ngx_conf_t,
        u: *mut ngx_url_t,
        flags: ngx_uint_t,
    ) -> *mut ngx_http_upstream_srv_conf_t;
}
extern "C" {
    pub fn ngx_http_upstream_bind_set_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut libc::c_void,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn ngx_http_upstream_param_set_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut libc::c_void,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn ngx_http_upstream_hide_headers_hash(
        cf: *mut ngx_conf_t,
        conf: *mut ngx_http_upstream_conf_t,
        prev: *mut ngx_http_upstream_conf_t,
        default_hide_headers: *mut ngx_str_t,
        hash: *mut ngx_hash_init_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub static mut ngx_http_upstream_module: ngx_module_t;
}
extern "C" {
    pub static mut ngx_http_upstream_cache_method_mask: [ngx_conf_bitmask_t; 0usize];
}
extern "C" {
    pub static mut ngx_http_upstream_ignore_headers_masks: [ngx_conf_bitmask_t; 0usize];
}
pub type ngx_http_upstream_rr_peer_t = ngx_http_upstream_rr_peer_s;
#[repr(C)]
pub struct ngx_http_upstream_rr_peer_s {
    pub sockaddr: *mut sockaddr,
    pub socklen: socklen_t,
    pub name: ngx_str_t,
    pub server: ngx_str_t,
    pub current_weight: ngx_int_t,
    pub effective_weight: ngx_int_t,
    pub weight: ngx_int_t,
    pub conns: ngx_uint_t,
    pub max_conns: ngx_uint_t,
    pub fails: ngx_uint_t,
    pub accessed: time_t,
    pub checked: time_t,
    pub max_fails: ngx_uint_t,
    pub fail_timeout: time_t,
    pub slow_start: ngx_msec_t,
    pub start_time: ngx_msec_t,
    pub down: ngx_uint_t,
    pub lock: ngx_atomic_t,
    pub next: *mut ngx_http_upstream_rr_peer_t,
}
impl ::std::fmt::Debug for ngx_http_upstream_rr_peer_s {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "ngx_http_upstream_rr_peer_s {{ sockaddr: {:?}, name: {:?}, server: {:?}, next: {:?} }}" , self . sockaddr , self . name , self . server , self . next )
    }
}
pub type ngx_http_upstream_rr_peers_t = ngx_http_upstream_rr_peers_s;
#[repr(C)]
pub struct ngx_http_upstream_rr_peers_s {
    pub number: ngx_uint_t,
    pub shpool: *mut ngx_slab_pool_t,
    pub rwlock: ngx_atomic_t,
    pub zone_next: *mut ngx_http_upstream_rr_peers_t,
    pub total_weight: ngx_uint_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub name: *mut ngx_str_t,
    pub next: *mut ngx_http_upstream_rr_peers_t,
    pub peer: *mut ngx_http_upstream_rr_peer_t,
}
impl ::std::fmt::Debug for ngx_http_upstream_rr_peers_s {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "ngx_http_upstream_rr_peers_s {{ shpool: {:?}, zone_next: {:?}, single : {:?}, weighted : {:?}, name: {:?}, next: {:?}, peer: {:?} }}" , self . shpool , self . zone_next , self . single ( ) , self . weighted ( ) , self . name , self . next , self . peer )
    }
}
impl ngx_http_upstream_rr_peers_s {
    #[inline]
    pub fn single(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_single(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn weighted(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_weighted(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        single: libc::c_uint,
        weighted: libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let single: u32 = unsafe { ::std::mem::transmute(single) };
            single as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let weighted: u32 = unsafe { ::std::mem::transmute(weighted) };
            weighted as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct ngx_http_upstream_rr_peer_data_t {
    pub config: ngx_uint_t,
    pub peers: *mut ngx_http_upstream_rr_peers_t,
    pub current: *mut ngx_http_upstream_rr_peer_t,
    pub tried: *mut usize,
    pub data: usize,
}
impl ::std::fmt::Debug for ngx_http_upstream_rr_peer_data_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_http_upstream_rr_peer_data_t {{ peers: {:?}, current: {:?}, tried: {:?} }}",
            self.peers, self.current, self.tried
        )
    }
}
extern "C" {
    pub fn ngx_http_upstream_init_round_robin(
        cf: *mut ngx_conf_t,
        us: *mut ngx_http_upstream_srv_conf_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_upstream_init_round_robin_peer(
        r: *mut ngx_http_request_t,
        us: *mut ngx_http_upstream_srv_conf_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_upstream_create_round_robin_peer(
        r: *mut ngx_http_request_t,
        ur: *mut ngx_http_upstream_resolved_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_upstream_get_round_robin_peer(
        pc: *mut ngx_peer_connection_t,
        data: *mut libc::c_void,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_upstream_free_round_robin_peer(
        pc: *mut ngx_peer_connection_t,
        data: *mut libc::c_void,
        state: ngx_uint_t,
    );
}
pub type ngx_http_location_tree_node_t = ngx_http_location_tree_node_s;
pub type ngx_http_core_loc_conf_t = ngx_http_core_loc_conf_s;
#[repr(C)]
pub struct ngx_http_listen_opt_t {
    pub sockaddr: *mut sockaddr,
    pub socklen: socklen_t,
    pub addr_text: ngx_str_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub backlog: libc::c_int,
    pub rcvbuf: libc::c_int,
    pub sndbuf: libc::c_int,
    pub fastopen: libc::c_int,
}
impl ::std::fmt::Debug for ngx_http_listen_opt_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "ngx_http_listen_opt_t {{ sockaddr: {:?}, addr_text: {:?}, set : {:?}, default_server : {:?}, bind : {:?}, wildcard : {:?}, ssl : {:?}, http2 : {:?}, ipv6only : {:?}, deferred_accept : {:?}, reuseport : {:?}, so_keepalive : {:?}, proxy_protocol : {:?}, backlog: {:?}, rcvbuf: {:?}, sndbuf: {:?}, fastopen: {:?} }}" , self . sockaddr , self . addr_text , self . set ( ) , self . default_server ( ) , self . bind ( ) , self . wildcard ( ) , self . ssl ( ) , self . http2 ( ) , self . ipv6only ( ) , self . deferred_accept ( ) , self . reuseport ( ) , self . so_keepalive ( ) , self . proxy_protocol ( ) , self . backlog , self . rcvbuf , self . sndbuf , self . fastopen )
    }
}
impl ngx_http_listen_opt_t {
    #[inline]
    pub fn set(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_set(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn default_server(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_default_server(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bind(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bind(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wildcard(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wildcard(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ssl(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ssl(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn http2(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_http2(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ipv6only(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ipv6only(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn deferred_accept(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_deferred_accept(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reuseport(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reuseport(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn so_keepalive(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_so_keepalive(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn proxy_protocol(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_proxy_protocol(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        set: libc::c_uint,
        default_server: libc::c_uint,
        bind: libc::c_uint,
        wildcard: libc::c_uint,
        ssl: libc::c_uint,
        http2: libc::c_uint,
        ipv6only: libc::c_uint,
        deferred_accept: libc::c_uint,
        reuseport: libc::c_uint,
        so_keepalive: libc::c_uint,
        proxy_protocol: libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let set: u32 = unsafe { ::std::mem::transmute(set) };
            set as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let default_server: u32 = unsafe { ::std::mem::transmute(default_server) };
            default_server as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let bind: u32 = unsafe { ::std::mem::transmute(bind) };
            bind as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let wildcard: u32 = unsafe { ::std::mem::transmute(wildcard) };
            wildcard as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ssl: u32 = unsafe { ::std::mem::transmute(ssl) };
            ssl as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let http2: u32 = unsafe { ::std::mem::transmute(http2) };
            http2 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let ipv6only: u32 = unsafe { ::std::mem::transmute(ipv6only) };
            ipv6only as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let deferred_accept: u32 = unsafe { ::std::mem::transmute(deferred_accept) };
            deferred_accept as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let reuseport: u32 = unsafe { ::std::mem::transmute(reuseport) };
            reuseport as u64
        });
        __bindgen_bitfield_unit.set(9usize, 2u8, {
            let so_keepalive: u32 = unsafe { ::std::mem::transmute(so_keepalive) };
            so_keepalive as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let proxy_protocol: u32 = unsafe { ::std::mem::transmute(proxy_protocol) };
            proxy_protocol as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const NGX_HTTP_POST_READ_PHASE: ngx_http_phases = 0;
pub const NGX_HTTP_SERVER_REWRITE_PHASE: ngx_http_phases = 1;
pub const NGX_HTTP_FIND_CONFIG_PHASE: ngx_http_phases = 2;
pub const NGX_HTTP_REWRITE_PHASE: ngx_http_phases = 3;
pub const NGX_HTTP_POST_REWRITE_PHASE: ngx_http_phases = 4;
pub const NGX_HTTP_PREACCESS_PHASE: ngx_http_phases = 5;
pub const NGX_HTTP_ACCESS_PHASE: ngx_http_phases = 6;
pub const NGX_HTTP_POST_ACCESS_PHASE: ngx_http_phases = 7;
pub const NGX_HTTP_PRECONTENT_PHASE: ngx_http_phases = 8;
pub const NGX_HTTP_CONTENT_PHASE: ngx_http_phases = 9;
pub const NGX_HTTP_LOG_PHASE: ngx_http_phases = 10;
pub type ngx_http_phases = u32;
pub type ngx_http_phase_handler_t = ngx_http_phase_handler_s;
pub type ngx_http_phase_handler_pt = ::std::option::Option<
    unsafe extern "C" fn(
        r: *mut ngx_http_request_t,
        ph: *mut ngx_http_phase_handler_t,
    ) -> ngx_int_t,
>;
#[repr(C)]
pub struct ngx_http_phase_handler_s {
    pub checker: ngx_http_phase_handler_pt,
    pub handler: ngx_http_handler_pt,
    pub next: ngx_uint_t,
}
impl ::std::fmt::Debug for ngx_http_phase_handler_s {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_http_phase_handler_s {{ checker: {:?}, handler: {:?} }}",
            self.checker, self.handler
        )
    }
}
#[repr(C)]
pub struct ngx_http_phase_engine_t {
    pub handlers: *mut ngx_http_phase_handler_t,
    pub server_rewrite_index: ngx_uint_t,
    pub location_rewrite_index: ngx_uint_t,
}
impl ::std::fmt::Debug for ngx_http_phase_engine_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_http_phase_engine_t {{ handlers: {:?} }}",
            self.handlers
        )
    }
}
#[repr(C)]
pub struct ngx_http_phase_t {
    pub handlers: ngx_array_t,
}
impl ::std::fmt::Debug for ngx_http_phase_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "ngx_http_phase_t {{ handlers: {:?} }}", self.handlers)
    }
}
#[repr(C)]
pub struct ngx_http_core_main_conf_t {
    pub servers: ngx_array_t,
    pub phase_engine: ngx_http_phase_engine_t,
    pub headers_in_hash: ngx_hash_t,
    pub variables_hash: ngx_hash_t,
    pub variables: ngx_array_t,
    pub prefix_variables: ngx_array_t,
    pub ncaptures: ngx_uint_t,
    pub server_names_hash_max_size: ngx_uint_t,
    pub server_names_hash_bucket_size: ngx_uint_t,
    pub variables_hash_max_size: ngx_uint_t,
    pub variables_hash_bucket_size: ngx_uint_t,
    pub variables_keys: *mut ngx_hash_keys_arrays_t,
    pub ports: *mut ngx_array_t,
    pub phases: [ngx_http_phase_t; 11usize],
}
impl ::std::fmt::Debug for ngx_http_core_main_conf_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "ngx_http_core_main_conf_t {{ servers: {:?}, phase_engine: {:?}, headers_in_hash: {:?}, variables_hash: {:?}, variables: {:?}, prefix_variables: {:?}, variables_keys: {:?}, ports: {:?}, phases: {:?} }}" , self . servers , self . phase_engine , self . headers_in_hash , self . variables_hash , self . variables , self . prefix_variables , self . variables_keys , self . ports , self . phases )
    }
}
#[repr(C)]
pub struct ngx_http_core_srv_conf_t {
    pub server_names: ngx_array_t,
    pub ctx: *mut ngx_http_conf_ctx_t,
    pub file_name: *mut u_char,
    pub line: ngx_uint_t,
    pub server_name: ngx_str_t,
    pub connection_pool_size: size_t,
    pub request_pool_size: size_t,
    pub client_header_buffer_size: size_t,
    pub large_client_header_buffers: ngx_bufs_t,
    pub client_header_timeout: ngx_msec_t,
    pub ignore_invalid_headers: ngx_flag_t,
    pub merge_slashes: ngx_flag_t,
    pub underscores_in_headers: ngx_flag_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub named_locations: *mut *mut ngx_http_core_loc_conf_t,
}
impl ::std::fmt::Debug for ngx_http_core_srv_conf_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "ngx_http_core_srv_conf_t {{ server_names: {:?}, ctx: {:?}, file_name: {:?}, server_name: {:?}, large_client_header_buffers: {:?}, listen : {:?}, captures : {:?}, named_locations: {:?} }}" , self . server_names , self . ctx , self . file_name , self . server_name , self . large_client_header_buffers , self . listen ( ) , self . captures ( ) , self . named_locations )
    }
}
impl ngx_http_core_srv_conf_t {
    #[inline]
    pub fn listen(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_listen(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn captures(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_captures(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        listen: libc::c_uint,
        captures: libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let listen: u32 = unsafe { ::std::mem::transmute(listen) };
            listen as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let captures: u32 = unsafe { ::std::mem::transmute(captures) };
            captures as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct ngx_http_server_name_t {
    pub regex: *mut ngx_http_regex_t,
    pub server: *mut ngx_http_core_srv_conf_t,
    pub name: ngx_str_t,
}
impl ::std::fmt::Debug for ngx_http_server_name_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_http_server_name_t {{ regex: {:?}, server: {:?}, name: {:?} }}",
            self.regex, self.server, self.name
        )
    }
}
#[repr(C)]
pub struct ngx_http_virtual_names_t {
    pub names: ngx_hash_combined_t,
    pub nregex: ngx_uint_t,
    pub regex: *mut ngx_http_server_name_t,
}
impl ::std::fmt::Debug for ngx_http_virtual_names_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_http_virtual_names_t {{ names: {:?}, regex: {:?} }}",
            self.names, self.regex
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_addr_conf_s {
    pub default_server: *mut ngx_http_core_srv_conf_t,
    pub virtual_names: *mut ngx_http_virtual_names_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl ngx_http_addr_conf_s {
    #[inline]
    pub fn ssl(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ssl(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn http2(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_http2(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn proxy_protocol(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_proxy_protocol(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ssl: libc::c_uint,
        http2: libc::c_uint,
        proxy_protocol: libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ssl: u32 = unsafe { ::std::mem::transmute(ssl) };
            ssl as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let http2: u32 = unsafe { ::std::mem::transmute(http2) };
            http2 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let proxy_protocol: u32 = unsafe { ::std::mem::transmute(proxy_protocol) };
            proxy_protocol as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct ngx_http_in_addr_t {
    pub addr: in_addr_t,
    pub conf: ngx_http_addr_conf_t,
}
impl ::std::fmt::Debug for ngx_http_in_addr_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "ngx_http_in_addr_t {{ conf: {:?} }}", self.conf)
    }
}
#[repr(C)]
pub struct ngx_http_in6_addr_t {
    pub addr6: in6_addr,
    pub conf: ngx_http_addr_conf_t,
}
impl ::std::fmt::Debug for ngx_http_in6_addr_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "ngx_http_in6_addr_t {{ conf: {:?} }}", self.conf)
    }
}
#[repr(C)]
pub struct ngx_http_port_t {
    pub addrs: *mut libc::c_void,
    pub naddrs: ngx_uint_t,
}
impl ::std::fmt::Debug for ngx_http_port_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "ngx_http_port_t {{ addrs: {:?} }}", self.addrs)
    }
}
#[repr(C)]
pub struct ngx_http_conf_port_t {
    pub family: ngx_int_t,
    pub port: in_port_t,
    pub addrs: ngx_array_t,
}
impl ::std::fmt::Debug for ngx_http_conf_port_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "ngx_http_conf_port_t {{ addrs: {:?} }}", self.addrs)
    }
}
#[repr(C)]
pub struct ngx_http_conf_addr_t {
    pub opt: ngx_http_listen_opt_t,
    pub hash: ngx_hash_t,
    pub wc_head: *mut ngx_hash_wildcard_t,
    pub wc_tail: *mut ngx_hash_wildcard_t,
    pub nregex: ngx_uint_t,
    pub regex: *mut ngx_http_server_name_t,
    pub default_server: *mut ngx_http_core_srv_conf_t,
    pub servers: ngx_array_t,
}
impl ::std::fmt::Debug for ngx_http_conf_addr_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "ngx_http_conf_addr_t {{ opt: {:?}, hash: {:?}, wc_head: {:?}, wc_tail: {:?}, regex: {:?}, default_server: {:?}, servers: {:?} }}" , self . opt , self . hash , self . wc_head , self . wc_tail , self . regex , self . default_server , self . servers )
    }
}
#[repr(C)]
pub struct ngx_http_err_page_t {
    pub status: ngx_int_t,
    pub overwrite: ngx_int_t,
    pub value: ngx_http_complex_value_t,
    pub args: ngx_str_t,
}
impl ::std::fmt::Debug for ngx_http_err_page_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_http_err_page_t {{ value: {:?}, args: {:?} }}",
            self.value, self.args
        )
    }
}
#[repr(C)]
pub struct ngx_http_core_loc_conf_s {
    pub name: ngx_str_t,
    pub regex: *mut ngx_http_regex_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub static_locations: *mut ngx_http_location_tree_node_t,
    pub regex_locations: *mut *mut ngx_http_core_loc_conf_t,
    pub loc_conf: *mut *mut libc::c_void,
    pub limit_except: u32,
    pub limit_except_loc_conf: *mut *mut libc::c_void,
    pub handler: ngx_http_handler_pt,
    pub alias: size_t,
    pub root: ngx_str_t,
    pub post_action: ngx_str_t,
    pub root_lengths: *mut ngx_array_t,
    pub root_values: *mut ngx_array_t,
    pub types: *mut ngx_array_t,
    pub types_hash: ngx_hash_t,
    pub default_type: ngx_str_t,
    pub client_max_body_size: off_t,
    pub directio: off_t,
    pub directio_alignment: off_t,
    pub client_body_buffer_size: size_t,
    pub send_lowat: size_t,
    pub postpone_output: size_t,
    pub sendfile_max_chunk: size_t,
    pub read_ahead: size_t,
    pub subrequest_output_buffer_size: size_t,
    pub limit_rate: *mut ngx_http_complex_value_t,
    pub limit_rate_after: *mut ngx_http_complex_value_t,
    pub client_body_timeout: ngx_msec_t,
    pub send_timeout: ngx_msec_t,
    pub keepalive_timeout: ngx_msec_t,
    pub lingering_time: ngx_msec_t,
    pub lingering_timeout: ngx_msec_t,
    pub resolver_timeout: ngx_msec_t,
    pub resolver: *mut ngx_resolver_t,
    pub keepalive_header: time_t,
    pub keepalive_requests: ngx_uint_t,
    pub keepalive_disable: ngx_uint_t,
    pub satisfy: ngx_uint_t,
    pub lingering_close: ngx_uint_t,
    pub if_modified_since: ngx_uint_t,
    pub max_ranges: ngx_uint_t,
    pub client_body_in_file_only: ngx_uint_t,
    pub client_body_in_single_buffer: ngx_flag_t,
    pub internal: ngx_flag_t,
    pub sendfile: ngx_flag_t,
    pub aio: ngx_flag_t,
    pub aio_write: ngx_flag_t,
    pub tcp_nopush: ngx_flag_t,
    pub tcp_nodelay: ngx_flag_t,
    pub reset_timedout_connection: ngx_flag_t,
    pub absolute_redirect: ngx_flag_t,
    pub server_name_in_redirect: ngx_flag_t,
    pub port_in_redirect: ngx_flag_t,
    pub msie_padding: ngx_flag_t,
    pub msie_refresh: ngx_flag_t,
    pub log_not_found: ngx_flag_t,
    pub log_subrequest: ngx_flag_t,
    pub recursive_error_pages: ngx_flag_t,
    pub server_tokens: ngx_uint_t,
    pub chunked_transfer_encoding: ngx_flag_t,
    pub etag: ngx_flag_t,
    pub gzip_vary: ngx_flag_t,
    pub gzip_http_version: ngx_uint_t,
    pub gzip_proxied: ngx_uint_t,
    pub gzip_disable: *mut ngx_array_t,
    pub disable_symlinks: ngx_uint_t,
    pub disable_symlinks_from: *mut ngx_http_complex_value_t,
    pub error_pages: *mut ngx_array_t,
    pub client_body_temp_path: *mut ngx_path_t,
    pub open_file_cache: *mut ngx_open_file_cache_t,
    pub open_file_cache_valid: time_t,
    pub open_file_cache_min_uses: ngx_uint_t,
    pub open_file_cache_errors: ngx_flag_t,
    pub open_file_cache_events: ngx_flag_t,
    pub error_log: *mut ngx_log_t,
    pub types_hash_max_size: ngx_uint_t,
    pub types_hash_bucket_size: ngx_uint_t,
    pub locations: *mut ngx_queue_t,
}
impl ::std::fmt::Debug for ngx_http_core_loc_conf_s {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "ngx_http_core_loc_conf_s {{ name: {:?}, regex: {:?}, noname : {:?}, lmt_excpt : {:?}, named : {:?}, exact_match : {:?}, noregex : {:?}, auto_redirect : {:?}, gzip_disable_msie6 : {:?}, gzip_disable_degradation : {:?}, static_locations: {:?}, regex_locations: {:?}, loc_conf: {:?}, limit_except_loc_conf: {:?}, handler: {:?}, root: {:?}, post_action: {:?}, root_lengths: {:?}, root_values: {:?}, types: {:?}, types_hash: {:?}, default_type: {:?}, limit_rate: {:?}, limit_rate_after: {:?}, resolver: {:?}, gzip_disable: {:?}, disable_symlinks_from: {:?}, error_pages: {:?}, client_body_temp_path: {:?}, open_file_cache: {:?}, error_log: {:?}, locations: {:?} }}" , self . name , self . regex , self . noname ( ) , self . lmt_excpt ( ) , self . named ( ) , self . exact_match ( ) , self . noregex ( ) , self . auto_redirect ( ) , self . gzip_disable_msie6 ( ) , self . gzip_disable_degradation ( ) , self . static_locations , self . regex_locations , self . loc_conf , self . limit_except_loc_conf , self . handler , self . root , self . post_action , self . root_lengths , self . root_values , self . types , self . types_hash , self . default_type , self . limit_rate , self . limit_rate_after , self . resolver , self . gzip_disable , self . disable_symlinks_from , self . error_pages , self . client_body_temp_path , self . open_file_cache , self . error_log , self . locations )
    }
}
impl ngx_http_core_loc_conf_s {
    #[inline]
    pub fn noname(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_noname(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lmt_excpt(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lmt_excpt(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn named(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_named(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn exact_match(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_exact_match(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn noregex(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_noregex(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn auto_redirect(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_auto_redirect(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn gzip_disable_msie6(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_gzip_disable_msie6(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn gzip_disable_degradation(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_gzip_disable_degradation(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        noname: libc::c_uint,
        lmt_excpt: libc::c_uint,
        named: libc::c_uint,
        exact_match: libc::c_uint,
        noregex: libc::c_uint,
        auto_redirect: libc::c_uint,
        gzip_disable_msie6: libc::c_uint,
        gzip_disable_degradation: libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let noname: u32 = unsafe { ::std::mem::transmute(noname) };
            noname as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let lmt_excpt: u32 = unsafe { ::std::mem::transmute(lmt_excpt) };
            lmt_excpt as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let named: u32 = unsafe { ::std::mem::transmute(named) };
            named as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let exact_match: u32 = unsafe { ::std::mem::transmute(exact_match) };
            exact_match as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let noregex: u32 = unsafe { ::std::mem::transmute(noregex) };
            noregex as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let auto_redirect: u32 = unsafe { ::std::mem::transmute(auto_redirect) };
            auto_redirect as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let gzip_disable_msie6: u32 = unsafe { ::std::mem::transmute(gzip_disable_msie6) };
            gzip_disable_msie6 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let gzip_disable_degradation: u32 =
                unsafe { ::std::mem::transmute(gzip_disable_degradation) };
            gzip_disable_degradation as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct ngx_http_location_queue_t {
    pub queue: ngx_queue_t,
    pub exact: *mut ngx_http_core_loc_conf_t,
    pub inclusive: *mut ngx_http_core_loc_conf_t,
    pub name: *mut ngx_str_t,
    pub file_name: *mut u_char,
    pub line: ngx_uint_t,
    pub list: ngx_queue_t,
}
impl ::std::fmt::Debug for ngx_http_location_queue_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "ngx_http_location_queue_t {{ queue: {:?}, exact: {:?}, inclusive: {:?}, name: {:?}, file_name: {:?}, list: {:?} }}" , self . queue , self . exact , self . inclusive , self . name , self . file_name , self . list )
    }
}
#[repr(C)]
pub struct ngx_http_location_tree_node_s {
    pub left: *mut ngx_http_location_tree_node_t,
    pub right: *mut ngx_http_location_tree_node_t,
    pub tree: *mut ngx_http_location_tree_node_t,
    pub exact: *mut ngx_http_core_loc_conf_t,
    pub inclusive: *mut ngx_http_core_loc_conf_t,
    pub auto_redirect: u_char,
    pub len: u_char,
    pub name: [u_char; 1usize],
}
impl ::std::fmt::Debug for ngx_http_location_tree_node_s {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "ngx_http_location_tree_node_s {{ left: {:?}, right: {:?}, tree: {:?}, exact: {:?}, inclusive: {:?}, name: {:?} }}" , self . left , self . right , self . tree , self . exact , self . inclusive , self . name )
    }
}
extern "C" {
    pub fn ngx_http_core_run_phases(r: *mut ngx_http_request_t);
}
extern "C" {
    pub fn ngx_http_core_generic_phase(
        r: *mut ngx_http_request_t,
        ph: *mut ngx_http_phase_handler_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_core_rewrite_phase(
        r: *mut ngx_http_request_t,
        ph: *mut ngx_http_phase_handler_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_core_find_config_phase(
        r: *mut ngx_http_request_t,
        ph: *mut ngx_http_phase_handler_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_core_post_rewrite_phase(
        r: *mut ngx_http_request_t,
        ph: *mut ngx_http_phase_handler_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_core_access_phase(
        r: *mut ngx_http_request_t,
        ph: *mut ngx_http_phase_handler_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_core_post_access_phase(
        r: *mut ngx_http_request_t,
        ph: *mut ngx_http_phase_handler_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_core_content_phase(
        r: *mut ngx_http_request_t,
        ph: *mut ngx_http_phase_handler_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_test_content_type(
        r: *mut ngx_http_request_t,
        types_hash: *mut ngx_hash_t,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn ngx_http_set_content_type(r: *mut ngx_http_request_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_set_exten(r: *mut ngx_http_request_t);
}
extern "C" {
    pub fn ngx_http_set_etag(r: *mut ngx_http_request_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_weak_etag(r: *mut ngx_http_request_t);
}
extern "C" {
    pub fn ngx_http_send_response(
        r: *mut ngx_http_request_t,
        status: ngx_uint_t,
        ct: *mut ngx_str_t,
        cv: *mut ngx_http_complex_value_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_map_uri_to_path(
        r: *mut ngx_http_request_t,
        name: *mut ngx_str_t,
        root_length: *mut size_t,
        reserved: size_t,
    ) -> *mut u_char;
}
extern "C" {
    pub fn ngx_http_auth_basic_user(r: *mut ngx_http_request_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_gzip_ok(r: *mut ngx_http_request_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_subrequest(
        r: *mut ngx_http_request_t,
        uri: *mut ngx_str_t,
        args: *mut ngx_str_t,
        sr: *mut *mut ngx_http_request_t,
        psr: *mut ngx_http_post_subrequest_t,
        flags: ngx_uint_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_internal_redirect(
        r: *mut ngx_http_request_t,
        uri: *mut ngx_str_t,
        args: *mut ngx_str_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_named_location(r: *mut ngx_http_request_t, name: *mut ngx_str_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_cleanup_add(
        r: *mut ngx_http_request_t,
        size: size_t,
    ) -> *mut ngx_http_cleanup_t;
}
pub type ngx_http_output_header_filter_pt =
    ::std::option::Option<unsafe extern "C" fn(r: *mut ngx_http_request_t) -> ngx_int_t>;
pub type ngx_http_output_body_filter_pt = ::std::option::Option<
    unsafe extern "C" fn(r: *mut ngx_http_request_t, chain: *mut ngx_chain_t) -> ngx_int_t,
>;
pub type ngx_http_request_body_filter_pt = ::std::option::Option<
    unsafe extern "C" fn(r: *mut ngx_http_request_t, chain: *mut ngx_chain_t) -> ngx_int_t,
>;
extern "C" {
    pub fn ngx_http_output_filter(r: *mut ngx_http_request_t, chain: *mut ngx_chain_t)
        -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_write_filter(r: *mut ngx_http_request_t, chain: *mut ngx_chain_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_request_body_save_filter(
        r: *mut ngx_http_request_t,
        chain: *mut ngx_chain_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_set_disable_symlinks(
        r: *mut ngx_http_request_t,
        clcf: *mut ngx_http_core_loc_conf_t,
        path: *mut ngx_str_t,
        of: *mut ngx_open_file_info_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_get_forwarded_addr(
        r: *mut ngx_http_request_t,
        addr: *mut ngx_addr_t,
        headers: *mut ngx_array_t,
        value: *mut ngx_str_t,
        proxies: *mut ngx_array_t,
        recursive: libc::c_int,
    ) -> ngx_int_t;
}
extern "C" {
    pub static mut ngx_http_core_module: ngx_module_t;
}
extern "C" {
    pub static mut ngx_http_max_module: ngx_uint_t;
}
extern "C" {
    pub static mut ngx_http_core_get_method: ngx_str_t;
}
#[repr(C)]
pub struct ngx_http_cache_valid_t {
    pub status: ngx_uint_t,
    pub valid: time_t,
}
impl ::std::fmt::Debug for ngx_http_cache_valid_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "ngx_http_cache_valid_t {{  }}")
    }
}
#[repr(C)]
pub struct ngx_http_file_cache_node_t {
    pub node: ngx_rbtree_node_t,
    pub queue: ngx_queue_t,
    pub key: [u_char; 8usize],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u32>,
    pub uniq: ngx_file_uniq_t,
    pub expire: time_t,
    pub valid_sec: time_t,
    pub body_start: size_t,
    pub fs_size: off_t,
    pub lock_time: ngx_msec_t,
}
impl ::std::fmt::Debug for ngx_http_file_cache_node_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "ngx_http_file_cache_node_t {{ node: {:?}, queue: {:?}, key: {:?}, count : {:?}, uses : {:?}, valid_msec : {:?}, error : {:?}, exists : {:?}, updating : {:?}, deleting : {:?}, purged : {:?} }}" , self . node , self . queue , self . key , self . count ( ) , self . uses ( ) , self . valid_msec ( ) , self . error ( ) , self . exists ( ) , self . updating ( ) , self . deleting ( ) , self . purged ( ) )
    }
}
impl ngx_http_file_cache_node_t {
    #[inline]
    pub fn count(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_count(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn uses(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_uses(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn valid_msec(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_valid_msec(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn error(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(42usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_error(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(42usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn exists(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(52usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_exists(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(52usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn updating(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(53usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_updating(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(53usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn deleting(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(54usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_deleting(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(54usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn purged(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(55usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_purged(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(55usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        count: libc::c_uint,
        uses: libc::c_uint,
        valid_msec: libc::c_uint,
        error: libc::c_uint,
        exists: libc::c_uint,
        updating: libc::c_uint,
        deleting: libc::c_uint,
        purged: libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 8usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let count: u32 = unsafe { ::std::mem::transmute(count) };
            count as u64
        });
        __bindgen_bitfield_unit.set(20usize, 10u8, {
            let uses: u32 = unsafe { ::std::mem::transmute(uses) };
            uses as u64
        });
        __bindgen_bitfield_unit.set(32usize, 10u8, {
            let valid_msec: u32 = unsafe { ::std::mem::transmute(valid_msec) };
            valid_msec as u64
        });
        __bindgen_bitfield_unit.set(42usize, 10u8, {
            let error: u32 = unsafe { ::std::mem::transmute(error) };
            error as u64
        });
        __bindgen_bitfield_unit.set(52usize, 1u8, {
            let exists: u32 = unsafe { ::std::mem::transmute(exists) };
            exists as u64
        });
        __bindgen_bitfield_unit.set(53usize, 1u8, {
            let updating: u32 = unsafe { ::std::mem::transmute(updating) };
            updating as u64
        });
        __bindgen_bitfield_unit.set(54usize, 1u8, {
            let deleting: u32 = unsafe { ::std::mem::transmute(deleting) };
            deleting as u64
        });
        __bindgen_bitfield_unit.set(55usize, 1u8, {
            let purged: u32 = unsafe { ::std::mem::transmute(purged) };
            purged as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct ngx_http_cache_s {
    pub file: ngx_file_t,
    pub keys: ngx_array_t,
    pub crc32: u32,
    pub key: [u_char; 16usize],
    pub main: [u_char; 16usize],
    pub uniq: ngx_file_uniq_t,
    pub valid_sec: time_t,
    pub updating_sec: time_t,
    pub error_sec: time_t,
    pub last_modified: time_t,
    pub date: time_t,
    pub etag: ngx_str_t,
    pub vary: ngx_str_t,
    pub variant: [u_char; 16usize],
    pub header_start: size_t,
    pub body_start: size_t,
    pub length: off_t,
    pub fs_size: off_t,
    pub min_uses: ngx_uint_t,
    pub error: ngx_uint_t,
    pub valid_msec: ngx_uint_t,
    pub vary_tag: ngx_uint_t,
    pub buf: *mut ngx_buf_t,
    pub file_cache: *mut ngx_http_file_cache_t,
    pub node: *mut ngx_http_file_cache_node_t,
    pub lock_timeout: ngx_msec_t,
    pub lock_age: ngx_msec_t,
    pub lock_time: ngx_msec_t,
    pub wait_time: ngx_msec_t,
    pub wait_event: ngx_event_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub __bindgen_padding_0: [u16; 3usize],
}
impl ::std::fmt::Debug for ngx_http_cache_s {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "ngx_http_cache_s {{ file: {:?}, keys: {:?}, key: {:?}, main: {:?}, etag: {:?}, vary: {:?}, variant: {:?}, buf: {:?}, file_cache: {:?}, node: {:?}, wait_event: {:?}, lock : {:?}, waiting : {:?}, updated : {:?}, updating : {:?}, exists : {:?}, temp_file : {:?}, purged : {:?}, reading : {:?}, secondary : {:?}, background : {:?}, stale_updating : {:?}, stale_error : {:?} }}" , self . file , self . keys , self . key , self . main , self . etag , self . vary , self . variant , self . buf , self . file_cache , self . node , self . wait_event , self . lock ( ) , self . waiting ( ) , self . updated ( ) , self . updating ( ) , self . exists ( ) , self . temp_file ( ) , self . purged ( ) , self . reading ( ) , self . secondary ( ) , self . background ( ) , self . stale_updating ( ) , self . stale_error ( ) )
    }
}
impl ngx_http_cache_s {
    #[inline]
    pub fn lock(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lock(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn waiting(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_waiting(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn updated(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_updated(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn updating(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_updating(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn exists(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_exists(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn temp_file(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_temp_file(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn purged(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_purged(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reading(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reading(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn secondary(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_secondary(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn background(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_background(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn stale_updating(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_stale_updating(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn stale_error(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_stale_error(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        lock: libc::c_uint,
        waiting: libc::c_uint,
        updated: libc::c_uint,
        updating: libc::c_uint,
        exists: libc::c_uint,
        temp_file: libc::c_uint,
        purged: libc::c_uint,
        reading: libc::c_uint,
        secondary: libc::c_uint,
        background: libc::c_uint,
        stale_updating: libc::c_uint,
        stale_error: libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let lock: u32 = unsafe { ::std::mem::transmute(lock) };
            lock as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let waiting: u32 = unsafe { ::std::mem::transmute(waiting) };
            waiting as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let updated: u32 = unsafe { ::std::mem::transmute(updated) };
            updated as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let updating: u32 = unsafe { ::std::mem::transmute(updating) };
            updating as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let exists: u32 = unsafe { ::std::mem::transmute(exists) };
            exists as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let temp_file: u32 = unsafe { ::std::mem::transmute(temp_file) };
            temp_file as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let purged: u32 = unsafe { ::std::mem::transmute(purged) };
            purged as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let reading: u32 = unsafe { ::std::mem::transmute(reading) };
            reading as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let secondary: u32 = unsafe { ::std::mem::transmute(secondary) };
            secondary as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let background: u32 = unsafe { ::std::mem::transmute(background) };
            background as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let stale_updating: u32 = unsafe { ::std::mem::transmute(stale_updating) };
            stale_updating as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let stale_error: u32 = unsafe { ::std::mem::transmute(stale_error) };
            stale_error as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct ngx_http_file_cache_header_t {
    pub version: ngx_uint_t,
    pub valid_sec: time_t,
    pub updating_sec: time_t,
    pub error_sec: time_t,
    pub last_modified: time_t,
    pub date: time_t,
    pub crc32: u32,
    pub valid_msec: u_short,
    pub header_start: u_short,
    pub body_start: u_short,
    pub etag_len: u_char,
    pub etag: [u_char; 128usize],
    pub vary_len: u_char,
    pub vary: [u_char; 128usize],
    pub variant: [u_char; 16usize],
}
impl ::std::fmt::Debug for ngx_http_file_cache_header_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_http_file_cache_header_t {{ etag: [{}], vary: [{}], variant: {:?} }}",
            self.etag
                .iter()
                .enumerate()
                .map(|(i, v)| format!("{}{:?}", if i > 0 { ", " } else { "" }, v))
                .collect::<String>(),
            self.vary
                .iter()
                .enumerate()
                .map(|(i, v)| format!("{}{:?}", if i > 0 { ", " } else { "" }, v))
                .collect::<String>(),
            self.variant
        )
    }
}
#[repr(C)]
pub struct ngx_http_file_cache_sh_t {
    pub rbtree: ngx_rbtree_t,
    pub sentinel: ngx_rbtree_node_t,
    pub queue: ngx_queue_t,
    pub cold: ngx_atomic_t,
    pub loading: ngx_atomic_t,
    pub size: off_t,
    pub count: ngx_uint_t,
    pub watermark: ngx_uint_t,
}
impl ::std::fmt::Debug for ngx_http_file_cache_sh_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_http_file_cache_sh_t {{ rbtree: {:?}, sentinel: {:?}, queue: {:?} }}",
            self.rbtree, self.sentinel, self.queue
        )
    }
}
#[repr(C)]
pub struct ngx_http_file_cache_s {
    pub sh: *mut ngx_http_file_cache_sh_t,
    pub shpool: *mut ngx_slab_pool_t,
    pub path: *mut ngx_path_t,
    pub max_size: off_t,
    pub bsize: size_t,
    pub inactive: time_t,
    pub fail_time: time_t,
    pub files: ngx_uint_t,
    pub loader_files: ngx_uint_t,
    pub last: ngx_msec_t,
    pub loader_sleep: ngx_msec_t,
    pub loader_threshold: ngx_msec_t,
    pub manager_files: ngx_uint_t,
    pub manager_sleep: ngx_msec_t,
    pub manager_threshold: ngx_msec_t,
    pub shm_zone: *mut ngx_shm_zone_t,
    pub use_temp_path: ngx_uint_t,
}
impl ::std::fmt::Debug for ngx_http_file_cache_s {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_http_file_cache_s {{ sh: {:?}, shpool: {:?}, path: {:?}, shm_zone: {:?} }}",
            self.sh, self.shpool, self.path, self.shm_zone
        )
    }
}
extern "C" {
    pub fn ngx_http_file_cache_new(r: *mut ngx_http_request_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_file_cache_create(r: *mut ngx_http_request_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_file_cache_create_key(r: *mut ngx_http_request_t);
}
extern "C" {
    pub fn ngx_http_file_cache_open(r: *mut ngx_http_request_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_file_cache_set_header(
        r: *mut ngx_http_request_t,
        buf: *mut u_char,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_file_cache_update(r: *mut ngx_http_request_t, tf: *mut ngx_temp_file_t);
}
extern "C" {
    pub fn ngx_http_file_cache_update_header(r: *mut ngx_http_request_t);
}
extern "C" {
    pub fn ngx_http_cache_send(arg1: *mut ngx_http_request_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_file_cache_free(c: *mut ngx_http_cache_t, tf: *mut ngx_temp_file_t);
}
extern "C" {
    pub fn ngx_http_file_cache_valid(cache_valid: *mut ngx_array_t, status: ngx_uint_t) -> time_t;
}
extern "C" {
    pub fn ngx_http_file_cache_set_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut libc::c_void,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn ngx_http_file_cache_valid_set_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut libc::c_void,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub static mut ngx_http_cache_status: [ngx_str_t; 0usize];
}
#[repr(C)]
pub struct ngx_http_ssi_main_conf_t {
    pub hash: ngx_hash_t,
    pub commands: ngx_hash_keys_arrays_t,
}
impl ::std::fmt::Debug for ngx_http_ssi_main_conf_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_http_ssi_main_conf_t {{ hash: {:?}, commands: {:?} }}",
            self.hash, self.commands
        )
    }
}
#[repr(C)]
pub struct ngx_http_ssi_ctx_t {
    pub buf: *mut ngx_buf_t,
    pub pos: *mut u_char,
    pub copy_start: *mut u_char,
    pub copy_end: *mut u_char,
    pub key: ngx_uint_t,
    pub command: ngx_str_t,
    pub params: ngx_array_t,
    pub param: *mut ngx_table_elt_t,
    pub params_array: [ngx_table_elt_t; 4usize],
    pub in_: *mut ngx_chain_t,
    pub out: *mut ngx_chain_t,
    pub last_out: *mut *mut ngx_chain_t,
    pub busy: *mut ngx_chain_t,
    pub free: *mut ngx_chain_t,
    pub state: ngx_uint_t,
    pub saved_state: ngx_uint_t,
    pub saved: size_t,
    pub looked: size_t,
    pub value_len: size_t,
    pub variables: *mut ngx_list_t,
    pub blocks: *mut ngx_array_t,
    pub ncaptures: ngx_uint_t,
    pub captures: *mut libc::c_int,
    pub captures_data: *mut u_char,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub wait: *mut ngx_http_request_t,
    pub value_buf: *mut libc::c_void,
    pub timefmt: ngx_str_t,
    pub errmsg: ngx_str_t,
}
impl ::std::fmt::Debug for ngx_http_ssi_ctx_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "ngx_http_ssi_ctx_t {{ buf: {:?}, pos: {:?}, copy_start: {:?}, copy_end: {:?}, command: {:?}, params: {:?}, param: {:?}, params_array: {:?}, in: {:?}, out: {:?}, last_out: {:?}, busy: {:?}, free: {:?}, variables: {:?}, blocks: {:?}, captures: {:?}, captures_data: {:?}, conditional : {:?}, encoding : {:?}, block : {:?}, output : {:?}, output_chosen : {:?}, wait: {:?}, value_buf: {:?}, timefmt: {:?}, errmsg: {:?} }}" , self . buf , self . pos , self . copy_start , self . copy_end , self . command , self . params , self . param , self . params_array , self . in_ , self . out , self . last_out , self . busy , self . free , self . variables , self . blocks , self . captures , self . captures_data , self . conditional ( ) , self . encoding ( ) , self . block ( ) , self . output ( ) , self . output_chosen ( ) , self . wait , self . value_buf , self . timefmt , self . errmsg )
    }
}
impl ngx_http_ssi_ctx_t {
    #[inline]
    pub fn conditional(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_conditional(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn encoding(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_encoding(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn block(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_block(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn output(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_output(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn output_chosen(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_output_chosen(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        conditional: libc::c_uint,
        encoding: libc::c_uint,
        block: libc::c_uint,
        output: libc::c_uint,
        output_chosen: libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let conditional: u32 = unsafe { ::std::mem::transmute(conditional) };
            conditional as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let encoding: u32 = unsafe { ::std::mem::transmute(encoding) };
            encoding as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let block: u32 = unsafe { ::std::mem::transmute(block) };
            block as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let output: u32 = unsafe { ::std::mem::transmute(output) };
            output as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let output_chosen: u32 = unsafe { ::std::mem::transmute(output_chosen) };
            output_chosen as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type ngx_http_ssi_command_pt = ::std::option::Option<
    unsafe extern "C" fn(
        r: *mut ngx_http_request_t,
        ctx: *mut ngx_http_ssi_ctx_t,
        arg1: *mut *mut ngx_str_t,
    ) -> ngx_int_t,
>;
#[repr(C)]
pub struct ngx_http_ssi_param_t {
    pub name: ngx_str_t,
    pub index: ngx_uint_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl ::std::fmt::Debug for ngx_http_ssi_param_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_http_ssi_param_t {{ name: {:?}, mandatory : {:?}, multiple : {:?} }}",
            self.name,
            self.mandatory(),
            self.multiple()
        )
    }
}
impl ngx_http_ssi_param_t {
    #[inline]
    pub fn mandatory(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mandatory(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn multiple(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_multiple(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mandatory: libc::c_uint,
        multiple: libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mandatory: u32 = unsafe { ::std::mem::transmute(mandatory) };
            mandatory as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let multiple: u32 = unsafe { ::std::mem::transmute(multiple) };
            multiple as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct ngx_http_ssi_command_t {
    pub name: ngx_str_t,
    pub handler: ngx_http_ssi_command_pt,
    pub params: *mut ngx_http_ssi_param_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl ::std::fmt::Debug for ngx_http_ssi_command_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! ( f , "ngx_http_ssi_command_t {{ name: {:?}, handler: {:?}, params: {:?}, conditional : {:?}, block : {:?}, flush : {:?} }}" , self . name , self . handler , self . params , self . conditional ( ) , self . block ( ) , self . flush ( ) )
    }
}
impl ngx_http_ssi_command_t {
    #[inline]
    pub fn conditional(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_conditional(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn block(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_block(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flush(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flush(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        conditional: libc::c_uint,
        block: libc::c_uint,
        flush: libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let conditional: u32 = unsafe { ::std::mem::transmute(conditional) };
            conditional as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let block: u32 = unsafe { ::std::mem::transmute(block) };
            block as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let flush: u32 = unsafe { ::std::mem::transmute(flush) };
            flush as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub static mut ngx_http_ssi_filter_module: ngx_module_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_log_ctx_s {
    pub connection: *mut ngx_connection_t,
    pub request: *mut ngx_http_request_t,
    pub current_request: *mut ngx_http_request_t,
}
#[repr(C)]
pub struct ngx_http_chunked_s {
    pub state: ngx_uint_t,
    pub size: off_t,
    pub length: off_t,
}
impl ::std::fmt::Debug for ngx_http_chunked_s {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "ngx_http_chunked_s {{  }}")
    }
}
#[repr(C)]
pub struct ngx_http_status_t {
    pub http_version: ngx_uint_t,
    pub code: ngx_uint_t,
    pub count: ngx_uint_t,
    pub start: *mut u_char,
    pub end: *mut u_char,
}
impl ::std::fmt::Debug for ngx_http_status_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "ngx_http_status_t {{ start: {:?}, end: {:?} }}",
            self.start, self.end
        )
    }
}
extern "C" {
    pub fn ngx_http_add_location(
        cf: *mut ngx_conf_t,
        locations: *mut *mut ngx_queue_t,
        clcf: *mut ngx_http_core_loc_conf_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_add_listen(
        cf: *mut ngx_conf_t,
        cscf: *mut ngx_http_core_srv_conf_t,
        lsopt: *mut ngx_http_listen_opt_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_init_connection(c: *mut ngx_connection_t);
}
extern "C" {
    pub fn ngx_http_close_connection(c: *mut ngx_connection_t);
}
extern "C" {
    pub fn ngx_http_parse_request_line(r: *mut ngx_http_request_t, b: *mut ngx_buf_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_parse_uri(r: *mut ngx_http_request_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_parse_complex_uri(
        r: *mut ngx_http_request_t,
        merge_slashes: ngx_uint_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_parse_status_line(
        r: *mut ngx_http_request_t,
        b: *mut ngx_buf_t,
        status: *mut ngx_http_status_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_parse_unsafe_uri(
        r: *mut ngx_http_request_t,
        uri: *mut ngx_str_t,
        args: *mut ngx_str_t,
        flags: *mut ngx_uint_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_parse_header_line(
        r: *mut ngx_http_request_t,
        b: *mut ngx_buf_t,
        allow_underscores: ngx_uint_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_parse_multi_header_lines(
        headers: *mut ngx_array_t,
        name: *mut ngx_str_t,
        value: *mut ngx_str_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_parse_set_cookie_lines(
        headers: *mut ngx_array_t,
        name: *mut ngx_str_t,
        value: *mut ngx_str_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_arg(
        r: *mut ngx_http_request_t,
        name: *mut u_char,
        len: size_t,
        value: *mut ngx_str_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_split_args(
        r: *mut ngx_http_request_t,
        uri: *mut ngx_str_t,
        args: *mut ngx_str_t,
    );
}
extern "C" {
    pub fn ngx_http_parse_chunked(
        r: *mut ngx_http_request_t,
        b: *mut ngx_buf_t,
        ctx: *mut ngx_http_chunked_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_create_request(c: *mut ngx_connection_t) -> *mut ngx_http_request_t;
}
extern "C" {
    pub fn ngx_http_process_request_uri(r: *mut ngx_http_request_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_process_request_header(r: *mut ngx_http_request_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_process_request(r: *mut ngx_http_request_t);
}
extern "C" {
    pub fn ngx_http_update_location_config(r: *mut ngx_http_request_t);
}
extern "C" {
    pub fn ngx_http_handler(r: *mut ngx_http_request_t);
}
extern "C" {
    pub fn ngx_http_run_posted_requests(c: *mut ngx_connection_t);
}
extern "C" {
    pub fn ngx_http_post_request(
        r: *mut ngx_http_request_t,
        pr: *mut ngx_http_posted_request_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_finalize_request(r: *mut ngx_http_request_t, rc: ngx_int_t);
}
extern "C" {
    pub fn ngx_http_free_request(r: *mut ngx_http_request_t, rc: ngx_int_t);
}
extern "C" {
    pub fn ngx_http_empty_handler(wev: *mut ngx_event_t);
}
extern "C" {
    pub fn ngx_http_request_empty_handler(r: *mut ngx_http_request_t);
}
extern "C" {
    pub fn ngx_http_send_special(r: *mut ngx_http_request_t, flags: ngx_uint_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_read_client_request_body(
        r: *mut ngx_http_request_t,
        post_handler: ngx_http_client_body_handler_pt,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_read_unbuffered_request_body(r: *mut ngx_http_request_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_send_header(r: *mut ngx_http_request_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_special_response_handler(
        r: *mut ngx_http_request_t,
        error: ngx_int_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_filter_finalize_request(
        r: *mut ngx_http_request_t,
        m: *mut ngx_module_t,
        error: ngx_int_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_clean_header(r: *mut ngx_http_request_t);
}
extern "C" {
    pub fn ngx_http_discard_request_body(r: *mut ngx_http_request_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_discarded_request_body_handler(r: *mut ngx_http_request_t);
}
extern "C" {
    pub fn ngx_http_block_reading(r: *mut ngx_http_request_t);
}
extern "C" {
    pub fn ngx_http_test_reading(r: *mut ngx_http_request_t);
}
extern "C" {
    pub fn ngx_http_types_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut libc::c_void,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn ngx_http_merge_types(
        cf: *mut ngx_conf_t,
        keys: *mut *mut ngx_array_t,
        types_hash: *mut ngx_hash_t,
        prev_keys: *mut *mut ngx_array_t,
        prev_types_hash: *mut ngx_hash_t,
        default_types: *mut ngx_str_t,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn ngx_http_set_default_types(
        cf: *mut ngx_conf_t,
        types: *mut *mut ngx_array_t,
        default_type: *mut ngx_str_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub static mut ngx_http_module: ngx_module_t;
}
extern "C" {
    pub static mut ngx_http_html_default_types: [ngx_str_t; 0usize];
}
extern "C" {
    pub static mut ngx_http_top_header_filter: ngx_http_output_header_filter_pt;
}
extern "C" {
    pub static mut ngx_http_top_body_filter: ngx_http_output_body_filter_pt;
}
extern "C" {
    pub static mut ngx_http_top_request_body_filter: ngx_http_request_body_filter_pt;
}
